<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ì¶œì¥ ê³„íš ìˆ˜ë¦½ ì—…ë¬´ ìë™í™” í”„ë¡¬í”„íŠ¸</title>

<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #61CCE9 0%, #A2E559 100%);
    min-height: 100vh;
    padding: 1rem;
  }

  .container {
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border-radius: 20px;
    padding: 2rem;
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
    width: 100%;
    max-width: 1200px;
    margin: 0 auto;
    animation: fadeInUp 0.6s ease-out;
  }

  @keyframes fadeInUp {
    from { opacity: 0; transform: translateY(30px); }
    to { opacity: 1; transform: translateY(0); }
  }

  .header {
    text-align: center;
    margin-bottom: 2rem;
  }

  .header h1 {
    color: #2d3748;
    font-size: 2.5rem;
    font-weight: 700;
    margin-bottom: 0.5rem;
    background: linear-gradient(135deg, #61CCE9, #A2E559);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .header p {
    color: #718096;
    font-size: 1.2rem;
  }

  .step {
    margin-bottom: 2rem;
    opacity: 0.6;
    transition: all 0.3s ease;
  }

  .step.active {
    opacity: 1;
  }

  .step-header {
    display: flex;
    align-items: center;
    margin-bottom: 1rem;
    font-size: 1.3rem;
    font-weight: 600;
    color: #2d3748;
  }

  .step-number {
    background: linear-gradient(135deg, #61CCE9, #A2E559);
    color: white;
    width: 32px;
    height: 32px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 1rem;
    font-size: 1rem;
  }

  .file-upload {
    position: relative;
    display: inline-block;
    width: 100%;
  }

  .file-upload input[type="file"] {
    position: absolute;
    opacity: 0;
    width: 100%;
    height: 100%;
    cursor: pointer;
  }

  .file-upload-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    padding: 1.5rem;
    background: linear-gradient(135deg, #e2e8f0, #cbd5e0);
    border: 2px dashed #a0aec0;
    border-radius: 12px;
    color: #4a5568;
    font-size: 1.1rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .file-upload-btn:hover {
    background: linear-gradient(135deg, #cbd5e0, #a0aec0);
    border-color: #61CCE9;
    transform: translateY(-2px);
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
  }

  .file-upload-btn::before {
    content: 'ğŸ“Š';
    font-size: 1.5rem;
    margin-right: 0.5rem;
  }

  .file-selected {
    background: linear-gradient(135deg, #61CCE9, #A2E559) !important;
    color: white !important;
    border-color: #61CCE9 !important;
  }

  .file-selected::before {
    content: 'âœ…';
  }

  .settings-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 1.5rem;
    margin-bottom: 2rem;
  }

  .setting-card {
    background: linear-gradient(135deg, #f8fafc, #e2e8f0);
    border-radius: 12px;
    padding: 1.5rem;
    border-left: 4px solid #61CCE9;
  }

  .setting-label {
    display: block;
    color: #2d3748;
    font-weight: 600;
    margin-bottom: 0.5rem;
  }

  .setting-input {
    width: 100%;
    padding: 0.8rem;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    font-size: 1rem;
    transition: all 0.3s ease;
  }

  .setting-input:focus {
    outline: none;
    border-color: #61CCE9;
    box-shadow: 0 0 0 3px rgba(97, 204, 233, 0.1);
  }

  .btn {
    padding: 1rem 2rem;
    border: none;
    border-radius: 12px;
    font-size: 1.1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    width: 100%;
    margin-top: 1rem;
  }

  .btn-primary {
    background: linear-gradient(135deg, #61CCE9, #A2E559);
    color: white;
  }

  .btn-success {
    background: linear-gradient(135deg, #48bb78, #38a169);
    color: white;
  }

  .btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 15px 30px rgba(97, 204, 233, 0.4);
  }

  .btn:disabled {
    background: #a0aec0 !important;
    cursor: not-allowed !important;
    transform: none !important;
    box-shadow: none !important;
    opacity: 0.6;
  }

  .result-card {
    background: linear-gradient(135deg, #f7fafc, #edf2f7);
    border-radius: 12px;
    padding: 1.5rem;
    border-left: 4px solid #61CCE9;
    transition: all 0.3s ease;
    margin-top: 1rem;
  }

  .result-card.processing {
    background: linear-gradient(135deg, #fff5f5, #fed7d7);
    border-left-color: #fc8181;
    animation: pulse 2s infinite;
  }

  .result-card.success {
    background: linear-gradient(135deg, #f0fff4, #c6f6d5);
    border-left-color: #48bb78;
  }

  .progress-bar {
    width: 100%;
    height: 8px;
    background: #e2e8f0;
    border-radius: 4px;
    overflow: hidden;
    margin: 1rem 0;
  }

  .progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #61CCE9, #A2E559);
    width: 0%;
    transition: width 0.3s ease;
    position: relative;
  }

  .progress-fill::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
    animation: shimmer 2s infinite;
  }

  @keyframes shimmer {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
  }

  .stats {
    display: flex;
    justify-content: space-around;
    margin: 1rem 0;
    flex-wrap: wrap;
    gap: 1rem;
  }

  .stat-item {
    text-align: center;
    flex: 1;
    min-width: 120px;
  }

  .stat-number {
    font-size: 1.8rem;
    font-weight: 700;
    color: #61CCE9;
    display: block;
  }

  .stat-label {
    color: #718096;
    font-size: 0.9rem;
    margin-top: 0.2rem;
  }

  .loading-spinner {
    display: inline-block;
    width: 20px;
    height: 20px;
    border: 2px solid #f3f3f3;
    border-top: 2px solid #61CCE9;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-right: 0.5rem;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
  }

  #map {
    width: 100%;
    height: 500px;
    margin-top: 1.5rem;
    border-radius: 12px;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
    display: none;
  }

  .schedule-container {
    display: none;
    margin-top: 2rem;
  }

  .day-card {
    background: white;
    border-radius: 12px;
    margin-bottom: 1rem;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    overflow: hidden;
    transition: all 0.3s ease;
  }

  .day-card:hover {
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    transform: translateY(-2px);
  }

  .day-header {
    background: linear-gradient(135deg, #61CCE9, #A2E559);
    color: white;
    padding: 1rem 1.5rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .day-title {
    font-size: 1.3rem;
    font-weight: 600;
  }

  .day-summary {
    font-size: 0.9rem;
    opacity: 0.9;
  }

  .day-cities {
    font-size: 0.85rem;
    opacity: 0.8;
    margin-top: 0.2rem;
  }

  .day-content {
    padding: 1.5rem;
  }

  .visit-item {
    display: flex;
    align-items: center;
    padding: 1rem;
    margin-bottom: 0.5rem;
    background: #f8fafc;
    border-radius: 8px;
    border-left: 4px solid #61CCE9;
  }

  .visit-number {
    background: #61CCE9;
    color: white;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.8rem;
    font-weight: 600;
    margin-right: 1rem;
    flex-shrink: 0;
  }

  .visit-details {
    flex: 1;
  }

  .visit-address {
    font-weight: 600;
    color: #2d3748;
    margin-bottom: 0.2rem;
  }

  .visit-time {
    color: #718096;
    font-size: 0.9rem;
  }

  .visit-city {
    color: #61CCE9;
    font-size: 0.8rem;
    font-weight: 500;
  }

  .total-summary {
    background: linear-gradient(135deg, #f0fff4, #c6f6d5);
    border-radius: 12px;
    padding: 1.5rem;
    margin-top: 2rem;
    border-left: 4px solid #48bb78;
  }

  .summary-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
    margin-top: 1rem;
  }

  .summary-item {
    text-align: center;
  }

  .summary-value {
    font-size: 1.5rem;
    font-weight: 700;
    color: #61CCE9;
  }

  .summary-label {
    color: #2d3748;
    font-size: 0.9rem;
    margin-top: 0.2rem;
  }

  .city-constraint-info {
    background: linear-gradient(135deg, #e6fffa, #b2f5ea);
    border: 1px solid #38b2ac;
    border-radius: 8px;
    padding: 1rem;
    margin-top: 1rem;
    font-size: 0.9rem;
    color: #2c7a7b;
  }

  .city-constraint-info strong {
    color: #234e52;
  }

  .copyright-footer {
    background: linear-gradient(135deg, #2d3748, #4a5568);
    color: white;
    text-align: center;
    padding: 1rem;
    margin-top: 2rem;
    border-radius: 0 0 20px 20px;
    font-size: 0.9rem;
  }

  .copyright-container p {
    margin: 0.2rem 0;
    opacity: 0.9;
  }

  .copyright-container p:first-child {
    font-weight: 600;
  }

  @media (max-width: 768px) {
    .container { padding: 1rem; }
    .header h1 { font-size: 2rem; }
    .settings-grid { grid-template-columns: 1fr; }
    .day-header { flex-direction: column; gap: 0.5rem; }
    .copyright-footer {
      font-size: 0.8rem;
      padding: 0.8rem;
    }
  }
</style>

<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
</head>
<body>
<div class="container">
  <div class="header">
    <h1>ğŸš—ë”°ë¼ì™€ by BTS(Business Trip Secretary)</h1>
    <p>ì¶œì¥ ê³„íš ìˆ˜ë¦½ ì—…ë¬´ ìë™í™” í”„ë¡¬í”„íŠ¸</p>
  </div>

  <!-- Step 1: íŒŒì¼ ì—…ë¡œë“œ -->
  <div class="step active" id="step1">
    <div class="step-header">
      <span class="step-number">1</span>
      ì—‘ì…€ íŒŒì¼ ì—…ë¡œë“œ
    </div>
    <div class="file-upload">
      <input type="file" id="excelFile" accept=".xlsx, .xls">
      <div class="file-upload-btn" id="uploadBtn">
        ì‚¬ì—…ì¥ ì£¼ì†Œ ì—‘ì…€ íŒŒì¼ ì„ íƒí•˜ê¸°
      </div>
    </div>
    <button class="btn btn-primary" id="convertBtn" onclick="processExcel()" disabled>
      ì£¼ì†Œ â†’ ìœ„ê²½ë„ ë³€í™˜ ì‹œì‘
    </button>
  </div>

  <!-- Step 2: ë³€í™˜ ê²°ê³¼ -->
  <div class="step" id="step2">
    <div class="step-header">
      <span class="step-number">2</span>
      ì£¼ì†Œ ë³€í™˜ ê²°ê³¼
    </div>
    <div class="result-card" id="resultCard">
      <div id="result">ğŸ“‹ ì—‘ì…€ íŒŒì¼ì„ ì—…ë¡œë“œí•˜ê³  ë³€í™˜ì„ ì‹œì‘í•´ì£¼ì„¸ìš”</div>
      <div class="progress-bar" id="progressContainer" style="display: none;">
        <div class="progress-fill" id="progressFill"></div>
      </div>
      <div class="stats" id="stats" style="display: none;">
        <div class="stat-item">
          <span class="stat-number" id="totalCount">0</span>
          <span class="stat-label">ì „ì²´ ì£¼ì†Œ</span>
        </div>
        <div class="stat-item">
          <span class="stat-number" id="successCount">0</span>
          <span class="stat-label">ë³€í™˜ ì„±ê³µ</span>
        </div>
        <div class="stat-item">
          <span class="stat-number" id="failCount">0</span>
          <span class="stat-label">ë³€í™˜ ì‹¤íŒ¨</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Step 3: ìŠ¤ì¼€ì¤„ ì„¤ì • -->
  <div class="step" id="step3">
    <div class="step-header">
      <span class="step-number">3</span>
      ë°©ë¬¸ ì¼ì • ì„¤ì •
    </div>
    <div class="settings-grid">
      <div class="setting-card">
        <label class="setting-label">â° ì¼ì¼ ìµœëŒ€ ì—…ë¬´ì‹œê°„ (ì‹œê°„)</label>
        <input type="number" class="setting-input" id="maxWorkHours" value="8" min="1" max="12">
      </div>
      <div class="setting-card">
        <label class="setting-label">ğŸ“ ì¼ì¼ ë°©ë¬¸ì—…ì²´ìˆ˜</label>
        <input type="number" class="setting-input" id="maxVisitsPerDay" value="4" min="2" max="20">
        <small style="color: #718096; font-size: 0.8rem; margin-top: 0.3rem; display: block;">
          ì„¤ì •ê°’-1 ~ ì„¤ì •ê°’ ë²”ìœ„ë¡œ ì¡°ì •ë©ë‹ˆë‹¤ (ì˜ˆ: 4 ì„¤ì •ì‹œ 3~4ê°œì†Œ)
        </small>
      </div>
      <div class="setting-card">
        <label class="setting-label">ğŸ• í‰ê·  ì²´ë¥˜ì‹œê°„ (ë¶„)</label>
        <input type="number" class="setting-input" id="avgStayTime" value="60" min="15" max="480">
      </div>
      <div class="setting-card">
        <label class="setting-label">ğŸ  ì¶œë°œì§€ ì£¼ì†Œ</label>
        <input type="text" class="setting-input" id="startLocation" placeholder="ì˜ˆ: ì„œìš¸ì‹œ ê°•ë‚¨êµ¬ í…Œí—¤ë€ë¡œ 123">
      </div>
    </div>
    
    <div class="city-constraint-info">
      <strong>ğŸ™ï¸ ìµœì í™” ì œì•½ ì¡°ê±´</strong><br>
      â€¢ ê°™ì€ ì‹œ(å¸‚) ë‚´ì˜ ì—…ì²´ë“¤ì„ ìš°ì„ ì ìœ¼ë¡œ ë¬¶ì–´ì„œ ë°©ë¬¸í•©ë‹ˆë‹¤<br>
      â€¢ í•˜ë£¨ì— ìµœëŒ€ 3ê°œ ì‹œê¹Œì§€ë§Œ ë°©ë¬¸í•˜ì—¬ ì§€ì—­ ì§‘ì¤‘ë„ë¥¼ ë†’ì…ë‹ˆë‹¤<br>
      â€¢ <strong>ë°©ë¬¸ì§€ ê°„ í•˜ë£¨ ì´ ì´ë™ê±°ë¦¬ 80km ì´ë‚´ë¡œ ì œí•œí•©ë‹ˆë‹¤</strong><br>
      â€¢ ì¶œë°œì§€ ì™•ë³µ ê±°ë¦¬ëŠ” ë³„ë„ì´ë©°, ìˆœìˆ˜ ì—…ì²´ ê°„ ì´ë™ë§Œ ì œí•œë©ë‹ˆë‹¤
    </div>
    
    <button class="btn btn-primary" id="optimizeBtn" onclick="startOptimization()" disabled>
      ğŸ¤– AI ì‹œë³„ ê²½ë¡œ ìµœì í™” ì‹œì‘
    </button>
  </div>

  <!-- Step 4: ìµœì í™” ê²°ê³¼ -->
  <div class="step" id="step4">
    <div class="step-header">
      <span class="step-number">4</span>
      ìµœì í™”ëœ ë°©ë¬¸ ìŠ¤ì¼€ì¤„
    </div>
    <div class="schedule-container" id="scheduleContainer">
      <!-- ìŠ¤ì¼€ì¤„ì´ ì—¬ê¸°ì— ë™ì ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤ -->
    </div>
    <button class="btn btn-success" id="downloadScheduleBtn" onclick="downloadSchedule()" style="display: none;">
      ğŸ“… ìµœì í™”ëœ ìŠ¤ì¼€ì¤„ ë‹¤ìš´ë¡œë“œ
    </button>
  </div>

  <div id="map"></div>

  <footer class="copyright-footer">
    <div class="copyright-container">
      <p>&copy; 2025 ë”°ë¼ì™€. All rights reserved.</p>
      <p>Developed by BTS(Business Trip Secretary)</p>
    </div>
  </footer>
</div>

<script>
let map, markers = [], polylines = [];
let processedData = null;
let optimizedSchedule = null;
let stats = { total: 0, success: 0, fail: 0 };

// Nominatim APIë¥¼ ìœ„í•œ ìš”ì²­ ê°„ê²© ì œì–´ (1ì´ˆë‹¹ 1íšŒ)
let lastRequestTime = 0;
const REQUEST_DELAY = 1100; // 1.1ì´ˆ

// ì§€ì˜¤ì½”ë”© API í˜¸ì¶œ ëŒ€ê¸° í•¨ìˆ˜
async function waitForRateLimit() {
  const now = Date.now();
  const timeSinceLastRequest = now - lastRequestTime;
  if (timeSinceLastRequest < REQUEST_DELAY) {
    await new Promise(resolve => setTimeout(resolve, REQUEST_DELAY - timeSinceLastRequest));
  }
  lastRequestTime = Date.now();
}

// ì§€ë„ ì´ˆê¸°í™”
function initMap() {
  const mapContainer = document.getElementById("map");
  map = L.map('map').setView([37.413479, 127.125512], 13);
  
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: 'Â© OpenStreetMap contributors',
    maxZoom: 19
  }).addTo(map);
  
  console.log('ì§€ë„ ì´ˆê¸°í™” ì™„ë£Œ - íŒêµ ì¤‘ì‹¬ (37.413479, 127.125512)');
}

// Nominatim APIë¥¼ ì‚¬ìš©í•œ ì§€ì˜¤ì½”ë”©
async function geocodeAddress(address) {
  await waitForRateLimit();
  
  try {
    const encodedAddress = encodeURIComponent(address);
    const url = `https://nominatim.openstreetmap.org/search?q=${encodedAddress}&format=json&limit=1&countrycodes=kr`;
    
    const response = await fetch(url, {
      headers: {
        'User-Agent': 'BusinessTripSecretary/1.0'
      }
    });
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    
    if (data && data.length > 0) {
      return {
        lat: parseFloat(data[0].lat),
        lng: parseFloat(data[0].lon),
        display_name: data[0].display_name
      };
    }
    
    return null;
  } catch (error) {
    console.error('ì§€ì˜¤ì½”ë”© ì˜¤ë¥˜:', error);
    return null;
  }
}

// ì£¼ì†Œì—ì„œ ì‹œ(City) ì •ë³´ ì¶”ì¶œ
function extractCityFromAddress(address) {
  if (!address) return 'ê¸°íƒ€';
  
  const cityPatterns = [
    /([ê°€-í£]+ì‹œ)\s/,
    /^([ê°€-í£]+ì‹œ)/,
    /\s([ê°€-í£]+ì‹œ)(?=[êµ¬êµ°])/,
    /([ê°€-í£]+íŠ¹ë³„ì‹œ)/,
    /([ê°€-í£]+ê´‘ì—­ì‹œ)/,
    /([ê°€-í£]+ìì¹˜ì‹œ)/
  ];
  
  for (const pattern of cityPatterns) {
    const match = address.match(pattern);
    if (match) {
      let city = match[1];
      city = city.replace(/(íŠ¹ë³„ì‹œ|ê´‘ì—­ì‹œ|ìì¹˜ì‹œ)$/, 'ì‹œ');
      return city;
    }
  }
  
  if (address.includes('ì„¸ì¢…')) return 'ì„¸ì¢…ì‹œ';
  if (address.includes('ì„œìš¸')) return 'ì„œìš¸ì‹œ';
  if (address.includes('ë¶€ì‚°')) return 'ë¶€ì‚°ì‹œ';
  if (address.includes('ëŒ€êµ¬')) return 'ëŒ€êµ¬ì‹œ';
  if (address.includes('ì¸ì²œ')) return 'ì¸ì²œì‹œ';
  if (address.includes('ê´‘ì£¼')) return 'ê´‘ì£¼ì‹œ';
  if (address.includes('ëŒ€ì „')) return 'ëŒ€ì „ì‹œ';
  if (address.includes('ìš¸ì‚°')) return 'ìš¸ì‚°ì‹œ';
  
  const provincePatterns = [
    /([ê°€-í£]+ë„)\s([ê°€-í£]+êµ°)/,
    /([ê°€-í£]+ë„)\s([ê°€-í£]+ì‹œ)/
  ];
  
  for (const pattern of provincePatterns) {
    const match = address.match(pattern);
    if (match) {
      return match[2];
    }
  }
  
  return 'ê¸°íƒ€';
}

// íŒŒì¼ ì„ íƒ ì´ë²¤íŠ¸
function initFileUpload() {
  const fileInput = document.getElementById("excelFile");
  const uploadBtn = document.getElementById("uploadBtn");
  const convertBtn = document.getElementById("convertBtn");
  
  fileInput.addEventListener('change', function(e) {
    if (e.target.files[0]) {
      const fileName = e.target.files[0].name;
      const fileSize = (e.target.files[0].size / 1024 / 1024).toFixed(1);
      
      uploadBtn.innerHTML = `âœ… ${fileName} (${fileSize}MB)`;
      uploadBtn.classList.add('file-selected');
      convertBtn.disabled = false;
      convertBtn.style.opacity = '1';
      
      uploadBtn.style.transform = 'scale(0.98)';
      setTimeout(() => {
        uploadBtn.style.transform = 'scale(1)';
      }, 150);
    } else {
      uploadBtn.innerHTML = 'ğŸ“Š ì‚¬ì—…ì¥ ì£¼ì†Œ ì—‘ì…€ íŒŒì¼ ì„ íƒí•˜ê¸°';
      uploadBtn.classList.remove('file-selected');
      convertBtn.disabled = true;
      convertBtn.style.opacity = '0.6';
    }
  });
  
  uploadBtn.addEventListener('dragover', function(e) {
    e.preventDefault();
    uploadBtn.style.borderColor = '#61CCE9';
    uploadBtn.style.backgroundColor = 'rgba(97, 204, 233, 0.1)';
  });
  
  uploadBtn.addEventListener('dragleave', function(e) {
    e.preventDefault();
    uploadBtn.style.borderColor = '#a0aec0';
    uploadBtn.style.backgroundColor = '';
  });
  
  uploadBtn.addEventListener('drop', function(e) {
    e.preventDefault();
    uploadBtn.style.borderColor = '#a0aec0';
    uploadBtn.style.backgroundColor = '';
    
    const files = e.dataTransfer.files;
    if (files.length > 0 && (files[0].name.endsWith('.xlsx') || files[0].name.endsWith('.xls'))) {
      fileInput.files = files;
      const event = new Event('change', { bubbles: true });
      fileInput.dispatchEvent(event);
    } else {
      alert('ì—‘ì…€ íŒŒì¼(.xlsx, .xls)ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤.');
    }
  });
  
  uploadBtn.addEventListener('click', function() {
    fileInput.click();
  });
}

// ë‹¨ê³„ í™œì„±í™”
function activateStep(stepNum) {
  document.querySelectorAll('.step').forEach(step => step.classList.remove('active'));
  document.getElementById(`step${stepNum}`).classList.add('active');
}

// í†µê³„ ì—…ë°ì´íŠ¸
function updateStats() {
  document.getElementById('totalCount').textContent = stats.total;
  document.getElementById('successCount').textContent = stats.success;
  document.getElementById('failCount').textContent = stats.fail;
  
  const progressPercent = stats.total > 0 ? ((stats.success + stats.fail) / stats.total) * 100 : 0;
  document.getElementById('progressFill').style.width = progressPercent + '%';
}

// ì£¼ì†Œ ì»¬ëŸ¼ ìë™ ê°ì§€
function detectAddressColumn(data) {
  if (data.length === 0) return null;
  
  const firstRow = data[0];
  const possibleAddressColumns = [
    'ì£¼ì†Œ', 'ì—…ì²´ì£¼ì†Œ', 'ì†Œì¬ì§€', 'ìœ„ì¹˜', 'ì£¼ì†Œì§€', 'ì‚¬ì—…ì¥ì£¼ì†Œ', 
    'address', 'Address', 'ADDRESS', 'ì£¼ì†Œëª…', 'ì§€ë²ˆì£¼ì†Œ', 'ë„ë¡œëª…ì£¼ì†Œ'
  ];
  
  for (const column of possibleAddressColumns) {
    if (firstRow.hasOwnProperty(column)) {
      console.log('ì£¼ì†Œ ì»¬ëŸ¼ ë°œê²¬:', column);
      return column;
    }
  }
  
  const columns = Object.keys(firstRow);
  for (const column of columns) {
    const lowerColumn = column.toLowerCase();
    if (lowerColumn.includes('ì£¼ì†Œ') || lowerColumn.includes('address') || 
        lowerColumn.includes('ì†Œì¬ì§€') || lowerColumn.includes('ìœ„ì¹˜')) {
      console.log('ì£¼ì†Œ ì»¬ëŸ¼ ì¶”ì •:', column);
      return column;
    }
  }
  
  for (const column of columns) {
    const sampleValue = firstRow[column];
    if (typeof sampleValue === 'string' && sampleValue.length > 10) {
      if (sampleValue.includes('ì‹œ') || sampleValue.includes('êµ¬') || 
          sampleValue.includes('ë™') || sampleValue.includes('ë¡œ') ||
          sampleValue.includes('ê¸¸') || sampleValue.includes('ë²ˆì§€')) {
        console.log('ì£¼ì†Œ ì»¬ëŸ¼ ê°’ ê¸°ë°˜ ì¶”ì •:', column);
        return column;
      }
    }
  }
  
  return null;
}

// ì£¼ì†Œ ì „ì²˜ë¦¬
function preprocessAddress(addr) {
  if (!addr) return "";
  
  let cleaned = String(addr).trim();
  
  cleaned = cleaned.replace(/\([^)]*\)/g, "");
  cleaned = cleaned.replace(/\[[^\]]*\]/g, "");
  cleaned = cleaned.replace(/\{[^}]*\}/g, "");
  cleaned = cleaned.replace(/\d{2,4}-\d{3,4}-\d{4}/g, "");
  cleaned = cleaned.replace(/\d{3}-\d{4}-\d{4}/g, "");
  cleaned = cleaned.replace(/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g, "");
  cleaned = cleaned.replace(/(ì£¼ì‹íšŒì‚¬|ìœ í•œíšŒì‚¬|ì£¼ì‹|ìœ í•œ|íšŒì‚¬|\(ì£¼\)|\(ìœ \)|ãˆœ|ãˆ²)/g, "");
  cleaned = cleaned.replace(/\s*(ë¹Œë”©|íƒ€ì›Œ|ì„¼í„°|í”Œë¼ì|ëª°|ë§ˆíŠ¸|ìƒê°€|ì•„íŒŒíŠ¸|ì˜¤í”¼ìŠ¤í…”).*$/i, "");
  cleaned = cleaned.replace(/\s*\d+ì¸µ.*$/g, "");
  cleaned = cleaned.replace(/\s*[BGF]?\d+F.*$/gi, "");
  cleaned = cleaned.replace(/\s*\d+í˜¸.*$/g, "");
  cleaned = cleaned.replace(/\s*\d{5}(\s*-\s*\d{3})?\s*/g, " ");
  cleaned = cleaned.replace(/\s+/g, " ");
  cleaned = cleaned.replace(/íŠ¹ë³„ì‹œ/g, "ì‹œ");
  cleaned = cleaned.replace(/ê´‘ì—­ì‹œ/g, "ì‹œ");
  cleaned = cleaned.replace(/ìì¹˜ì‹œ/g, "ì‹œ");
  cleaned = cleaned.replace(/[,;]/g, " ");
  cleaned = cleaned.replace(/\./g, "");
  cleaned = cleaned.trim();
  
  return cleaned;
}

// ì£¼ì†Œ ë³€í™˜ ì‹¤íŒ¨ ì›ì¸ ë¶„ì„
function analyzeAddressFailure(originalAddr, preprocessedAddr) {
  const issues = [];
  
  if (!originalAddr || originalAddr.trim() === "") {
    issues.push("ë¹ˆ ì£¼ì†Œ");
    return issues;
  }
  
  if (originalAddr.length < 10) {
    issues.push("ì£¼ì†Œê°€ ë„ˆë¬´ ì§§ìŒ");
  }
  
  if (/^\d+$/.test(originalAddr.trim())) {
    issues.push("ìˆ«ìë§Œ í¬í•¨");
  }
  
  if (/^[a-zA-Z\s]+$/.test(originalAddr.trim())) {
    issues.push("ì˜ë¬¸ë§Œ í¬í•¨");
  }
  
  if (!/[ê°€-í£]/.test(originalAddr)) {
    issues.push("í•œê¸€ ì£¼ì†Œ ì •ë³´ ì—†ìŒ");
  }
  
  const hasCity = /[ê°€-í£]+(ì‹œ|ë„)/.test(originalAddr);
  if (!hasCity) {
    issues.push("ì‹œ/ë„ ì •ë³´ ëˆ„ë½");
  }
  
  const hasDistrict = /[ê°€-í£]+(êµ¬|êµ°)/.test(originalAddr);
  if (!hasDistrict) {
    issues.push("êµ¬/êµ° ì •ë³´ ëˆ„ë½");
  }
  
  if (/\d{2,4}-\d{3,4}-\d{4}/.test(originalAddr)) {
    issues.push("ì „í™”ë²ˆí˜¸ í¬í•¨");
  }
  
  if (/(ì£¼ì‹íšŒì‚¬|ìœ í•œíšŒì‚¬|\(ì£¼\)|\(ìœ \)|ãˆœ|ãˆ²)/.test(originalAddr)) {
    issues.push("ìƒí˜¸ëª… í¬í•¨");
  }
  
  if (/(ë¹Œë”©|íƒ€ì›Œ|ì„¼í„°|í”Œë¼ì)/.test(originalAddr) && originalAddr.length > 50) {
    issues.push("ê±´ë¬¼ ìƒì„¸ì •ë³´ ê³¼ë‹¤");
  }
  
  return issues;
}

// ì—‘ì…€ ì²˜ë¦¬
function processExcel() {
  const fileInput = document.getElementById("excelFile");
  if (!fileInput.files[0]) {
    alert("ì—‘ì…€ íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”.");
    return;
  }

  activateStep(2);
  const resultCard = document.getElementById("resultCard");
  const resultDiv = document.getElementById("result");
  const progressContainer = document.getElementById("progressContainer");
  const statsDiv = document.getElementById("stats");
  const convertBtn = document.getElementById("convertBtn");
  
  resultCard.className = "result-card processing";
  progressContainer.style.display = "block";
  statsDiv.style.display = "flex";
  convertBtn.disabled = true;
  convertBtn.innerHTML = '<div class="loading-spinner"></div>ë³€í™˜ ì¤‘...';

  const reader = new FileReader();
  reader.onload = function(e) {
    const data = new Uint8Array(e.target.result);
    const workbook = XLSX.read(data, { type: 'array' });
    const sheetName = workbook.SheetNames[0];
    const worksheet = workbook.Sheets[sheetName];
    const jsonData = XLSX.utils.sheet_to_json(worksheet);

    if (jsonData.length === 0) {
      alert("ì—‘ì…€ì— ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.");
      resetUI();
      return;
    }

    const addressColumn = detectAddressColumn(jsonData);
    if (!addressColumn) {
      alert("ì£¼ì†Œ ì»¬ëŸ¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\nì—‘ì…€ íŒŒì¼ì— ì£¼ì†Œê°€ í¬í•¨ëœ ì»¬ëŸ¼ì´ ìˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.");
      resetUI();
      return;
    }
    
    const normalizedData = jsonData.map(row => {
      const newRow = { ...row };
      newRow['ì£¼ì†Œ'] = row[addressColumn];
      newRow['ì „ì²˜ë¦¬í›„ì£¼ì†Œ'] = '';
      newRow['ìœ„ë„'] = '';
      newRow['ê²½ë„'] = '';
      newRow['ë³€í™˜ì„±ê³µë°©ë²•'] = '';
      newRow['ë³€í™˜ì‹¤íŒ¨ì›ì¸'] = [];
      return newRow;
    });

    console.log(`ê°ì§€ëœ ì£¼ì†Œ ì»¬ëŸ¼: "${addressColumn}", ì´ ${normalizedData.length}ê°œ ë°ì´í„°`);

    window.conversionData = normalizedData;
    stats = { total: normalizedData.length, success: 0, fail: 0, originalData: normalizedData };
    updateStats();
    convertAddresses(normalizedData);
  };
  reader.readAsArrayBuffer(fileInput.files[0]);
}

// ì£¼ì†Œ ë³€í™˜
async function convertAddresses(data) {
  const resultDiv = document.getElementById("result");
  let completed = 0;

  for (let index = 0; index < data.length; index++) {
    const row = data[index];
    const originalAddr = row['ì£¼ì†Œ'];
    
    if (!originalAddr) {
      row['ì „ì²˜ë¦¬í›„ì£¼ì†Œ'] = '';
      row['ìœ„ë„'] = '';
      row['ê²½ë„'] = '';
      row['ë³€í™˜ì‹¤íŒ¨ì›ì¸'] = ['ë¹ˆ ì£¼ì†Œ'];
      stats.fail++;
      completed++;
      updateStats();
      continue;
    }

    resultDiv.innerHTML = `
      <div class="loading-spinner"></div>
      ë³€í™˜ ì¤‘... <strong>${originalAddr}</strong><br>
      <small>${completed + 1} / ${data.length}</small>
    `;

    const preprocessedAddr = preprocessAddress(originalAddr);
    row['ì „ì²˜ë¦¬í›„ì£¼ì†Œ'] = preprocessedAddr;
    
    const issues = analyzeAddressFailure(originalAddr, preprocessedAddr);
    
    // 1ì°¨ ì‹œë„: ì›ë˜ ì£¼ì†Œ
    let result = await geocodeAddress(originalAddr);
    
    if (result) {
      row['ìœ„ë„'] = result.lat;
      row['ê²½ë„'] = result.lng;
      row['ë³€í™˜ì„±ê³µë°©ë²•'] = 'ì›ë³¸ì£¼ì†Œ';
      row['ë³€í™˜ì‹¤íŒ¨ì›ì¸'] = [];
      stats.success++;
      console.log(`ë³€í™˜ ì„±ê³µ (ì›ë³¸ì£¼ì†Œ): ${originalAddr}`);
    } else if (preprocessedAddr && preprocessedAddr !== originalAddr) {
      // 2ì°¨ ì‹œë„: ì „ì²˜ë¦¬ëœ ì£¼ì†Œ
      result = await geocodeAddress(preprocessedAddr);
      
      if (result) {
        row['ìœ„ë„'] = result.lat;
        row['ê²½ë„'] = result.lng;
        row['ë³€í™˜ì„±ê³µë°©ë²•'] = 'ì „ì²˜ë¦¬í›„';
        row['ë³€í™˜ì‹¤íŒ¨ì›ì¸'] = [];
        stats.success++;
        console.log(`ë³€í™˜ ì„±ê³µ (ì „ì²˜ë¦¬í›„): ${originalAddr}`);
      } else {
        row['ìœ„ë„'] = '';
        row['ê²½ë„'] = '';
        row['ë³€í™˜ì„±ê³µë°©ë²•'] = '';
        row['ë³€í™˜ì‹¤íŒ¨ì›ì¸'] = issues.length > 0 ? issues : ['ëª¨ë“  ë³€í™˜ ë°©ë²• ì‹¤íŒ¨'];
        stats.fail++;
        console.log(`ë³€í™˜ ì‹¤íŒ¨: ${originalAddr} - ì‚¬ìœ : ${row['ë³€í™˜ì‹¤íŒ¨ì›ì¸'].join(', ')}`);
      }
    } else {
      row['ìœ„ë„'] = '';
      row['ê²½ë„'] = '';
      row['ë³€í™˜ì„±ê³µë°©ë²•'] = '';
      row['ë³€í™˜ì‹¤íŒ¨ì›ì¸'] = issues.length > 0 ? issues : ['ëª¨ë“  ë³€í™˜ ë°©ë²• ì‹¤íŒ¨'];
      stats.fail++;
      console.log(`ë³€í™˜ ì‹¤íŒ¨: ${originalAddr} - ì‚¬ìœ : ${row['ë³€í™˜ì‹¤íŒ¨ì›ì¸'].join(', ')}`);
    }
    
    completed++;
    updateStats();
  }

  // ë³€í™˜ ì™„ë£Œ
  const resultCard = document.getElementById("resultCard");
  const optimizeBtn = document.getElementById("optimizeBtn");
  
  resultCard.className = "result-card success";
  resultDiv.innerHTML = `
    ğŸ‰ ëª¨ë“  ì£¼ì†Œ ë³€í™˜ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!<br>
    <small>ì„±ê³µ: ${stats.success}ê°œ | ì‹¤íŒ¨: ${stats.fail}ê°œ</small><br>
    <button class="btn btn-success" onclick="downloadConversionResults()" style="margin-top: 1rem;">
      ğŸ“Š ë³€í™˜ ê²°ê³¼ ë‹¤ìš´ë¡œë“œ (ì „ì²˜ë¦¬ í¬í•¨)
    </button>
  `;
  
  processedData = data.filter(row => row['ìœ„ë„'] && row['ê²½ë„']);
  
  processedData.forEach(row => {
    row['ì‹œ'] = extractCityFromAddress(row['ì£¼ì†Œ']);
  });
  
  const cityStats = {};
  processedData.forEach(row => {
    const city = row['ì‹œ'];
    cityStats[city] = (cityStats[city] || 0) + 1;
  });
  
  console.log('ì‹œë³„ ë¶„í¬:', cityStats);
  
  if (processedData.length > 0) {
    activateStep(3);
    optimizeBtn.disabled = false;
    showMapWithMarkers(processedData);
  } else {
    alert("ë³€í™˜ëœ ì£¼ì†Œê°€ ì—†ìŠµë‹ˆë‹¤. ì£¼ì†Œ í˜•ì‹ì„ í™•ì¸í•´ì£¼ì„¸ìš”.");
  }
  
  resetUI();
}

// ë³€í™˜ ê²°ê³¼ ë‹¤ìš´ë¡œë“œ
function downloadConversionResults() {
  if (!window.conversionData || window.conversionData.length === 0) {
    alert('ë³€í™˜ëœ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
    return;
  }

  const enhancedData = window.conversionData.map(row => {
    const newRow = { ...row };
    
    if (Array.isArray(newRow['ë³€í™˜ì‹¤íŒ¨ì›ì¸'])) {
      newRow['ë³€í™˜ì‹¤íŒ¨ì›ì¸'] = newRow['ë³€í™˜ì‹¤íŒ¨ì›ì¸'].join(', ');
    }
    
    newRow['ë³€í™˜ê²°ê³¼'] = (newRow['ìœ„ë„'] && newRow['ê²½ë„']) ? 'ì„±ê³µ' : 'ì‹¤íŒ¨';
    
    if (newRow['ë³€í™˜ì„±ê³µë°©ë²•']) {
      if (newRow['ë³€í™˜ì„±ê³µë°©ë²•'] === 'ì›ë³¸ì£¼ì†Œ') {
        newRow['ì „ì²˜ë¦¬íš¨ê³¼'] = 'ë¶ˆí•„ìš”';
      } else if (newRow['ë³€í™˜ì„±ê³µë°©ë²•'] === 'ì „ì²˜ë¦¬í›„') {
        newRow['ì „ì²˜ë¦¬íš¨ê³¼'] = 'ìœ íš¨';
      }
    } else {
      newRow['ì „ì²˜ë¦¬íš¨ê³¼'] = 'íš¨ê³¼ì—†ìŒ';
    }
    
    return newRow;
  });

  const workbook = XLSX.utils.book_new();
  const mainSheet = XLSX.utils.json_to_sheet(enhancedData);
  XLSX.utils.book_append_sheet(workbook, mainSheet, "ë³€í™˜ê²°ê³¼_ì „ì²´");
  
  const successData = enhancedData.filter(row => row['ë³€í™˜ê²°ê³¼'] === 'ì„±ê³µ');
  if (successData.length > 0) {
    const successSheet = XLSX.utils.json_to_sheet(successData);
    XLSX.utils.book_append_sheet(workbook, successSheet, "ë³€í™˜ì„±ê³µ_ë°ì´í„°");
  }
  
  const failData = enhancedData.filter(row => row['ë³€í™˜ê²°ê³¼'] === 'ì‹¤íŒ¨');
  if (failData.length > 0) {
    const failSheet = XLSX.utils.json_to_sheet(failData);
    XLSX.utils.book_append_sheet(workbook, failSheet, "ë³€í™˜ì‹¤íŒ¨_ë°ì´í„°");
  }
  
  const now = new Date();
  const timestamp = now.toISOString().slice(0, 16).replace('T', '_').replace(/:/g, '');
  XLSX.writeFile(workbook, `ì£¼ì†Œë³€í™˜ê²°ê³¼_${timestamp}.xlsx`);
  
  alert(`ë³€í™˜ ê²°ê³¼ ë‹¤ìš´ë¡œë“œ ì™„ë£Œ!\n\n` +
        `ğŸ“Š ì „ì²´: ${enhancedData.length}ê°œ\n` +
        `âœ… ì„±ê³µ: ${successData.length}ê°œ (${Math.round(successData.length/enhancedData.length*100)}%)\n` +
        `âŒ ì‹¤íŒ¨: ${failData.length}ê°œ`);
}

// ì§€ë„ì— ëª¨ë“  ë§ˆì»¤ í‘œì‹œ
function showMapWithMarkers(data) {
  const mapDiv = document.getElementById("map");
  mapDiv.style.display = "block";
  
  // ê¸°ì¡´ ë§ˆì»¤ ì œê±°
  markers.forEach(marker => map.removeLayer(marker));
  markers = [];
  
  const bounds = [];
  
  data.forEach((row, index) => {
    if (row['ìœ„ë„'] && row['ê²½ë„']) {
      const lat = parseFloat(row['ìœ„ë„']);
      const lng = parseFloat(row['ê²½ë„']);
      
      const marker = L.marker([lat, lng]).addTo(map);
      marker.bindPopup(`
        <div style="min-width: 200px;">
          <strong>${row['ì£¼ì†Œ']}</strong><br>
          <small>ğŸ™ï¸ ${row['ì‹œ']}</small>
        </div>
      `);
      
      markers.push(marker);
      bounds.push([lat, lng]);
    }
  });
  
  if (bounds.length > 0) {
    map.fitBounds(bounds);
  }
}

// ê±°ë¦¬ ê³„ì‚° (í•˜ë²„ì‚¬ì¸ ê³µì‹)
function calculateDistance(lat1, lng1, lat2, lng2) {
  const R = 6371;
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLng = (lng2 - lng1) * Math.PI / 180;
  const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
    Math.sin(dLng/2) * Math.sin(dLng/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

// ê·¼ë¬´ì¼ ê³„ì‚°
function getWorkingDay(dayOffset) {
  const today = new Date();
  let workingDays = 0;
  let currentDate = new Date(today);

  while (workingDays <= dayOffset) {
    if (currentDate.getDay() !== 0 && currentDate.getDay() !== 6) {
      if (workingDays === dayOffset) {
        return currentDate.toLocaleDateString('ko-KR', {
          month: 'long',
          day: 'numeric',
          weekday: 'short'
        });
      }
      workingDays++;
    }
    currentDate.setDate(currentDate.getDate() + 1);
  }
}

// ì‹œë³„ í´ëŸ¬ìŠ¤í„°ë§ (ì´ì „ê³¼ ë™ì¼)
function cityBasedClustering(data, maxVisitsPerDay) {
  console.log('ê±°ë¦¬ ì œì•½ ê²½ë¡œ ìµœì í™” ì‹œì‘:', data.length, 'ê°œ ë°ì´í„°');
  
  const minVisitsPerDay = Math.max(2, maxVisitsPerDay - 1);
  const maxDailyDistance = 80;
  console.log('ì œì•½ ì¡°ê±´:', minVisitsPerDay, '~', maxVisitsPerDay, 'ê°œì†Œ,', maxDailyDistance, 'km ì´í•˜');
  
  const cityGroups = {};
  data.forEach(item => {
    const city = item['ì‹œ'] || 'ê¸°íƒ€';
    if (!cityGroups[city]) {
      cityGroups[city] = [];
    }
    cityGroups[city].push(item);
  });
  
  const sortedCities = Object.keys(cityGroups).sort((a, b) => cityGroups[b].length - cityGroups[a].length);
  console.log('ì‹œë³„ ë¶„í¬:', sortedCities.map(city => `${city}: ${cityGroups[city].length}ê°œ`));
  
  const mainClusters = [];
  const remainingData = [];
  
  sortedCities.forEach(city => {
    const cityData = [...cityGroups[city]];
    
    while (cityData.length >= minVisitsPerDay) {
      const optimalSubset = selectDistanceConstrainedSubset(cityData, maxVisitsPerDay, maxDailyDistance);
      
      if (optimalSubset.length >= minVisitsPerDay) {
        mainClusters.push({
          locations: optimalSubset,
          cities: [city],
          centroid: calculateCentroid(optimalSubset),
          totalDistance: calculateClusterTotalDistance(optimalSubset),
          hasCapacity: optimalSubset.length < maxVisitsPerDay
        });
        
        optimalSubset.forEach(selected => {
          const index = cityData.findIndex(item => item === selected);
          if (index >= 0) cityData.splice(index, 1);
        });
      } else {
        remainingData.push(...cityData.splice(0));
      }
    }
    
    if (cityData.length > 0) {
      remainingData.push(...cityData);
    }
  });
  
  console.log(`ë©”ì¸ í´ëŸ¬ìŠ¤í„° ${mainClusters.length}ê°œ ìƒì„±, ë‚¨ì€ ë°ì´í„° ${remainingData.length}ê°œ`);
  
  distributeRemainingDataWithDistanceConstraint(mainClusters, remainingData, maxVisitsPerDay, minVisitsPerDay, maxDailyDistance);
  
  const finalClusters = mainClusters.filter(cluster => cluster.locations.length > 0);
  
  console.log(`ìµœì¢… ê²°ê³¼: ${finalClusters.length}ê°œ í´ëŸ¬ìŠ¤í„°`);
  
  return finalClusters.map(cluster => cluster.locations);
}

// ë‚˜ë¨¸ì§€ í´ëŸ¬ìŠ¤í„°ë§ ê´€ë ¨ í•¨ìˆ˜ë“¤ (ì´ì „ê³¼ ë™ì¼)
function selectDistanceConstrainedSubset(data, maxCount, maxDistance) {
  if (data.length <= 1) return [...data];
  
  let bestSubset = [];
  let bestScore = -Infinity;
  
  const trySeeds = Math.min(5, data.length);
  
  for (let seedTry = 0; seedTry < trySeeds; seedTry++) {
    const subset = [];
    const available = [...data];
    
    let seedIndex;
    if (seedTry === 0) {
      const centroid = calculateCentroid(data);
      seedIndex = 0;
      let minDist = Infinity;
      data.forEach((point, idx) => {
        const dist = calculateDistance(
          parseFloat(point['ìœ„ë„']), parseFloat(point['ê²½ë„']),
          centroid.lat, centroid.lng
        );
        if (dist < minDist) {
          minDist = dist;
          seedIndex = idx;
        }
      });
    } else {
      seedIndex = Math.floor(Math.random() * available.length);
    }
    
    subset.push(available[seedIndex]);
    available.splice(seedIndex, 1);
    
    while (subset.length < maxCount && available.length > 0) {
      let bestCandidate = null;
      let bestCandidateIndex = -1;
      let bestDistance = Infinity;
      
      available.forEach((candidate, idx) => {
        const testSubset = [...subset, candidate];
        const totalDistance = calculateClusterTotalDistance(testSubset);
        
        if (totalDistance <= maxDistance) {
          const avgDistanceIncrease = totalDistance - calculateClusterTotalDistance(subset);
          
          if (avgDistanceIncrease < bestDistance) {
            bestDistance = avgDistanceIncrease;
            bestCandidate = candidate;
            bestCandidateIndex = idx;
          }
        }
      });
      
      if (bestCandidate) {
        subset.push(bestCandidate);
        available.splice(bestCandidateIndex, 1);
      } else {
        break;
      }
    }
    
    const distance = calculateClusterTotalDistance(subset);
    const score = subset.length * 100 - distance;
    
    if (score > bestScore && distance <= maxDistance) {
      bestScore = score;
      bestSubset = [...subset];
    }
  }
  
  return bestSubset;
}

function calculateClusterTotalDistance(locations) {
  if (locations.length <= 1) return 0;
  if (locations.length === 2) {
    return calculateDistance(
      parseFloat(locations[0]['ìœ„ë„']), parseFloat(locations[0]['ê²½ë„']),
      parseFloat(locations[1]['ìœ„ë„']), parseFloat(locations[1]['ê²½ë„'])
    );
  }
  
  const visited = new Array(locations.length).fill(false);
  let totalDistance = 0;
  let currentIndex = 0;
  visited[currentIndex] = true;
  
  for (let step = 1; step < locations.length; step++) {
    let nearestIndex = -1;
    let nearestDistance = Infinity;
    
    for (let i = 0; i < locations.length; i++) {
      if (!visited[i]) {
        const distance = calculateDistance(
          parseFloat(locations[currentIndex]['ìœ„ë„']), parseFloat(locations[currentIndex]['ê²½ë„']),
          parseFloat(locations[i]['ìœ„ë„']), parseFloat(locations[i]['ê²½ë„'])
        );
        
        if (distance < nearestDistance) {
          nearestDistance = distance;
          nearestIndex = i;
        }
      }
    }
    
    if (nearestIndex >= 0) {
      totalDistance += nearestDistance;
      currentIndex = nearestIndex;
      visited[currentIndex] = true;
    }
  }
  
  return totalDistance;
}

function distributeRemainingDataWithDistanceConstraint(clusters, remainingData, maxVisitsPerDay, minVisitsPerDay, maxDistance) {
  remainingData.forEach(point => {
    let bestCluster = null;
    let bestScore = Infinity;
    
    const availableClusters = clusters.filter(cluster => cluster.locations.length < maxVisitsPerDay);
    
    availableClusters.forEach(cluster => {
      const testLocations = [...cluster.locations, point];
      const newTotalDistance = calculateClusterTotalDistance(testLocations);
      
      if (newTotalDistance <= maxDistance) {
        const insertionScore = calculateInsertionScore(point, cluster);
        const cityMatch = cluster.cities.includes(point['ì‹œ'] || 'ê¸°íƒ€');
        const newCityCount = new Set([...cluster.cities, point['ì‹œ'] || 'ê¸°íƒ€']).size;
        
        let adjustedScore = insertionScore;
        if (cityMatch) adjustedScore *= 0.3;
        if (newCityCount > 3) adjustedScore *= 3.0;
        
        const distanceEfficiency = 1.0 - (newTotalDistance / maxDistance);
        adjustedScore *= (1.0 + distanceEfficiency);
        
        if (adjustedScore < bestScore) {
          bestScore = adjustedScore;
          bestCluster = cluster;
        }
      }
    });
    
    if (bestCluster) {
      bestCluster.locations.push(point);
      const newCity = point['ì‹œ'] || 'ê¸°íƒ€';
      if (!bestCluster.cities.includes(newCity)) {
        bestCluster.cities.push(newCity);
      }
      bestCluster.centroid = calculateCentroid(bestCluster.locations);
      bestCluster.totalDistance = calculateClusterTotalDistance(bestCluster.locations);
    } else {
      clusters.push({
        locations: [point],
        cities: [point['ì‹œ'] || 'ê¸°íƒ€'],
        centroid: {
          lat: parseFloat(point['ìœ„ë„']),
          lng: parseFloat(point['ê²½ë„'])
        },
        totalDistance: 0,
        hasCapacity: true
      });
    }
  });
  
  mergeSmallClustersWithDistance(clusters, minVisitsPerDay, maxVisitsPerDay, maxDistance);
}

function mergeSmallClustersWithDistance(clusters, minVisitsPerDay, maxVisitsPerDay, maxDistance) {
  let attempts = 0;
  const maxAttempts = 10;
  
  while (attempts < maxAttempts) {
    attempts++;
    
    const smallClusters = clusters.filter(c => c.locations.length < minVisitsPerDay && c.locations.length > 0);
    
    if (smallClusters.length === 0) break;
    
    let merged = false;
    
    for (let i = 0; i < smallClusters.length - 1; i++) {
      const cluster1 = smallClusters[i];
      
      for (let j = i + 1; j < smallClusters.length; j++) {
        const cluster2 = smallClusters[j];
        
        const combinedLocations = [...cluster1.locations, ...cluster2.locations];
        const totalSize = combinedLocations.length;
        const combinedCities = new Set([...cluster1.cities, ...cluster2.cities]);
        const combinedDistance = calculateClusterTotalDistance(combinedLocations);
        
        if (totalSize <= maxVisitsPerDay && combinedCities.size <= 3 && combinedDistance <= maxDistance) {
          cluster1.locations = combinedLocations;
          cluster1.cities = Array.from(combinedCities);
          cluster1.centroid = calculateCentroid(cluster1.locations);
          cluster1.totalDistance = combinedDistance;
          
          cluster2.locations = [];
          cluster2.cities = [];
          
          merged = true;
          break;
        }
      }
      
      if (merged) break;
    }
    
    if (!merged) break;
  }
}

function calculateInsertionScore(point, cluster) {
  const pointLat = parseFloat(point['ìœ„ë„']);
  const pointLng = parseFloat(point['ê²½ë„']);
  
  if (cluster.locations.length === 0) {
    return 0;
  }
  
  let totalDistance = 0;
  cluster.locations.forEach(existing => {
    totalDistance += calculateDistance(
      pointLat, pointLng,
      parseFloat(existing['ìœ„ë„']), parseFloat(existing['ê²½ë„'])
    );
  });
  
  const avgDistance = totalDistance / cluster.locations.length;
  
  const distToCentroid = calculateDistance(
    pointLat, pointLng,
    cluster.centroid.lat, cluster.centroid.lng
  );
  
  return 0.7 * avgDistance + 0.3 * distToCentroid;
}

function calculateCentroid(cluster) {
  if (cluster.length === 0) return { lat: 0, lng: 0 };
  
  const sumLat = cluster.reduce((sum, point) => sum + parseFloat(point['ìœ„ë„']), 0);
  const sumLng = cluster.reduce((sum, point) => sum + parseFloat(point['ê²½ë„']), 0);
  
  return {
    lat: sumLat / cluster.length,
    lng: sumLng / cluster.length
  };
}

// ìµœì í™” ì‹œì‘
function startOptimization() {
  const maxWorkHours = document.getElementById('maxWorkHours').value;
  const maxVisitsPerDay = document.getElementById('maxVisitsPerDay').value;
  const avgStayTime = document.getElementById('avgStayTime').value;
  const startLocation = document.getElementById('startLocation').value;
  
  if (!processedData || processedData.length === 0) {
    alert("ë¨¼ì € ì£¼ì†Œ ë³€í™˜ì„ ì™„ë£Œí•´ì£¼ì„¸ìš”.");
    return;
  }
  
  if (!maxWorkHours || !maxVisitsPerDay || !avgStayTime) {
    alert("ëª¨ë“  ì„¤ì •ê°’ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.");
    return;
  }
  
  if (!startLocation.trim()) {
    alert("ì¶œë°œì§€ ì£¼ì†Œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.");
    document.getElementById('startLocation').focus();
    return;
  }
  
  optimizeSchedule();
}

// ìŠ¤ì¼€ì¤„ ìµœì í™”
async function optimizeSchedule() {
  const maxWorkHours = parseInt(document.getElementById('maxWorkHours').value);
  const maxVisitsPerDay = parseInt(document.getElementById('maxVisitsPerDay').value);
  const avgStayTime = parseInt(document.getElementById('avgStayTime').value);
  const startLocation = document.getElementById('startLocation').value.trim();

  const optimizeBtn = document.getElementById('optimizeBtn');
  optimizeBtn.disabled = true;
  optimizeBtn.innerHTML = '<div class="loading-spinner"></div> AI ì‹œë³„ ê²½ë¡œ ìµœì í™” ì¤‘...';

  try {
    activateStep(4);
    const scheduleContainer = document.getElementById('scheduleContainer');
    scheduleContainer.innerHTML = '<div class="result-card processing"><div class="loading-spinner"></div> AIê°€ ì‹œë³„ ìµœì  ê²½ë¡œë¥¼ ê³„ì‚°í•˜ê³  ìˆìŠµë‹ˆë‹¤...</div>';
    scheduleContainer.style.display = 'block';

    // ì¶œë°œì§€ ì¢Œí‘œ ë³€í™˜
    const startResult = await geocodeAddress(startLocation);
    
    if (!startResult) {
      alert('ì¶œë°œì§€ ì£¼ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ' + startLocation);
      resetOptimizeButton();
      return;
    }

    const startCoords = {
      ìœ„ë„: startResult.lat,
      ê²½ë„: startResult.lng,
      ì£¼ì†Œ: startLocation
    };

    const validData = processedData.filter(item => {
      const lat = parseFloat(item['ìœ„ë„']);
      const lng = parseFloat(item['ê²½ë„']);
      return !isNaN(lat) && !isNaN(lng) && lat !== 0 && lng !== 0;
    });

    if (validData.length === 0) {
      alert('ìœ íš¨í•œ ìœ„ì¹˜ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
      resetOptimizeButton();
      return;
    }

    const clusters = cityBasedClustering(validData, maxVisitsPerDay);
    
    optimizedSchedule = [];
    let totalDistance = 0;

    for (let i = 0; i < clusters.length; i++) {
      if (clusters[i].length === 0) continue;
      
      const dayRoute = optimizedTSP(clusters[i], startCoords);
      const visitedCities = [...new Set(dayRoute.map(location => location['ì‹œ']))];
      const dayDistance = calculateRouteDistance(dayRoute, startCoords);
      const dayTime = Math.round(dayDistance * 2) + (dayRoute.length * avgStayTime);
      
      optimizedSchedule.push({
        day: i + 1,
        date: getWorkingDay(i),
        locations: dayRoute,
        cities: visitedCities,
        distance: Math.round(dayDistance * 10) / 10,
        estimatedTime: Math.round(dayTime),
        startLocation: startCoords
      });
      
      totalDistance += dayDistance;
    }

    displaySchedule();

  } catch (error) {
    console.error('ìµœì í™” ì¤‘ ì˜¤ë¥˜:', error);
    alert('ìµœì í™” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
  } finally {
    resetOptimizeButton();
  }
}

function resetOptimizeButton() {
  const optimizeBtn = document.getElementById('optimizeBtn');
  optimizeBtn.disabled = false;
  optimizeBtn.innerHTML = 'ğŸ¤– AI ì‹œë³„ ê²½ë¡œ ìµœì í™” ì‹œì‘';
}

function nearestNeighborTSP(locations, startIndex = 0) {
  const n = locations.length;
  if (n <= 1) return locations;
  
  const visited = new Array(n).fill(false);
  const route = [];
  let current = startIndex;
  
  route.push(locations[current]);
  visited[current] = true;
  
  for (let i = 1; i < n; i++) {
    let nearest = -1;
    let minDistance = Infinity;
    
    for (let j = 0; j < n; j++) {
      if (!visited[j]) {
        const distance = calculateDistance(
          parseFloat(locations[current]['ìœ„ë„']), parseFloat(locations[current]['ê²½ë„']),
          parseFloat(locations[j]['ìœ„ë„']), parseFloat(locations[j]['ê²½ë„'])
        );
        if (distance < minDistance) {
          minDistance = distance;
          nearest = j;
        }
      }
    }
    
    if (nearest !== -1) {
      route.push(locations[nearest]);
      visited[nearest] = true;
      current = nearest;
    }
  }
  
  return route;
}

function optimizedTSP(locations, startCoords) {
  const n = locations.length;
  if (n <= 1) return locations;
  
  let bestStartIndex = 0;
  let bestTotalDistance = Infinity;
  
  for (let startIndex = 0; startIndex < Math.min(n, 3); startIndex++) {
    const route = nearestNeighborTSP(locations, startIndex);
    const totalDistance = calculateRouteDistance(route, startCoords);
    
    if (totalDistance < bestTotalDistance) {
      bestTotalDistance = totalDistance;
      bestStartIndex = startIndex;
    }
  }
  
  let initialRoute = nearestNeighborTSP(locations, bestStartIndex);
  let improvedRoute = twoOptImprovement(initialRoute);
  
  return improvedRoute;
}

function calculateRouteDistance(route, startCoords) {
  if (route.length === 0) return 0;
  
  let totalDistance = 0;
  
  totalDistance += calculateDistance(
    startCoords.ìœ„ë„, startCoords.ê²½ë„,
    parseFloat(route[0]['ìœ„ë„']), parseFloat(route[0]['ê²½ë„'])
  );
  
  for (let i = 1; i < route.length; i++) {
    totalDistance += calculateDistance(
      parseFloat(route[i-1]['ìœ„ë„']), parseFloat(route[i-1]['ê²½ë„']),
      parseFloat(route[i]['ìœ„ë„']), parseFloat(route[i]['ê²½ë„'])
    );
  }
  
  totalDistance += calculateDistance(
    parseFloat(route[route.length-1]['ìœ„ë„']), parseFloat(route[route.length-1]['ê²½ë„']),
    startCoords.ìœ„ë„, startCoords.ê²½ë„
  );
  
  return totalDistance;
}

function twoOptImprovement(route) {
  if (route.length <= 3) return route;
  
  let improved = true;
  let bestRoute = [...route];
  let maxIterations = 50;
  let iteration = 0;
  
  while (improved && iteration < maxIterations) {
    improved = false;
    iteration++;
    
    for (let i = 1; i < bestRoute.length - 2; i++) {
      for (let j = i + 1; j < bestRoute.length; j++) {
        if (j - i === 1) continue;
        
        const currentDistance = 
          calculateDistance(
            parseFloat(bestRoute[i-1]['ìœ„ë„']), parseFloat(bestRoute[i-1]['ê²½ë„']),
            parseFloat(bestRoute[i]['ìœ„ë„']), parseFloat(bestRoute[i]['ê²½ë„'])
          ) +
          calculateDistance(
            parseFloat(bestRoute[j]['ìœ„ë„']), parseFloat(bestRoute[j]['ê²½ë„']),
            parseFloat(bestRoute[j === bestRoute.length - 1 ? 0 : j + 1]['ìœ„ë„']), 
            parseFloat(bestRoute[j === bestRoute.length - 1 ? 0 : j + 1]['ê²½ë„'])
          );
        
        const newDistance = 
          calculateDistance(
            parseFloat(bestRoute[i-1]['ìœ„ë„']), parseFloat(bestRoute[i-1]['ê²½ë„']),
            parseFloat(bestRoute[j]['ìœ„ë„']), parseFloat(bestRoute[j]['ê²½ë„'])
          ) +
          calculateDistance(
            parseFloat(bestRoute[i]['ìœ„ë„']), parseFloat(bestRoute[i]['ê²½ë„']),
            parseFloat(bestRoute[j === bestRoute.length - 1 ? 0 : j + 1]['ìœ„ë„']), 
            parseFloat(bestRoute[j === bestRoute.length - 1 ? 0 : j + 1]['ê²½ë„'])
          );
        
        if (newDistance < currentDistance) {
          const newRoute = [...bestRoute];
          for (let k = 0; k < Math.ceil((j - i + 1) / 2); k++) {
            const temp = newRoute[i + k];
            newRoute[i + k] = newRoute[j - k];
            newRoute[j - k] = temp;
          }
          
          bestRoute = newRoute;
          improved = true;
        }
      }
    }
  }
  
  return bestRoute;
}

// ìŠ¤ì¼€ì¤„ í‘œì‹œ
function displaySchedule() {
  if (!optimizedSchedule || optimizedSchedule.length === 0) {
    alert('ìŠ¤ì¼€ì¤„ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
    return;
  }

  const scheduleContainer = document.getElementById('scheduleContainer');
  const downloadBtn = document.getElementById('downloadScheduleBtn');
  
  let html = '';
  let totalDistance = 0;
  let totalEstimatedTime = 0;
  let totalLocations = 0;

  optimizedSchedule.forEach((day, dayIndex) => {
    totalDistance += day.distance || 0;
    totalEstimatedTime += day.estimatedTime || 0;
    totalLocations += day.locations ? day.locations.length : 0;
    
    html += `
      <div class="day-card">
        <div class="day-header">
          <div>
            <div class="day-title">ğŸ“… Day ${day.day} - ${day.date || 'ë‚ ì§œ ë¯¸ì„¤ì •'}</div>
            <div class="day-cities">ğŸ™ï¸ ë°©ë¬¸ ì§€ì—­: ${day.cities && day.cities.length > 0 ? day.cities.join(', ') : 'ë¯¸ì„¤ì •'}</div>
          </div>
          <div class="day-summary">${day.locations ? day.locations.length : 0}ê³³ ë°©ë¬¸ | ${day.distance || 0}km | ${Math.floor((day.estimatedTime || 0)/60)}ì‹œê°„ ${(day.estimatedTime || 0)%60}ë¶„</div>
        </div>
        <div class="day-content">
    `;
    
    html += `
      <div class="visit-item">
        <div class="visit-number">ğŸ </div>
        <div class="visit-details">
          <div class="visit-address">ğŸ“ ì¶œë°œì§€: ${day.startLocation ? day.startLocation.ì£¼ì†Œ : 'ì¶œë°œì§€ ë¯¸ì„¤ì •'}</div>
          <div class="visit-time">09:00 ì¶œë°œ</div>
        </div>
      </div>
    `;
    
    if (day.locations && day.locations.length > 0) {
      let currentTime = 9 * 60;
      const avgStayTime = parseInt(document.getElementById('avgStayTime').value) || 60;
      
      if (day.startLocation && day.locations[0]) {
        const travelTime = calculateDistance(
          day.startLocation.ìœ„ë„, day.startLocation.ê²½ë„,
          parseFloat(day.locations[0]['ìœ„ë„']), parseFloat(day.locations[0]['ê²½ë„'])
        ) * 2;
        currentTime += travelTime;
      }
      
      day.locations.forEach((location, index) => {
        const arrivalHour = Math.floor(currentTime / 60);
        const arrivalMin = Math.round(currentTime % 60);
        const departureTime = currentTime + avgStayTime;
        const departureHour = Math.floor(departureTime / 60);
        const departureMinute = Math.round(departureTime % 60);
        
        html += `
          <div class="visit-item">
            <div class="visit-number">${index + 1}</div>
            <div class="visit-details">
              <div class="visit-address">${location['ì£¼ì†Œ'] || 'ì£¼ì†Œ ë¯¸ì„¤ì •'}</div>
              <div class="visit-city">${location['ì‹œ'] || 'ì‹œ ë¯¸ì„¤ì •'}</div>
              <div class="visit-time">
                ${String(arrivalHour).padStart(2, '0')}:${String(arrivalMin).padStart(2, '0')} ë„ì°© â†’ 
                ${String(departureHour).padStart(2, '0')}:${String(departureMinute).padStart(2, '0')} ì¶œë°œ
              </div>
            </div>
          </div>
        `;
        
        if (index < day.locations.length - 1) {
          const lat1 = parseFloat(location['ìœ„ë„']);
          const lng1 = parseFloat(location['ê²½ë„']);
          const lat2 = parseFloat(day.locations[index + 1]['ìœ„ë„']);
          const lng2 = parseFloat(day.locations[index + 1]['ê²½ë„']);
          const travelTime = calculateDistance(lat1, lng1, lat2, lng2) * 2;
          currentTime = departureTime + travelTime;
        }
      });
    }
    
    html += `
        </div>
      </div>
    `;
  });

  const avgDailyTime = optimizedSchedule.length > 0 ? Math.round(totalEstimatedTime / 60 / optimizedSchedule.length) : 0;
  const totalCitiesVisited = [...new Set(optimizedSchedule.flatMap(day => day.cities))].length;
  
  html += `
    <div class="total-summary">
      <h3>ğŸ“Š ì „ì²´ ì¼ì • ìš”ì•½</h3>
      <div class="summary-grid">
        <div class="summary-item">
          <div class="summary-value">${optimizedSchedule.length}</div>
          <div class="summary-label">ì´ ê·¼ë¬´ì¼</div>
        </div>
        <div class="summary-item">
          <div class="summary-value">${totalLocations}</div>
          <div class="summary-label">ì´ ë°©ë¬¸ì§€</div>
        </div>
        <div class="summary-item">
          <div class="summary-value">${totalCitiesVisited}</div>
          <div class="summary-label">ë°©ë¬¸ ì‹œ ìˆ˜</div>
        </div>
        <div class="summary-item">
          <div class="summary-value">${Math.round(totalDistance * 10) / 10}km</div>
          <div class="summary-label">ì´ ì´ë™ê±°ë¦¬</div>
        </div>
        <div class="summary-item">
          <div class="summary-value">${avgDailyTime}ì‹œê°„</div>
          <div class="summary-label">ì¼í‰ê·  ì—…ë¬´ì‹œê°„</div>
        </div>
      </div>
    </div>
  `;

  scheduleContainer.innerHTML = html;
  downloadBtn.style.display = 'block';
  
  displayScheduleOnMap();
}

// ìŠ¤ì¼€ì¤„ì„ ì§€ë„ì— í‘œì‹œ
function displayScheduleOnMap() {
  const mapDiv = document.getElementById("map");
  mapDiv.style.display = "block";
  
  // ê¸°ì¡´ ë§ˆì»¤ì™€ ê²½ë¡œì„  ì œê±°
  markers.forEach(marker => map.removeLayer(marker));
  polylines.forEach(polyline => map.removeLayer(polyline));
  markers = [];
  polylines = [];
  
  const bounds = [];
  const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8'];
  
  optimizedSchedule.forEach((day, dayIndex) => {
    const color = colors[dayIndex % colors.length];
    
    // ì¶œë°œì§€ ë§ˆì»¤
    const startIcon = L.divIcon({
      className: 'custom-div-icon',
      html: `<div style="background-color: #2E8B57; color: white; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 16px; border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);">ğŸ </div>`,
      iconSize: [30, 30],
      iconAnchor: [15, 15]
    });
    
    const startMarker = L.marker([day.startLocation.ìœ„ë„, day.startLocation.ê²½ë„], { icon: startIcon }).addTo(map);
    startMarker.bindPopup(`<strong>ì¶œë°œì§€</strong><br>${day.startLocation.ì£¼ì†Œ}`);
    markers.push(startMarker);
    bounds.push([day.startLocation.ìœ„ë„, day.startLocation.ê²½ë„]);
    
    // ë°©ë¬¸ì§€ ë§ˆì»¤ë“¤
    day.locations.forEach((location, index) => {
      const markerIcon = L.divIcon({
        className: 'custom-div-icon',
        html: `<div style="background-color: ${color}; color: white; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 12px; border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);">${index + 1}</div>`,
        iconSize: [28, 28],
        iconAnchor: [14, 14]
      });
      
      const marker = L.marker([parseFloat(location['ìœ„ë„']), parseFloat(location['ê²½ë„'])], { icon: markerIcon }).addTo(map);
      
      marker.bindPopup(`
        <div style="min-width: 200px;">
          <strong>Day ${day.day} - ${index + 1}ë²ˆì§¸</strong><br>
          ${location['ì£¼ì†Œ']}<br>
          <small>ğŸ™ï¸ ${location['ì‹œ']}</small>
        </div>
      `);
      
      markers.push(marker);
      bounds.push([parseFloat(location['ìœ„ë„']), parseFloat(location['ê²½ë„'])]);
    });

    // ë°©ë¬¸ì§€ ê°„ ê²½ë¡œì„  ê·¸ë¦¬ê¸°
    if (day.locations.length > 1) {
      const path = day.locations.map(loc => [parseFloat(loc['ìœ„ë„']), parseFloat(loc['ê²½ë„'])]);
      
      const polyline = L.polyline(path, {
        color: color,
        weight: 3,
        opacity: 0.8
      }).addTo(map);
      
      polylines.push(polyline);
    }
  });
  
  if (bounds.length > 0) {
    map.fitBounds(bounds);
  }
}

// ìŠ¤ì¼€ì¤„ ë‹¤ìš´ë¡œë“œ
function downloadSchedule() {
  if (!optimizedSchedule || !processedData) return;

  const enhancedData = processedData.map(originalRow => {
    const newRow = { ...originalRow };
    
    let scheduleInfo = null;
    let dayInfo = null;
    let visitOrder = null;
    
    for (let dayIndex = 0; dayIndex < optimizedSchedule.length; dayIndex++) {
      const day = optimizedSchedule[dayIndex];
      const locationIndex = day.locations.findIndex(loc => 
        loc['ì£¼ì†Œ'] === originalRow['ì£¼ì†Œ'] || 
        (loc['ìœ„ë„'] === originalRow['ìœ„ë„'] && loc['ê²½ë„'] === originalRow['ê²½ë„'])
      );
      
      if (locationIndex !== -1) {
        scheduleInfo = day;
        dayInfo = dayIndex + 1;
        visitOrder = locationIndex + 1;
        break;
      }
    }
    
    if (scheduleInfo) {
      newRow['ë°©ë¬¸_ì¼ì°¨'] = `Day ${dayInfo}`;
      newRow['ë°©ë¬¸_ë‚ ì§œ'] = scheduleInfo.date || '';
      newRow['ë°©ë¬¸_ìˆœì„œ'] = visitOrder;
      newRow['ë°©ë¬¸_ë„ì‹œëª©ë¡'] = scheduleInfo.cities ? scheduleInfo.cities.join(', ') : '';
      newRow['ì˜ˆìƒ_ì²´ë¥˜ì‹œê°„(ë¶„)'] = document.getElementById('avgStayTime').value;
      newRow['ì¼ì¼_ì´ê±°ë¦¬(km)'] = visitOrder === 1 ? scheduleInfo.distance : '';
      newRow['ì¼ì¼_ì´ì‹œê°„(ë¶„)'] = visitOrder === 1 ? scheduleInfo.estimatedTime : '';
      newRow['ë°©ë¬¸_ì˜ˆì •ì‹œê°„'] = calculateVisitTime(scheduleInfo, visitOrder - 1);
    } else {
      newRow['ë°©ë¬¸_ì¼ì°¨'] = '';
      newRow['ë°©ë¬¸_ë‚ ì§œ'] = '';
      newRow['ë°©ë¬¸_ìˆœì„œ'] = '';
      newRow['ë°©ë¬¸_ë„ì‹œëª©ë¡'] = '';
      newRow['ì˜ˆìƒ_ì²´ë¥˜ì‹œê°„(ë¶„)'] = '';
      newRow['ì¼ì¼_ì´ê±°ë¦¬(km)'] = '';
      newRow['ì¼ì¼_ì´ì‹œê°„(ë¶„)'] = '';
      newRow['ë°©ë¬¸_ì˜ˆì •ì‹œê°„'] = '';
    }
    
    return newRow;
  });

  const worksheet = XLSX.utils.json_to_sheet(enhancedData);
  const workbook = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(workbook, worksheet, "ì›ë³¸ë°ì´í„°_with_ìŠ¤ì¼€ì¤„");
  
  const now = new Date();
  const timestamp = now.toISOString().slice(0, 10);
  XLSX.writeFile(workbook, `ì‚¬ì—…ì¥_ë°©ë¬¸ìŠ¤ì¼€ì¤„_${timestamp}.xlsx`);
}

function calculateVisitTime(daySchedule, locationIndex) {
  if (!daySchedule.locations || locationIndex < 0 || locationIndex >= daySchedule.locations.length) {
    return '';
  }
  
  const avgStayTime = parseInt(document.getElementById('avgStayTime').value) || 60;
  let currentTime = 9 * 60;
  
  if (daySchedule.startLocation && daySchedule.locations[0]) {
    const travelTime = calculateDistance(
      daySchedule.startLocation.ìœ„ë„, daySchedule.startLocation.ê²½ë„,
      parseFloat(daySchedule.locations[0]['ìœ„ë„']), parseFloat(daySchedule.locations[0]['ê²½ë„'])
    ) * 2;
    currentTime += travelTime;
  }
  
  for (let i = 0; i < locationIndex; i++) {
    currentTime += avgStayTime;
    
    if (i < daySchedule.locations.length - 1) {
      const lat1 = parseFloat(daySchedule.locations[i]['ìœ„ë„']);
      const lng1 = parseFloat(daySchedule.locations[i]['ê²½ë„']);
      const lat2 = parseFloat(daySchedule.locations[i + 1]['ìœ„ë„']);
      const lng2 = parseFloat(daySchedule.locations[i + 1]['ê²½ë„']);
      const travelTime = calculateDistance(lat1, lng1, lat2, lng2) * 2;
      currentTime += travelTime;
    }
  }
  
  const arrivalHour = Math.floor(currentTime / 60);
  const arrivalMin = Math.round(currentTime % 60);
  const departureTime = currentTime + avgStayTime;
  const departureHour = Math.floor(departureTime / 60);
  const departureMinute = Math.round(departureTime % 60);
  
  return `${String(arrivalHour).padStart(2, '0')}:${String(arrivalMin).padStart(2, '0')} ë„ì°© â†’ ${String(departureHour).padStart(2, '0')}:${String(departureMinute).padStart(2, '0')} ì¶œë°œ`;
}

function resetUI() {
  const convertBtn = document.getElementById("convertBtn");
  convertBtn.disabled = false;
  convertBtn.innerHTML = 'ì£¼ì†Œ â†’ ìœ„ê²½ë„ ë³€í™˜ ì‹œì‘';
}

window.onload = function() {
  console.log('í˜ì´ì§€ ë¡œë“œ ì™„ë£Œ');
  initMap();
  initFileUpload();
};
</script>
</body>
</html>
