<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>BTS ë”°ë¼ì™€</title>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #61CCE9 0%, #A2E559 100%);
    min-height: 100vh;
    padding: 1rem;
  }

  .container {
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    border-radius: 20px;
    padding: 2rem;
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
    width: 100%;
    max-width: 1200px;
    margin: 0 auto;
    animation: fadeInUp 0.6s ease-out;
  }

  @keyframes fadeInUp {
    from { opacity: 0; transform: translateY(30px); }
    to { opacity: 1; transform: translateY(0); }
  }

  .header {
    text-align: center;
    margin-bottom: 2rem;
  }

  .header h1 {
    color: #2d3748;
    font-size: 2.5rem;
    font-weight: 700;
    margin-bottom: 0.5rem;
    background: linear-gradient(135deg, #61CCE9, #A2E559);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .header p {
    color: #718096;
    font-size: 1.2rem;
  }

  .step {
    margin-bottom: 2rem;
    opacity: 0.6;
    transition: all 0.3s ease;
  }

  .step.active {
    opacity: 1;
  }

  .step-header {
    display: flex;
    align-items: center;
    margin-bottom: 1rem;
    font-size: 1.3rem;
    font-weight: 600;
    color: #2d3748;
  }

  .step-number {
    background: linear-gradient(135deg, #61CCE9, #A2E559);
    color: white;
    width: 32px;
    height: 32px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 1rem;
    font-size: 1rem;
  }

  .file-upload {
    position: relative;
    display: inline-block;
    width: 100%;
  }

  .file-upload input[type="file"] {
    position: absolute;
    opacity: 0;
    width: 100%;
    height: 100%;
    cursor: pointer;
  }

  .file-upload-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
    padding: 1.5rem;
    background: linear-gradient(135deg, #e2e8f0, #cbd5e0);
    border: 2px dashed #a0aec0;
    border-radius: 12px;
    color: #4a5568;
    font-size: 1.1rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .file-upload-btn:hover {
    background: linear-gradient(135deg, #cbd5e0, #a0aec0);
    border-color: #61CCE9;
    transform: translateY(-2px);
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
  }

  .file-upload-btn::before {
    content: 'ğŸ“Š';
    font-size: 1.5rem;
    margin-right: 0.5rem;
  }

  .file-selected {
    background: linear-gradient(135deg, #61CCE9, #A2E559) !important;
    color: white !important;
    border-color: #61CCE9 !important;
  }

  .file-selected::before {
    content: 'âœ…';
  }

  .settings-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 1.5rem;
    margin-bottom: 2rem;
  }

  .setting-card {
    background: linear-gradient(135deg, #f8fafc, #e2e8f0);
    border-radius: 12px;
    padding: 1.5rem;
    border-left: 4px solid #61CCE9;
  }

  .setting-label {
    display: block;
    color: #2d3748;
    font-weight: 600;
    margin-bottom: 0.5rem;
  }

  .setting-input {
    width: 100%;
    padding: 0.8rem;
    border: 2px solid #e2e8f0;
    border-radius: 8px;
    font-size: 1rem;
    transition: all 0.3s ease;
  }

  .setting-input:focus {
    outline: none;
    border-color: #61CCE9;
    box-shadow: 0 0 0 3px rgba(97, 204, 233, 0.1);
  }

  .btn {
    padding: 1rem 2rem;
    border: none;
    border-radius: 12px;
    font-size: 1.1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s ease;
    width: 100%;
    margin-top: 1rem;
  }

  .btn-primary {
    background: linear-gradient(135deg, #61CCE9, #A2E559);
    color: white;
  }

  .btn-success {
    background: linear-gradient(135deg, #48bb78, #38a169);
    color: white;
  }

  .btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 15px 30px rgba(97, 204, 233, 0.4);
  }

  .btn:disabled {
    background: #a0aec0 !important;
    cursor: not-allowed !important;
    transform: none !important;
    box-shadow: none !important;
    opacity: 0.6;
  }

  .result-card {
    background: linear-gradient(135deg, #f7fafc, #edf2f7);
    border-radius: 12px;
    padding: 1.5rem;
    border-left: 4px solid #61CCE9;
    transition: all 0.3s ease;
    margin-top: 1rem;
  }

  .result-card.processing {
    background: linear-gradient(135deg, #fff5f5, #fed7d7);
    border-left-color: #fc8181;
    animation: pulse 2s infinite;
  }

  .result-card.success {
    background: linear-gradient(135deg, #f0fff4, #c6f6d5);
    border-left-color: #48bb78;
  }

  .progress-bar {
    width: 100%;
    height: 8px;
    background: #e2e8f0;
    border-radius: 4px;
    overflow: hidden;
    margin: 1rem 0;
  }

  .progress-fill {
    height: 100%;
    background: linear-gradient(90deg, #61CCE9, #A2E559);
    width: 0%;
    transition: width 0.3s ease;
    position: relative;
  }

  .progress-fill::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
    animation: shimmer 2s infinite;
  }

  @keyframes shimmer {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
  }

  .stats {
    display: flex;
    justify-content: space-around;
    margin: 1rem 0;
    flex-wrap: wrap;
    gap: 1rem;
  }

  .stat-item {
    text-align: center;
    flex: 1;
    min-width: 120px;
  }

  .stat-number {
    font-size: 1.8rem;
    font-weight: 700;
    color: #61CCE9;
    display: block;
  }

  .stat-label {
    color: #718096;
    font-size: 0.9rem;
    margin-top: 0.2rem;
  }

  .loading-spinner {
    display: inline-block;
    width: 20px;
    height: 20px;
    border: 2px solid #f3f3f3;
    border-top: 2px solid #61CCE9;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-right: 0.5rem;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
  }

  #map {
    width: 100%;
    height: 500px;
    margin-top: 1.5rem;
    border-radius: 12px;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
    display: none;
  }

  .schedule-container {
    display: none;
    margin-top: 2rem;
  }

  .day-card {
    background: white;
    border-radius: 12px;
    margin-bottom: 1rem;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    overflow: hidden;
    transition: all 0.3s ease;
  }

  .day-card:hover {
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    transform: translateY(-2px);
  }

  .day-header {
    background: linear-gradient(135deg, #61CCE9, #A2E559);
    color: white;
    padding: 1rem 1.5rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .day-title {
    font-size: 1.3rem;
    font-weight: 600;
  }

  .day-summary {
    font-size: 0.9rem;
    opacity: 0.9;
  }

  .day-cities {
    font-size: 0.85rem;
    opacity: 0.8;
    margin-top: 0.2rem;
  }

  .day-content {
    padding: 1.5rem;
  }

  .visit-item {
    display: flex;
    align-items: center;
    padding: 1rem;
    margin-bottom: 0.5rem;
    background: #f8fafc;
    border-radius: 8px;
    border-left: 4px solid #61CCE9;
  }

  .visit-number {
    background: #61CCE9;
    color: white;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.8rem;
    font-weight: 600;
    margin-right: 1rem;
    flex-shrink: 0;
  }

  .visit-details {
    flex: 1;
  }

  .visit-address {
    font-weight: 600;
    color: #2d3748;
    margin-bottom: 0.2rem;
  }

  .visit-time {
    color: #718096;
    font-size: 0.9rem;
  }

  .visit-city {
    color: #61CCE9;
    font-size: 0.8rem;
    font-weight: 500;
  }

  .total-summary {
    background: linear-gradient(135deg, #f0fff4, #c6f6d5);
    border-radius: 12px;
    padding: 1.5rem;
    margin-top: 2rem;
    border-left: 4px solid #48bb78;
  }

  .summary-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
    margin-top: 1rem;
  }

  .summary-item {
    text-align: center;
  }

  .summary-value {
    font-size: 1.5rem;
    font-weight: 700;
    color: #61CCE9;
  }

  .summary-label {
    color: #2d3748;
    font-size: 0.9rem;
    margin-top: 0.2rem;
  }

  .city-constraint-info {
    background: linear-gradient(135deg, #e6fffa, #b2f5ea);
    border: 1px solid #38b2ac;
    border-radius: 8px;
    padding: 1rem;
    margin-top: 1rem;
    font-size: 0.9rem;
    color: #2c7a7b;
  }

  .city-constraint-info strong {
    color: #234e52;
  }

  @media (max-width: 768px) {
    .container { padding: 1rem; }
    .header h1 { font-size: 2rem; }
    .settings-grid { grid-template-columns: 1fr; }
    .day-header { flex-direction: column; gap: 0.5rem; }
  }
</style>

<script type="text/javascript" src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=0c62e9a12c740ee7f1620f92ec4659bf&libraries=services"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
</head>
<body>
<div class="container">
  <div class="header">
    <h1>ğŸš— BTS(Business Trip Secretary) ë”°ë¼ì™€</h1>
    <p>ì¶œì¥ ê³„íš ìˆ˜ë¦½ ì—…ë¬´ ìë™í™” í”„ë¡¬í”„íŠ¸</p>
  </div>

  <!-- Step 1: íŒŒì¼ ì—…ë¡œë“œ -->
  <div class="step active" id="step1">
    <div class="step-header">
      <span class="step-number">1</span>
      ì—‘ì…€ íŒŒì¼ ì—…ë¡œë“œ
    </div>
    <div class="file-upload">
      <input type="file" id="excelFile" accept=".xlsx, .xls">
      <div class="file-upload-btn" id="uploadBtn">
        ì‚¬ì—…ì¥ ì£¼ì†Œ ì—‘ì…€ íŒŒì¼ ì„ íƒí•˜ê¸°
      </div>
    </div>
    <button class="btn btn-primary" id="convertBtn" onclick="processExcel()" disabled>
      ì£¼ì†Œ â†’ ìœ„ê²½ë„ ë³€í™˜ ì‹œì‘
    </button>
  </div>

  <!-- Step 2: ë³€í™˜ ê²°ê³¼ -->
  <div class="step" id="step2">
    <div class="step-header">
      <span class="step-number">2</span>
      ì£¼ì†Œ ë³€í™˜ ê²°ê³¼
    </div>
    <div class="result-card" id="resultCard">
      <div id="result">ğŸ“‹ ì—‘ì…€ íŒŒì¼ì„ ì—…ë¡œë“œí•˜ê³  ë³€í™˜ì„ ì‹œì‘í•´ì£¼ì„¸ìš”</div>
      <div class="progress-bar" id="progressContainer" style="display: none;">
        <div class="progress-fill" id="progressFill"></div>
      </div>
      <div class="stats" id="stats" style="display: none;">
        <div class="stat-item">
          <span class="stat-number" id="totalCount">0</span>
          <span class="stat-label">ì „ì²´ ì£¼ì†Œ</span>
        </div>
        <div class="stat-item">
          <span class="stat-number" id="successCount">0</span>
          <span class="stat-label">ë³€í™˜ ì„±ê³µ</span>
        </div>
        <div class="stat-item">
          <span class="stat-number" id="failCount">0</span>
          <span class="stat-label">ë³€í™˜ ì‹¤íŒ¨</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Step 3: ìŠ¤ì¼€ì¤„ ì„¤ì • -->
  <div class="step" id="step3">
    <div class="step-header">
      <span class="step-number">3</span>
      ë°©ë¬¸ ì¼ì • ì„¤ì •
    </div>
    <div class="settings-grid">
      <div class="setting-card">
        <label class="setting-label">â° ì¼ì¼ ìµœëŒ€ ì—…ë¬´ì‹œê°„ (ì‹œê°„)</label>
        <input type="number" class="setting-input" id="maxWorkHours" value="8" min="1" max="12">
      </div>
      <div class="setting-card">
        <label class="setting-label">ğŸ“ ì¼ì¼ ë°©ë¬¸ì—…ì²´ìˆ˜</label>
        <input type="number" class="setting-input" id="maxVisitsPerDay" value="4" min="2" max="20">
        <small style="color: #718096; font-size: 0.8rem; margin-top: 0.3rem; display: block;">
          ì„¤ì •ê°’-1 ~ ì„¤ì •ê°’ ë²”ìœ„ë¡œ ì¡°ì •ë©ë‹ˆë‹¤ (ì˜ˆ: 4 ì„¤ì •ì‹œ 3~4ê°œì†Œ)
        </small>
      </div>
      <div class="setting-card">
        <label class="setting-label">ğŸ• í‰ê·  ì²´ë¥˜ì‹œê°„ (ë¶„)</label>
        <input type="number" class="setting-input" id="avgStayTime" value="60" min="15" max="480">
      </div>
      <div class="setting-card">
        <label class="setting-label">ğŸ  ì¶œë°œì§€ ì£¼ì†Œ</label>
        <input type="text" class="setting-input" id="startLocation" placeholder="ì˜ˆ: ì„œìš¸ì‹œ ê°•ë‚¨êµ¬ í…Œí—¤ë€ë¡œ 123">
      </div>
    </div>
    
    <div class="city-constraint-info">
      <strong>ğŸ™ï¸ ìµœì í™” ì œì•½ ì¡°ê±´</strong><br>
      â€¢ ê°™ì€ ì‹œ(å¸‚) ë‚´ì˜ ì—…ì²´ë“¤ì„ ìš°ì„ ì ìœ¼ë¡œ ë¬¶ì–´ì„œ ë°©ë¬¸í•©ë‹ˆë‹¤<br>
      â€¢ í•˜ë£¨ì— ìµœëŒ€ 3ê°œ ì‹œê¹Œì§€ë§Œ ë°©ë¬¸í•˜ì—¬ ì§€ì—­ ì§‘ì¤‘ë„ë¥¼ ë†’ì…ë‹ˆë‹¤<br>
      â€¢ <strong>ë°©ë¬¸ì§€ ê°„ í•˜ë£¨ ì´ ì´ë™ê±°ë¦¬ 80km ì´ë‚´ë¡œ ì œí•œí•©ë‹ˆë‹¤</strong><br>
      â€¢ ì¶œë°œì§€ ì™•ë³µ ê±°ë¦¬ëŠ” ë³„ë„ì´ë©°, ìˆœìˆ˜ ì—…ì²´ ê°„ ì´ë™ë§Œ ì œí•œë©ë‹ˆë‹¤
    </div>
    
    <button class="btn btn-primary" id="optimizeBtn" onclick="startOptimization()" disabled>
      ğŸ¤– AI ì‹œë³„ ê²½ë¡œ ìµœì í™” ì‹œì‘
    </button>
  </div>

  <!-- Step 4: ìµœì í™” ê²°ê³¼ -->
  <div class="step" id="step4">
    <div class="step-header">
      <span class="step-number">4</span>
      ìµœì í™”ëœ ë°©ë¬¸ ìŠ¤ì¼€ì¤„
    </div>
    <div class="schedule-container" id="scheduleContainer">
      <!-- ìŠ¤ì¼€ì¤„ì´ ì—¬ê¸°ì— ë™ì ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤ -->
    </div>
    <button class="btn btn-success" id="downloadScheduleBtn" onclick="downloadSchedule()" style="display: none;">
      ğŸ“… ìµœì í™”ëœ ìŠ¤ì¼€ì¤„ ë‹¤ìš´ë¡œë“œ
    </button>
  </div>

  <div id="map"></div>
</div>

<script>
let map, marker, geocoder;
let processedData = null;
let optimizedSchedule = null;
let stats = { total: 0, success: 0, fail: 0 };

// ì§€ë„ ì´ˆê¸°í™”
function initMap() {
  const mapContainer = document.getElementById("map");
  map = new kakao.maps.Map(mapContainer, {
    center: new kakao.maps.LatLng(37.413479, 127.125512), // íŒêµ ì¢Œí‘œ
    level: 4
  });
  geocoder = new kakao.maps.services.Geocoder();
  console.log('ì§€ë„ ì´ˆê¸°í™” ì™„ë£Œ - íŒêµ ì¤‘ì‹¬ (37.413479, 127.125512)');
}

// ì£¼ì†Œì—ì„œ ì‹œ(City) ì •ë³´ ì¶”ì¶œ
function extractCityFromAddress(address) {
  if (!address) return 'ê¸°íƒ€';
  
  // ì‹œ íŒ¨í„´ ë§¤ì¹­ (í•œêµ­ ì£¼ì†Œ í˜•ì‹)
  const cityPatterns = [
    /([ê°€-í£]+ì‹œ)\s/,           // "ì„œìš¸ì‹œ ", "ë¶€ì‚°ì‹œ " ë“±
    /^([ê°€-í£]+ì‹œ)/,            // ì£¼ì†Œ ì‹œì‘ì´ "ì‹œ"ë¡œ ëë‚˜ëŠ” ê²½ìš°
    /\s([ê°€-í£]+ì‹œ)(?=[êµ¬êµ°])/,  // " ì‹œ" ë’¤ì— êµ¬/êµ°ì´ ì˜¤ëŠ” ê²½ìš°
    /([ê°€-í£]+íŠ¹ë³„ì‹œ)/,          // "ì„œìš¸íŠ¹ë³„ì‹œ"
    /([ê°€-í£]+ê´‘ì—­ì‹œ)/,          // "ë¶€ì‚°ê´‘ì—­ì‹œ" ë“±
    /([ê°€-í£]+ìì¹˜ì‹œ)/           // "ì„¸ì¢…ìì¹˜ì‹œ"
  ];
  
  for (const pattern of cityPatterns) {
    const match = address.match(pattern);
    if (match) {
      let city = match[1];
      // "íŠ¹ë³„ì‹œ", "ê´‘ì—­ì‹œ" ë“±ì˜ ì ‘ë¯¸ì‚¬ ì œê±°
      city = city.replace(/(íŠ¹ë³„ì‹œ|ê´‘ì—­ì‹œ|ìì¹˜ì‹œ)$/, 'ì‹œ');
      return city;
    }
  }
  
  // íŠ¹ë³„í•œ ê²½ìš°ë“¤ ì²˜ë¦¬
  if (address.includes('ì„¸ì¢…')) return 'ì„¸ì¢…ì‹œ';
  if (address.includes('ì„œìš¸')) return 'ì„œìš¸ì‹œ';
  if (address.includes('ë¶€ì‚°')) return 'ë¶€ì‚°ì‹œ';
  if (address.includes('ëŒ€êµ¬')) return 'ëŒ€êµ¬ì‹œ';
  if (address.includes('ì¸ì²œ')) return 'ì¸ì²œì‹œ';
  if (address.includes('ê´‘ì£¼')) return 'ê´‘ì£¼ì‹œ';
  if (address.includes('ëŒ€ì „')) return 'ëŒ€ì „ì‹œ';
  if (address.includes('ìš¸ì‚°')) return 'ìš¸ì‚°ì‹œ';
  
  // ë„ ë‹¨ìœ„ ì§€ì—­ (ì‹œê°€ ì—†ëŠ” ê²½ìš°)
  const provincePatterns = [
    /([ê°€-í£]+ë„)\s([ê°€-í£]+êµ°)/,  // "ê²½ê¸°ë„ ì–‘í‰êµ°" ë“±
    /([ê°€-í£]+ë„)\s([ê°€-í£]+ì‹œ)/   // "ê²½ê¸°ë„ ì„±ë‚¨ì‹œ" ë“±
  ];
  
  for (const pattern of provincePatterns) {
    const match = address.match(pattern);
    if (match) {
      return match[2]; // ì‹œ/êµ° ì´ë¦„ ë°˜í™˜
    }
  }
  
  return 'ê¸°íƒ€';
}

// íŒŒì¼ ì„ íƒ ì´ë²¤íŠ¸
function initFileUpload() {
  const fileInput = document.getElementById("excelFile");
  const uploadBtn = document.getElementById("uploadBtn");
  const convertBtn = document.getElementById("convertBtn");
  
  // íŒŒì¼ ì…ë ¥ ì´ë²¤íŠ¸
  fileInput.addEventListener('change', function(e) {
    console.log('íŒŒì¼ ì„ íƒë¨:', e.target.files[0]); // ë””ë²„ê·¸ìš©
    
    if (e.target.files[0]) {
      const fileName = e.target.files[0].name;
      const fileSize = (e.target.files[0].size / 1024 / 1024).toFixed(1); // MB
      
      uploadBtn.innerHTML = `âœ… ${fileName} (${fileSize}MB)`;
      uploadBtn.classList.add('file-selected');
      convertBtn.disabled = false;
      convertBtn.style.opacity = '1';
      
      // ì•½ê°„ì˜ ì• ë‹ˆë©”ì´ì…˜ íš¨ê³¼
      uploadBtn.style.transform = 'scale(0.98)';
      setTimeout(() => {
        uploadBtn.style.transform = 'scale(1)';
      }, 150);
      
      console.log('íŒŒì¼ ì„ íƒ ì™„ë£Œ, ë³€í™˜ ë²„íŠ¼ í™œì„±í™”ë¨'); // ë””ë²„ê·¸ìš©
    } else {
      uploadBtn.innerHTML = 'ğŸ“Š ì‚¬ì—…ì¥ ì£¼ì†Œ ì—‘ì…€ íŒŒì¼ ì„ íƒí•˜ê¸°';
      uploadBtn.classList.remove('file-selected');
      convertBtn.disabled = true;
      convertBtn.style.opacity = '0.6';
    }
  });
  
  // ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì´ë²¤íŠ¸
  uploadBtn.addEventListener('dragover', function(e) {
    e.preventDefault();
    uploadBtn.style.borderColor = '#61CCE9';
    uploadBtn.style.backgroundColor = 'rgba(97, 204, 233, 0.1)';
  });
  
  uploadBtn.addEventListener('dragleave', function(e) {
    e.preventDefault();
    uploadBtn.style.borderColor = '#a0aec0';
    uploadBtn.style.backgroundColor = '';
  });
  
  uploadBtn.addEventListener('drop', function(e) {
    e.preventDefault();
    uploadBtn.style.borderColor = '#a0aec0';
    uploadBtn.style.backgroundColor = '';
    
    const files = e.dataTransfer.files;
    if (files.length > 0 && (files[0].name.endsWith('.xlsx') || files[0].name.endsWith('.xls'))) {
      fileInput.files = files;
      // change ì´ë²¤íŠ¸ ìˆ˜ë™ íŠ¸ë¦¬ê±°
      const event = new Event('change', { bubbles: true });
      fileInput.dispatchEvent(event);
    } else {
      alert('ì—‘ì…€ íŒŒì¼(.xlsx, .xls)ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤.');
    }
  });
  
  // ë²„íŠ¼ í´ë¦­ ì‹œ íŒŒì¼ ì„ íƒì°½ ì—´ê¸°
  uploadBtn.addEventListener('click', function() {
    fileInput.click();
  });
}

// ë‹¨ê³„ í™œì„±í™”
function activateStep(stepNum) {
  document.querySelectorAll('.step').forEach(step => step.classList.remove('active'));
  document.getElementById(`step${stepNum}`).classList.add('active');
}

// í†µê³„ ì—…ë°ì´íŠ¸
function updateStats() {
  document.getElementById('totalCount').textContent = stats.total;
  document.getElementById('successCount').textContent = stats.success;
  document.getElementById('failCount').textContent = stats.fail;
  
  const progressPercent = stats.total > 0 ? ((stats.success + stats.fail) / stats.total) * 100 : 0;
  document.getElementById('progressFill').style.width = progressPercent + '%';
}

// ì£¼ì†Œ ì»¬ëŸ¼ ìë™ ê°ì§€ í•¨ìˆ˜
function detectAddressColumn(data) {
  if (data.length === 0) return null;
  
  const firstRow = data[0];
  const possibleAddressColumns = [
    'ì£¼ì†Œ', 'ì—…ì²´ì£¼ì†Œ', 'ì†Œì¬ì§€', 'ìœ„ì¹˜', 'ì£¼ì†Œì§€', 'ì‚¬ì—…ì¥ì£¼ì†Œ', 
    'address', 'Address', 'ADDRESS', 'ì£¼ì†Œëª…', 'ì§€ë²ˆì£¼ì†Œ', 'ë„ë¡œëª…ì£¼ì†Œ'
  ];
  
  // ì •í™•í•œ ë§¤ì¹­ ìš°ì„ 
  for (const column of possibleAddressColumns) {
    if (firstRow.hasOwnProperty(column)) {
      console.log('ì£¼ì†Œ ì»¬ëŸ¼ ë°œê²¬:', column);
      return column;
    }
  }
  
  // ë¶€ë¶„ ë§¤ì¹­ (ì»¬ëŸ¼ëª…ì— í‚¤ì›Œë“œê°€ í¬í•¨ëœ ê²½ìš°)
  const columns = Object.keys(firstRow);
  for (const column of columns) {
    const lowerColumn = column.toLowerCase();
    if (lowerColumn.includes('ì£¼ì†Œ') || lowerColumn.includes('address') || 
        lowerColumn.includes('ì†Œì¬ì§€') || lowerColumn.includes('ìœ„ì¹˜')) {
      console.log('ì£¼ì†Œ ì»¬ëŸ¼ ì¶”ì •:', column);
      return column;
    }
  }
  
  // ê°’ ê¸°ë°˜ ì¶”ì • (ì£¼ì†Œì²˜ëŸ¼ ë³´ì´ëŠ” ë°ì´í„°ê°€ ìˆëŠ” ì»¬ëŸ¼)
  for (const column of columns) {
    const sampleValue = firstRow[column];
    if (typeof sampleValue === 'string' && sampleValue.length > 10) {
      // í•œêµ­ ì£¼ì†Œ íŒ¨í„´ ì²´í¬
      if (sampleValue.includes('ì‹œ') || sampleValue.includes('êµ¬') || 
          sampleValue.includes('ë™') || sampleValue.includes('ë¡œ') ||
          sampleValue.includes('ê¸¸') || sampleValue.includes('ë²ˆì§€')) {
        console.log('ì£¼ì†Œ ì»¬ëŸ¼ ê°’ ê¸°ë°˜ ì¶”ì •:', column);
        return column;
      }
    }
  }
  
  return null;
}

// ì—‘ì…€ ì²˜ë¦¬
function processExcel() {
  const fileInput = document.getElementById("excelFile");
  if (!fileInput.files[0]) {
    alert("ì—‘ì…€ íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”.");
    return;
  }

  activateStep(2);
  const resultCard = document.getElementById("resultCard");
  const resultDiv = document.getElementById("result");
  const progressContainer = document.getElementById("progressContainer");
  const statsDiv = document.getElementById("stats");
  const convertBtn = document.getElementById("convertBtn");
  
  resultCard.className = "result-card processing";
  progressContainer.style.display = "block";
  statsDiv.style.display = "flex";
  convertBtn.disabled = true;
  convertBtn.innerHTML = '<div class="loading-spinner"></div>ë³€í™˜ ì¤‘...';

  const reader = new FileReader();
  reader.onload = function(e) {
    const data = new Uint8Array(e.target.result);
    const workbook = XLSX.read(data, { type: 'array' });
    const sheetName = workbook.SheetNames[0];
    const worksheet = workbook.Sheets[sheetName];
    const jsonData = XLSX.utils.sheet_to_json(worksheet);

    if (jsonData.length === 0) {
      alert("ì—‘ì…€ì— ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.");
      resetUI();
      return;
    }

    // ì£¼ì†Œ ì»¬ëŸ¼ ìë™ ê°ì§€
    const addressColumn = detectAddressColumn(jsonData);
    if (!addressColumn) {
      alert("ì£¼ì†Œ ì»¬ëŸ¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\nì—‘ì…€ íŒŒì¼ì— ì£¼ì†Œê°€ í¬í•¨ëœ ì»¬ëŸ¼ì´ ìˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.\nê°€ëŠ¥í•œ ì»¬ëŸ¼ëª…: ì£¼ì†Œ, ì—…ì²´ì£¼ì†Œ, ì†Œì¬ì§€, ìœ„ì¹˜ ë“±");
      resetUI();
      return;
    }
    
    // ì£¼ì†Œ ì»¬ëŸ¼ëª…ì„ 'ì£¼ì†Œ'ë¡œ í†µì¼ (ê¸°ì¡´ ì½”ë“œ í˜¸í™˜ì„±)
    const normalizedData = jsonData.map(row => {
      const newRow = { ...row };
      newRow['ì£¼ì†Œ'] = row[addressColumn];
      // ë³€í™˜ ê²°ê³¼ë¥¼ ìœ„í•œ ë¹ˆ ì»¬ëŸ¼ë“¤ ì´ˆê¸°í™”
      newRow['ì „ì²˜ë¦¬í›„ì£¼ì†Œ'] = '';
      newRow['í‚¤ì›Œë“œì£¼ì†Œ'] = '';
      newRow['ìœ„ë„'] = '';
      newRow['ê²½ë„'] = '';
      newRow['ë³€í™˜ì„±ê³µë°©ë²•'] = '';
      newRow['ë³€í™˜ì‹¤íŒ¨ì›ì¸'] = [];
      return newRow;
    });

    console.log(`ê°ì§€ëœ ì£¼ì†Œ ì»¬ëŸ¼: "${addressColumn}", ì´ ${normalizedData.length}ê°œ ë°ì´í„°`);
    console.log('ì²« ë²ˆì§¸ ì£¼ì†Œ ì˜ˆì‹œ:', normalizedData[0]['ì£¼ì†Œ']);

    // ì „ì—­ ë³€ìˆ˜ì— ì›ë³¸ ë°ì´í„° ì €ì¥
    window.conversionData = normalizedData;
    stats.originalData = [...normalizedData];

    stats = { total: normalizedData.length, success: 0, fail: 0, originalData: normalizedData };
    updateStats();
    convertAddresses(normalizedData);
  };
  reader.readAsArrayBuffer(fileInput.files[0]);
}

// ì£¼ì†Œ ì „ì²˜ë¦¬ ê°•í™” ë²„ì „
function preprocessAddress(addr) {
  if (!addr) return "";
  
  let cleaned = String(addr).trim();
  
  // 1ë‹¨ê³„: ê´„í˜¸ì™€ ë‚´ìš© ì œê±° (ì „í™”ë²ˆí˜¸, ìƒí˜¸ëª… ë“±)
  cleaned = cleaned.replace(/\([^)]*\)/g, "");
  cleaned = cleaned.replace(/\[[^\]]*\]/g, "");
  cleaned = cleaned.replace(/\{[^}]*\}/g, "");
  
  // 2ë‹¨ê³„: ì „í™”ë²ˆí˜¸ íŒ¨í„´ ì œê±°
  cleaned = cleaned.replace(/\d{2,4}-\d{3,4}-\d{4}/g, "");
  cleaned = cleaned.replace(/\d{3}-\d{4}-\d{4}/g, "");
  
  // 3ë‹¨ê³„: ì´ë©”ì¼ ì£¼ì†Œ ì œê±°
  cleaned = cleaned.replace(/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g, "");
  
  // 4ë‹¨ê³„: ìƒí˜¸ëª… íŒ¨í„´ ì œê±° (ì£¼ì‹íšŒì‚¬, ìœ í•œíšŒì‚¬ ë“±)
  cleaned = cleaned.replace(/(ì£¼ì‹íšŒì‚¬|ìœ í•œíšŒì‚¬|ì£¼ì‹|ìœ í•œ|íšŒì‚¬|\(ì£¼\)|\(ìœ \)|ãˆœ|ãˆ²)/g, "");
  
  // 5ë‹¨ê³„: ê±´ë¬¼ëª… í›„ì²˜ë¦¬ (ë¹Œë”©, íƒ€ì›Œ, ì„¼í„° ë“±ìœ¼ë¡œ ëë‚˜ëŠ” ê²½ìš° í•´ë‹¹ ë¶€ë¶„ë§Œ ì œê±°)
  cleaned = cleaned.replace(/\s*(ë¹Œë”©|íƒ€ì›Œ|ì„¼í„°|í”Œë¼ì|ëª°|ë§ˆíŠ¸|ìƒê°€|ì•„íŒŒíŠ¸|ì˜¤í”¼ìŠ¤í…”).*$/i, "");
  
  // 6ë‹¨ê³„: ì¸µìˆ˜ ì •ë³´ ì œê±°
  cleaned = cleaned.replace(/\s*\d+ì¸µ.*$/g, "");
  cleaned = cleaned.replace(/\s*[BGF]?\d+F.*$/gi, "");
  
  // 7ë‹¨ê³„: í˜¸ìˆ˜ ì •ë³´ ì œê±°
  cleaned = cleaned.replace(/\s*\d+í˜¸.*$/g, "");
  
  // 8ë‹¨ê³„: ìš°í¸ë²ˆí˜¸ ì œê±°
  cleaned = cleaned.replace(/\s*\d{5}(\s*-\s*\d{3})?\s*/g, " ");
  
  // 9ë‹¨ê³„: ë‹¤ì¤‘ ê³µë°±ì„ ë‹¨ì¼ ê³µë°±ìœ¼ë¡œ
  cleaned = cleaned.replace(/\s+/g, " ");
  
  // 10ë‹¨ê³„: í•œêµ­ ì£¼ì†Œ í‘œì¤€í™”
  cleaned = cleaned.replace(/íŠ¹ë³„ì‹œ/g, "ì‹œ");
  cleaned = cleaned.replace(/ê´‘ì—­ì‹œ/g, "ì‹œ");
  cleaned = cleaned.replace(/ìì¹˜ì‹œ/g, "ì‹œ");
  
  // 11ë‹¨ê³„: êµ¬ë‘ì  ì •ë¦¬
  cleaned = cleaned.replace(/[,;]/g, " ");
  cleaned = cleaned.replace(/\./g, "");
  
  // 12ë‹¨ê³„: ì‹œì‘ê³¼ ë ê³µë°± ì œê±°
  cleaned = cleaned.trim();
  
  return cleaned;
}

// ì£¼ì†Œ ë³€í™˜ ì‹¤íŒ¨ ì›ì¸ ë¶„ì„
function analyzeAddressFailure(originalAddr, preprocessedAddr) {
  const issues = [];
  
  if (!originalAddr || originalAddr.trim() === "") {
    issues.push("ë¹ˆ ì£¼ì†Œ");
    return issues;
  }
  
  // ê¸¸ì´ ì²´í¬
  if (originalAddr.length < 10) {
    issues.push("ì£¼ì†Œê°€ ë„ˆë¬´ ì§§ìŒ");
  }
  
  // ìˆ«ìë§Œ ìˆëŠ” ê²½ìš°
  if (/^\d+$/.test(originalAddr.trim())) {
    issues.push("ìˆ«ìë§Œ í¬í•¨");
  }
  
  // ì˜ë¬¸ë§Œ ìˆëŠ” ê²½ìš°
  if (/^[a-zA-Z\s]+$/.test(originalAddr.trim())) {
    issues.push("ì˜ë¬¸ë§Œ í¬í•¨");
  }
  
  // í•œê¸€ì´ ì—†ëŠ” ê²½ìš°
  if (!/[ê°€-í£]/.test(originalAddr)) {
    issues.push("í•œê¸€ ì£¼ì†Œ ì •ë³´ ì—†ìŒ");
  }
  
  // ì‹œ/ë„ ì •ë³´ ëˆ„ë½ ì²´í¬
  const hasCity = /[ê°€-í£]+(ì‹œ|ë„)/.test(originalAddr);
  if (!hasCity) {
    issues.push("ì‹œ/ë„ ì •ë³´ ëˆ„ë½");
  }
  
  // êµ¬/êµ° ì •ë³´ ì²´í¬
  const hasDistrict = /[ê°€-í£]+(êµ¬|êµ°)/.test(originalAddr);
  if (!hasDistrict) {
    issues.push("êµ¬/êµ° ì •ë³´ ëˆ„ë½");
  }
  
  // ì „í™”ë²ˆí˜¸ê°€ ì£¼ì†Œì™€ ì„ì—¬ìˆëŠ” ê²½ìš°
  if (/\d{2,4}-\d{3,4}-\d{4}/.test(originalAddr)) {
    issues.push("ì „í™”ë²ˆí˜¸ í¬í•¨");
  }
  
  // ìƒí˜¸ëª…ì´ í¬í•¨ëœ ê²½ìš°
  if (/(ì£¼ì‹íšŒì‚¬|ìœ í•œíšŒì‚¬|\(ì£¼\)|\(ìœ \)|ãˆœ|ãˆ²)/.test(originalAddr)) {
    issues.push("ìƒí˜¸ëª… í¬í•¨");
  }
  
  // ê±´ë¬¼ ìƒì„¸ì •ë³´ê°€ ê³¼ë„í•œ ê²½ìš°
  if (/(ë¹Œë”©|íƒ€ì›Œ|ì„¼í„°|í”Œë¼ì)/.test(originalAddr) && originalAddr.length > 50) {
    issues.push("ê±´ë¬¼ ìƒì„¸ì •ë³´ ê³¼ë‹¤");
  }
  
  // ì¤‘ë³µ ë²ˆì§€ ë¬¸ì œ ì²´í¬ (ì˜ˆ: "139-24 165-20")
  const duplicateJibunPattern = /(\d+(?:-\d+)?)\s+(\d+(?:-\d+)?)/;
  if (duplicateJibunPattern.test(originalAddr)) {
    issues.push("ì¤‘ë³µ ë²ˆì§€ ì •ë³´");
  }
  
  // ë„ë¡œëª… + ì¤‘ë³µ ë²ˆì§€ íŒ¨í„´ ì²´í¬
  const roadDuplicatePattern = /(ë¡œ|ê¸¸)\s*(\d+(?:-\d+)?)\s+(\d+(?:-\d+)?)/;
  if (roadDuplicatePattern.test(originalAddr)) {
    issues.push("ë„ë¡œëª… ì¤‘ë³µ ë²ˆì§€");
  }
  
  // í† ì§€ ëŒ€ì¥ í‘œê¸°ë²• ë¬¸ì œ ì²´í¬ (ì˜ˆ: "ì™¸ 1í•„ì§€", "ì™¸ 2í•„ì§€")
  if (/ì™¸\s*\d+\s*í•„ì§€/.test(originalAddr)) {
    issues.push("í† ì§€ ëŒ€ì¥ í‘œê¸° í¬í•¨");
  }
  
  // ê¸°íƒ€ í† ì§€ ê´€ë ¨ í‘œê¸° ì²´í¬ (ë‹¨, ì‚° ë²ˆì§€ëŠ” ìœ íš¨í•œ ì£¼ì†Œì´ë¯€ë¡œ ì œì™¸)
  if (/(ì¼ì›|ì¼ëŒ€|ë²ˆì§€|ì§€ë²ˆ|í•„ì§€)\s*$/.test(originalAddr)) {
    issues.push("í† ì§€ ê´€ë ¨ ì ‘ë¯¸ì‚¬");
  }
  
  // ì£¼ì˜: ì‚°123 í˜•íƒœëŠ” ìœ íš¨í•œ ì§€ë²ˆì£¼ì†Œì´ë¯€ë¡œ ì‹¤íŒ¨ ì›ì¸ìœ¼ë¡œ ë¶„ë¥˜í•˜ì§€ ì•ŠìŒ
  
  return issues;
}

// ì£¼ìš” í‚¤ì›Œë“œë§Œ ì¶”ì¶œí•˜ëŠ” í•¨ìˆ˜
function extractKeywords(addr) {
  if (!addr) return "";
  
  // ì‹œë„, êµ¬êµ°, ë™/ì/ë©´, ë¡œ/ê¸¸ ì •ë³´ë§Œ ì¶”ì¶œ
  const parts = addr.split(' ').filter(part => part.trim() !== '');
  const keywords = [];
  
  parts.forEach(part => {
    // ì‹œë„ ì •ë³´
    if (/(ì‹œ|ë„)$/.test(part) && part.length <= 10) {
      keywords.push(part);
    }
    // êµ¬êµ° ì •ë³´  
    else if (/(êµ¬|êµ°)$/.test(part) && part.length <= 10) {
      keywords.push(part);
    }
    // ë™ìë©´ ì •ë³´
    else if (/(ë™|ì|ë©´)$/.test(part) && part.length <= 15) {
      keywords.push(part);
    }
    // ë¡œê¸¸ ì •ë³´
    else if (/(ë¡œ|ê¸¸)$/.test(part) && part.length <= 20) {
      keywords.push(part);
    }
  });
  
  return keywords.slice(0, 4).join(' '); // ìµœëŒ€ 4ê°œ í‚¤ì›Œë“œë§Œ
}

// ì£¼ì†Œ ë³€í™˜ - ë¬´í•œë£¨í”„ ë°©ì§€ ë° Places ê²€ìƒ‰ ì¶”ê°€
function convertAddresses(data) {
  const resultDiv = document.getElementById("result");
  let completed = 0;
  const maxRetries = 5; // ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ ì œí•œ

  function convertNext(index) {
    if (index >= data.length) {
      // ë³€í™˜ ì™„ë£Œ - ì‹œ ì •ë³´ ì¶”ê°€
      const resultCard = document.getElementById("resultCard");
      const optimizeBtn = document.getElementById("optimizeBtn");
      
      resultCard.className = "result-card success";
      resultDiv.innerHTML = `
        ğŸ‰ ëª¨ë“  ì£¼ì†Œ ë³€í™˜ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!<br>
        <small>ì„±ê³µ: ${stats.success}ê°œ | ì‹¤íŒ¨: ${stats.fail}ê°œ</small><br>
        <button class="btn btn-success" onclick="downloadConversionResults()" style="margin-top: 1rem;">
          ğŸ“Š ë³€í™˜ ê²°ê³¼ ë‹¤ìš´ë¡œë“œ (ì „ì²˜ë¦¬ í¬í•¨)
        </button>
      `;
      
      processedData = data.filter(row => row['ìœ„ë„'] && row['ê²½ë„']); // ì„±ê³µí•œ ê²ƒë§Œ
      
      // ì‹œ ì •ë³´ ì¶”ê°€
      processedData.forEach(row => {
        row['ì‹œ'] = extractCityFromAddress(row['ì£¼ì†Œ']);
      });
      
      // ì‹œë³„ í†µê³„ ì¶œë ¥
      const cityStats = {};
      processedData.forEach(row => {
        const city = row['ì‹œ'];
        cityStats[city] = (cityStats[city] || 0) + 1;
      });
      
      console.log('ì‹œë³„ ë¶„í¬:', cityStats);
      
      // ì‹¤íŒ¨ ì›ì¸ í†µê³„
      const failureStats = {};
      data.filter(row => !row['ìœ„ë„'] || !row['ê²½ë„']).forEach(row => {
        const failures = row['ë³€í™˜ì‹¤íŒ¨ì›ì¸'] || ['ì•Œ ìˆ˜ ì—†ìŒ'];
        failures.forEach(failure => {
          failureStats[failure] = (failureStats[failure] || 0) + 1;
        });
      });
      
      console.log('ì‹¤íŒ¨ ì›ì¸ í†µê³„:', failureStats);
      
      if (processedData.length > 0) {
        activateStep(3);
        optimizeBtn.disabled = false;
        showMapWithMarkers(processedData);
      } else {
        alert("ë³€í™˜ëœ ì£¼ì†Œê°€ ì—†ìŠµë‹ˆë‹¤. ì£¼ì†Œ í˜•ì‹ì„ í™•ì¸í•´ì£¼ì„¸ìš”.");
      }
      
      resetUI();
      return;
    }

    const row = data[index];
    const originalAddr = row['ì£¼ì†Œ'];
    
    if (!originalAddr) {
      row['ì „ì²˜ë¦¬í›„ì£¼ì†Œ'] = '';
      row['ìœ„ë„'] = '';
      row['ê²½ë„'] = '';
      row['ë³€í™˜ì‹¤íŒ¨ì›ì¸'] = ['ë¹ˆ ì£¼ì†Œ'];
      stats.fail++;
      nextRow();
      return;
    }

    resultDiv.innerHTML = `
      <div class="loading-spinner"></div>
      ë³€í™˜ ì¤‘... <strong>${originalAddr}</strong><br>
      <small>${completed + 1} / ${data.length}</small>
    `;

    // ë³€í™˜ ì‹œë„ íšŸìˆ˜ ì¶”ì  (ë¬´í•œë£¨í”„ ë°©ì§€)
    let attemptCount = 0;
    
    function attemptConversion() {
      attemptCount++;
      if (attemptCount > maxRetries) {
        console.error(`ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ ì´ˆê³¼: ${originalAddr}`);
        finalizeFailure(['ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ ì´ˆê³¼']);
        return;
      }

      // ì „ì²˜ë¦¬ ì‹¤í–‰
      const preprocessedAddr = preprocessAddress(originalAddr);
      row['ì „ì²˜ë¦¬í›„ì£¼ì†Œ'] = preprocessedAddr;
      
      // ì‹¤íŒ¨ ì›ì¸ ì‚¬ì „ ë¶„ì„
      const issues = analyzeAddressFailure(originalAddr, preprocessedAddr);
      
      console.log(`${attemptCount}ì°¨ ì‹œë„: ${originalAddr}`);
      
      // 1ì°¨ ì‹œë„: ì›ë˜ ì£¼ì†Œ
      geocoder.addressSearch(originalAddr, function(result, status) {
        if (status === kakao.maps.services.Status.OK) {
          finalizeSuccess(result[0].y, result[0].x, 'ì›ë³¸ì£¼ì†Œ');
        } else {
          // 2ì°¨ ì‹œë„: ì „ì²˜ë¦¬ëœ ì£¼ì†Œ
          if (preprocessedAddr && preprocessedAddr !== originalAddr) {
            geocoder.addressSearch(preprocessedAddr, function(result2, status2) {
              if (status2 === kakao.maps.services.Status.OK) {
                finalizeSuccess(result2[0].y, result2[0].x, 'ì „ì²˜ë¦¬í›„');
              } else {
                attempt3rdConversion();
              }
            });
          } else {
            attempt3rdConversion();
          }
        }
      });
      
      function attempt3rdConversion() {
        // 3ì°¨ ì‹œë„: í‚¤ì›Œë“œ ì¶”ì¶œ
        const keywordAddr = extractKeywords(preprocessedAddr || originalAddr);
        if (keywordAddr && keywordAddr !== (preprocessedAddr || originalAddr)) {
          row['í‚¤ì›Œë“œì£¼ì†Œ'] = keywordAddr;
          geocoder.addressSearch(keywordAddr, function(result3, status3) {
            if (status3 === kakao.maps.services.Status.OK) {
              finalizeSuccess(result3[0].y, result3[0].x, 'í‚¤ì›Œë“œì¶”ì¶œ');
            } else {
              attempt4thConversion();
            }
          });
        } else {
          attempt4thConversion();
        }
      }
      
      function attempt4thConversion() {
        // 4ì°¨ ì‹œë„: Places APIë¡œ ê±´ë¬¼ëª… ê²€ìƒ‰
        const buildingName = extractBuildingName(originalAddr);
        const region = createSimplifiedAddress(originalAddr);
        
        if (buildingName) {
          row['ê±´ë¬¼ëª…'] = buildingName;
          console.log(`Places ê²€ìƒ‰: ${buildingName} in ${region}`);
          
          searchByPlaces(buildingName, region, function(places_result, places_status) {
            if (places_status === kakao.maps.services.Status.OK && places_result.length > 0) {
              // ê°€ì¥ ì •í™•í•œ ê²°ê³¼ ì„ íƒ (ì²« ë²ˆì§¸ ê²°ê³¼)
              const place = places_result[0];
              finalizeSuccess(place.y, place.x, 'Placesê²€ìƒ‰');
              console.log(`Places ê²€ìƒ‰ ì„±ê³µ: ${buildingName} â†’ ${place.place_name}`);
            } else {
              console.log(`Places ê²€ìƒ‰ ì‹¤íŒ¨: ${buildingName}`);
              finalizeFailure(issues.length > 0 ? issues : ['ëª¨ë“  ë³€í™˜ ë°©ë²• ì‹¤íŒ¨']);
            }
          });
        } else {
          finalizeFailure(issues.length > 0 ? issues : ['ê±´ë¬¼ëª… ì¶”ì¶œ ì‹¤íŒ¨']);
        }
      }
      
      function finalizeSuccess(lat, lng, method) {
        row['ìœ„ë„'] = lat;
        row['ê²½ë„'] = lng;
        row['ë³€í™˜ì„±ê³µë°©ë²•'] = method;
        row['ë³€í™˜ì‹¤íŒ¨ì›ì¸'] = [];
        stats.success++;
        console.log(`ë³€í™˜ ì„±ê³µ (${method}): ${originalAddr}`);
        nextRow();
      }
      
      function finalizeFailure(reasons) {
        row['ìœ„ë„'] = '';
        row['ê²½ë„'] = '';
        row['ë³€í™˜ì„±ê³µë°©ë²•'] = '';
        row['ë³€í™˜ì‹¤íŒ¨ì›ì¸'] = reasons;
        stats.fail++;
        console.log(`ë³€í™˜ ì‹¤íŒ¨: ${originalAddr} - ì‚¬ìœ : ${reasons.join(', ')}`);
        nextRow();
      }
    }
    
    // ì²« ë²ˆì§¸ ë³€í™˜ ì‹œë„ ì‹œì‘
    attemptConversion();

    function nextRow() {
      completed++;
      updateStats();
      // ë¬´í•œë£¨í”„ ë°©ì§€ë¥¼ ìœ„í•´ ì¦‰ì‹œ ë‹¤ìŒìœ¼ë¡œ ì´ë™
      setTimeout(() => convertNext(index + 1), 200); // API í˜¸ì¶œ ê°„ê²© ì¡°ê¸ˆ ì¦ê°€
    }
  }

  convertNext(0);
}

// ë³€í™˜ ê²°ê³¼ ë‹¤ìš´ë¡œë“œ í•¨ìˆ˜
function downloadConversionResults() {
  if (!window.conversionData || window.conversionData.length === 0) {
    alert('ë³€í™˜ëœ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
    return;
  }

  // ë³€í™˜ ê²°ê³¼ ë°ì´í„° ì •ë¦¬
  const enhancedData = window.conversionData.map(row => {
    const newRow = { ...row };
    
    // ì‹¤íŒ¨ ì›ì¸ì„ ë¬¸ìì—´ë¡œ ë³€í™˜ (ë°°ì—´ì´ë©´)
    if (Array.isArray(newRow['ë³€í™˜ì‹¤íŒ¨ì›ì¸'])) {
      newRow['ë³€í™˜ì‹¤íŒ¨ì›ì¸'] = newRow['ë³€í™˜ì‹¤íŒ¨ì›ì¸'].join(', ');
    }
    
    // ì„±ê³µ/ì‹¤íŒ¨ ì—¬ë¶€ ì¶”ê°€
    newRow['ë³€í™˜ê²°ê³¼'] = (newRow['ìœ„ë„'] && newRow['ê²½ë„']) ? 'ì„±ê³µ' : 'ì‹¤íŒ¨';
    
    // ì „ì²˜ë¦¬ íš¨ê³¼ ë¶„ì„
    if (newRow['ë³€í™˜ì„±ê³µë°©ë²•']) {
      if (newRow['ë³€í™˜ì„±ê³µë°©ë²•'] === 'ì›ë³¸ì£¼ì†Œ') {
        newRow['ì „ì²˜ë¦¬íš¨ê³¼'] = 'ë¶ˆí•„ìš”';
      } else if (newRow['ë³€í™˜ì„±ê³µë°©ë²•'] === 'ì „ì²˜ë¦¬í›„') {
        newRow['ì „ì²˜ë¦¬íš¨ê³¼'] = 'ìœ íš¨';
      } else if (newRow['ë³€í™˜ì„±ê³µë°©ë²•'] === 'í‚¤ì›Œë“œì¶”ì¶œ') {
        newRow['ì „ì²˜ë¦¬íš¨ê³¼'] = 'í‚¤ì›Œë“œì¶”ì¶œ í•„ìš”';
      }
    } else {
      newRow['ì „ì²˜ë¦¬íš¨ê³¼'] = 'íš¨ê³¼ì—†ìŒ';
    }
    
    return newRow;
  });

  // í†µê³„ ì •ë³´ ì‹œíŠ¸ ìƒì„±
  const successCount = enhancedData.filter(row => row['ë³€í™˜ê²°ê³¼'] === 'ì„±ê³µ').length;
  const failCount = enhancedData.filter(row => row['ë³€í™˜ê²°ê³¼'] === 'ì‹¤íŒ¨').length;
  const preprocessingEffective = enhancedData.filter(row => row['ì „ì²˜ë¦¬íš¨ê³¼'] === 'ìœ íš¨').length;
  const keywordEffective = enhancedData.filter(row => row['ì „ì²˜ë¦¬íš¨ê³¼'] === 'í‚¤ì›Œë“œì¶”ì¶œ í•„ìš”').length;
  
  // ì‹¤íŒ¨ ì›ì¸ë³„ í†µê³„
  const failureReasons = {};
  enhancedData.filter(row => row['ë³€í™˜ê²°ê³¼'] === 'ì‹¤íŒ¨').forEach(row => {
    const reason = row['ë³€í™˜ì‹¤íŒ¨ì›ì¸'] || 'ì•Œ ìˆ˜ ì—†ìŒ';
    failureReasons[reason] = (failureReasons[reason] || 0) + 1;
  });
  
  const statsData = [
    { 'í•­ëª©': 'ì „ì²´ ì£¼ì†Œ ìˆ˜', 'ê°’': enhancedData.length },
    { 'í•­ëª©': 'ë³€í™˜ ì„±ê³µ', 'ê°’': successCount },
    { 'í•­ëª©': 'ë³€í™˜ ì‹¤íŒ¨', 'ê°’': failCount },
    { 'í•­ëª©': 'ì„±ê³µë¥ (%)', 'ê°’': Math.round(successCount / enhancedData.length * 100) },
    { 'í•­ëª©': 'ì „ì²˜ë¦¬ íš¨ê³¼', 'ê°’': preprocessingEffective },
    { 'í•­ëª©': 'í‚¤ì›Œë“œ ì¶”ì¶œ íš¨ê³¼', 'ê°’': keywordEffective },
    { 'í•­ëª©': '', 'ê°’': '' },
    { 'í•­ëª©': '=== ì‹¤íŒ¨ ì›ì¸ë³„ í†µê³„ ===', 'ê°’': '' }
  ];
  
  Object.entries(failureReasons).forEach(([reason, count]) => {
    statsData.push({ 'í•­ëª©': reason, 'ê°’': count });
  });

  // ì›Œí¬ë¶ ìƒì„±
  const workbook = XLSX.utils.book_new();
  
  // ë©”ì¸ ë°ì´í„° ì‹œíŠ¸
  const mainSheet = XLSX.utils.json_to_sheet(enhancedData);
  XLSX.utils.book_append_sheet(workbook, mainSheet, "ë³€í™˜ê²°ê³¼_ì „ì²´");
  
  // ì„±ê³µ ë°ì´í„°ë§Œ
  const successData = enhancedData.filter(row => row['ë³€í™˜ê²°ê³¼'] === 'ì„±ê³µ');
  if (successData.length > 0) {
    const successSheet = XLSX.utils.json_to_sheet(successData);
    XLSX.utils.book_append_sheet(workbook, successSheet, "ë³€í™˜ì„±ê³µ_ë°ì´í„°");
  }
  
  // ì‹¤íŒ¨ ë°ì´í„°ë§Œ
  const failData = enhancedData.filter(row => row['ë³€í™˜ê²°ê³¼'] === 'ì‹¤íŒ¨');
  if (failData.length > 0) {
    const failSheet = XLSX.utils.json_to_sheet(failData);
    XLSX.utils.book_append_sheet(workbook, failSheet, "ë³€í™˜ì‹¤íŒ¨_ë°ì´í„°");
  }
  
  // í†µê³„ ì‹œíŠ¸
  const statsSheet = XLSX.utils.json_to_sheet(statsData);
  XLSX.utils.book_append_sheet(workbook, statsSheet, "ë³€í™˜í†µê³„");
  
  const now = new Date();
  const timestamp = now.toISOString().slice(0, 16).replace('T', '_').replace(/:/g, '');
  XLSX.writeFile(workbook, `ì£¼ì†Œë³€í™˜ê²°ê³¼_${timestamp}.xlsx`);
  
  // ì•Œë¦¼ì°½ìœ¼ë¡œ ê²°ê³¼ ìš”ì•½ í‘œì‹œ
  alert(`ë³€í™˜ ê²°ê³¼ ë‹¤ìš´ë¡œë“œ ì™„ë£Œ!\n\n` +
        `ğŸ“Š ì „ì²´: ${enhancedData.length}ê°œ\n` +
        `âœ… ì„±ê³µ: ${successCount}ê°œ (${Math.round(successCount/enhancedData.length*100)}%)\n` +
        `âŒ ì‹¤íŒ¨: ${failCount}ê°œ (${Math.round(failCount/enhancedData.length*100)}%)\n` +
        `ğŸ”§ ì „ì²˜ë¦¬ íš¨ê³¼: ${preprocessingEffective}ê°œ\n` +
        `ğŸ” í‚¤ì›Œë“œ ì¶”ì¶œ íš¨ê³¼: ${keywordEffective}ê°œ`);
}

// ì§€ë„ì— ëª¨ë“  ë§ˆì»¤ í‘œì‹œ
function showMapWithMarkers(data) {
  const mapDiv = document.getElementById("map");
  mapDiv.style.display = "block";
  
  const bounds = new kakao.maps.LatLngBounds();
  
  data.forEach((row, index) => {
    if (row['ìœ„ë„'] && row['ê²½ë„']) {
      const position = new kakao.maps.LatLng(row['ìœ„ë„'], row['ê²½ë„']);
      
      const marker = new kakao.maps.Marker({
        position: position,
        map: map
      });
      
      const infowindow = new kakao.maps.InfoWindow({
        content: `<div style="padding:5px;font-size:12px;">${row['ì£¼ì†Œ']}<br><small>${row['ì‹œ']}</small></div>`
      });
      
      kakao.maps.event.addListener(marker, 'click', function() {
        infowindow.open(map, marker);
      });
      
      bounds.extend(position);
    }
  });
  
  if (data.length > 0) {
    map.setBounds(bounds);
  } else {
    map.setCenter(new kakao.maps.LatLng(37.413479, 127.125512));
  }
}

// ë‘ ì  ê°„ ê±°ë¦¬ ê³„ì‚° (í•˜ë²„ì‚¬ì¸ ê³µì‹)
function calculateDistance(lat1, lng1, lat2, lng2) {
  const R = 6371;
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLng = (lng2 - lng1) * Math.PI / 180;
  const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
    Math.sin(dLng/2) * Math.sin(dLng/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

// ê·¼ë¬´ì¼ ê³„ì‚° (ì£¼ë§ ì œì™¸)
function getWorkingDay(dayOffset) {
  const today = new Date();
  let workingDays = 0;
  let currentDate = new Date(today);

  while (workingDays <= dayOffset) {
    if (currentDate.getDay() !== 0 && currentDate.getDay() !== 6) { // ì£¼ë§ ì œì™¸
      if (workingDays === dayOffset) {
        return currentDate.toLocaleDateString('ko-KR', {
          month: 'long',
          day: 'numeric',
          weekday: 'short'
        });
      }
      workingDays++;
    }
    currentDate.setDate(currentDate.getDate() + 1);
  }
}

// ê±°ë¦¬ ì œì•½ì„ ê³ ë ¤í•œ íš¨ìœ¨ì ì¸ ê²½ë¡œ ìµœì í™” í´ëŸ¬ìŠ¤í„°ë§
function cityBasedClustering(data, maxVisitsPerDay) {
  console.log('ê±°ë¦¬ ì œì•½ ê²½ë¡œ ìµœì í™” ì‹œì‘:', data.length, 'ê°œ ë°ì´í„°');
  
  const minVisitsPerDay = Math.max(2, maxVisitsPerDay - 1);
  const maxDailyDistance = 80; // km ì œí•œ
  console.log('ì œì•½ ì¡°ê±´:', minVisitsPerDay, '~', maxVisitsPerDay, 'ê°œì†Œ,', maxDailyDistance, 'km ì´í•˜');
  
  // 1ë‹¨ê³„: ì‹œë³„ ê·¸ë£¹í™”
  const cityGroups = {};
  data.forEach(item => {
    const city = item['ì‹œ'] || 'ê¸°íƒ€';
    if (!cityGroups[city]) {
      cityGroups[city] = [];
    }
    cityGroups[city].push(item);
  });
  
  const sortedCities = Object.keys(cityGroups).sort((a, b) => cityGroups[b].length - cityGroups[a].length);
  console.log('ì‹œë³„ ë¶„í¬:', sortedCities.map(city => `${city}: ${cityGroups[city].length}ê°œ`));
  
  // 2ë‹¨ê³„: ê±°ë¦¬ ì œì•½ì„ ê³ ë ¤í•œ ë©”ì¸ í´ëŸ¬ìŠ¤í„° ìƒì„±
  const mainClusters = [];
  const remainingData = [];
  
  sortedCities.forEach(city => {
    const cityData = [...cityGroups[city]];
    
    while (cityData.length >= minVisitsPerDay) {
      // ê±°ë¦¬ ì œì•½ì„ ë§Œì¡±í•˜ëŠ” ìµœì  ë¶€ë¶„ì§‘í•© ì„ íƒ
      const optimalSubset = selectDistanceConstrainedSubset(cityData, maxVisitsPerDay, maxDailyDistance);
      
      if (optimalSubset.length >= minVisitsPerDay) {
        mainClusters.push({
          locations: optimalSubset,
          cities: [city],
          centroid: calculateCentroid(optimalSubset),
          totalDistance: calculateClusterTotalDistance(optimalSubset),
          hasCapacity: optimalSubset.length < maxVisitsPerDay
        });
        
        // ì„ íƒëœ í•­ëª©ë“¤ì„ ì›ë³¸ ë°°ì—´ì—ì„œ ì œê±°
        optimalSubset.forEach(selected => {
          const index = cityData.findIndex(item => item === selected);
          if (index >= 0) cityData.splice(index, 1);
        });
      } else {
        // ìµœì†Œ ì¡°ê±´ë„ ë§Œì¡±í•˜ì§€ ëª»í•˜ë©´ ë‚¨ì€ ë°ì´í„°ë¡œ ì²˜ë¦¬
        remainingData.push(...cityData.splice(0));
      }
    }
    
    // ë‚¨ì€ ì‘ì€ ë°ì´í„°ë“¤
    if (cityData.length > 0) {
      remainingData.push(...cityData);
    }
  });
  
  console.log(`ë©”ì¸ í´ëŸ¬ìŠ¤í„° ${mainClusters.length}ê°œ ìƒì„±, ë‚¨ì€ ë°ì´í„° ${remainingData.length}ê°œ`);
  
  // 3ë‹¨ê³„: ë‚¨ì€ ë°ì´í„°ë¥¼ ê±°ë¦¬ ì œì•½ ë‚´ì—ì„œ ê¸°ì¡´ í´ëŸ¬ìŠ¤í„°ì— ë°°ì¹˜
  distributeRemainingDataWithDistanceConstraint(mainClusters, remainingData, maxVisitsPerDay, minVisitsPerDay, maxDailyDistance);
  
  // 4ë‹¨ê³„: ìµœì¢… ê²€ì¦
  const finalClusters = mainClusters.filter(cluster => cluster.locations.length > 0);
  const totalAssigned = finalClusters.reduce((sum, cluster) => sum + cluster.locations.length, 0);
  
  console.log(`ìµœì¢… ê²°ê³¼: ${finalClusters.length}ê°œ í´ëŸ¬ìŠ¤í„°, ${totalAssigned}ê°œ ìœ„ì¹˜ ë°°ì¹˜`);
  
  finalClusters.forEach((cluster, index) => {
    const distance = calculateClusterTotalDistance(cluster.locations);
    const status = distance <= maxDailyDistance ? 'âœ“' : 'âš ï¸';
    console.log(`${status} í´ëŸ¬ìŠ¤í„° ${index + 1}: ${cluster.locations.length}ê³³, ${distance.toFixed(1)}km (${cluster.cities.join(', ')})`);
  });
  
  return finalClusters.map(cluster => cluster.locations);
}

// ê±°ë¦¬ ì œì•½ì„ ê³ ë ¤í•œ ìµœì  ë¶€ë¶„ì§‘í•© ì„ íƒ
function selectDistanceConstrainedSubset(data, maxCount, maxDistance) {
  if (data.length <= 1) return [...data];
  
  // ì‹œì‘ ì „ëµ: ì—¬ëŸ¬ ì‹œë“œ í¬ì¸íŠ¸ë¡œ ì‹œë„í•˜ì—¬ ìµœì  ê²°ê³¼ ì„ íƒ
  let bestSubset = [];
  let bestScore = -Infinity; // ì ìˆ˜ê°€ ë†’ì„ìˆ˜ë¡ ì¢‹ìŒ (ë§ì€ ì  + ì ì€ ê±°ë¦¬)
  
  const trySeeds = Math.min(5, data.length);
  
  for (let seedTry = 0; seedTry < trySeeds; seedTry++) {
    const subset = [];
    const available = [...data];
    
    // ì‹œë“œ ì„ íƒ (ì¤‘ì‹¬ì  ê¸°ë°˜ ë˜ëŠ” ëœë¤)
    let seedIndex;
    if (seedTry === 0) {
      // ì²« ë²ˆì§¸ëŠ” ì¤‘ì‹¬ì ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ì 
      const centroid = calculateCentroid(data);
      seedIndex = 0;
      let minDist = Infinity;
      data.forEach((point, idx) => {
        const dist = calculateDistance(
          parseFloat(point['ìœ„ë„']), parseFloat(point['ê²½ë„']),
          centroid.lat, centroid.lng
        );
        if (dist < minDist) {
          minDist = dist;
          seedIndex = idx;
        }
      });
    } else {
      // ë‚˜ë¨¸ì§€ëŠ” ëœë¤
      seedIndex = Math.floor(Math.random() * available.length);
    }
    
    subset.push(available[seedIndex]);
    available.splice(seedIndex, 1);
    
    // ê·¸ë¦¬ë”” ë°©ì‹ìœ¼ë¡œ ì ì§„ì  ì¶”ê°€
    while (subset.length < maxCount && available.length > 0) {
      let bestCandidate = null;
      let bestCandidateIndex = -1;
      let bestDistance = Infinity;
      
      available.forEach((candidate, idx) => {
        const testSubset = [...subset, candidate];
        const totalDistance = calculateClusterTotalDistance(testSubset);
        
        if (totalDistance <= maxDistance) {
          // ì¶”ê°€ ì‹œ í‰ê·  ê±°ë¦¬ ì¦ê°€ëŸ‰ ê³„ì‚°
          const avgDistanceIncrease = totalDistance - calculateClusterTotalDistance(subset);
          
          if (avgDistanceIncrease < bestDistance) {
            bestDistance = avgDistanceIncrease;
            bestCandidate = candidate;
            bestCandidateIndex = idx;
          }
        }
      });
      
      if (bestCandidate) {
        subset.push(bestCandidate);
        available.splice(bestCandidateIndex, 1);
      } else {
        break; // ë” ì´ìƒ ì¶”ê°€í•  ìˆ˜ ì—†ìŒ
      }
    }
    
    // ì ìˆ˜ ê³„ì‚°: ì  ê°œìˆ˜ 100ì  + ê±°ë¦¬ íš¨ìœ¨ì„± ì ìˆ˜
    const distance = calculateClusterTotalDistance(subset);
    const score = subset.length * 100 - distance; // ë§ì€ ì , ì ì€ ê±°ë¦¬ì¼ìˆ˜ë¡ ë†’ì€ ì ìˆ˜
    
    if (score > bestScore && distance <= maxDistance) {
      bestScore = score;
      bestSubset = [...subset];
    }
  }
  
  console.log(`ê±°ë¦¬ ì œì•½ ë¶€ë¶„ì§‘í•©: ${bestSubset.length}ê°œ ì„ íƒ, ${calculateClusterTotalDistance(bestSubset).toFixed(1)}km`);
  return bestSubset;
}

// í´ëŸ¬ìŠ¤í„° ë‚´ ì´ ì´ë™ê±°ë¦¬ ê³„ì‚° (TSP ê·¼ì‚¬)
function calculateClusterTotalDistance(locations) {
  if (locations.length <= 1) return 0;
  if (locations.length === 2) {
    return calculateDistance(
      parseFloat(locations[0]['ìœ„ë„']), parseFloat(locations[0]['ê²½ë„']),
      parseFloat(locations[1]['ìœ„ë„']), parseFloat(locations[1]['ê²½ë„'])
    );
  }
  
  // ê°„ë‹¨í•œ ìµœê·¼ì ‘ ì´ì›ƒ TSPë¡œ ê²½ë¡œ ê±°ë¦¬ ì¶”ì •
  const visited = new Array(locations.length).fill(false);
  let totalDistance = 0;
  let currentIndex = 0;
  visited[currentIndex] = true;
  
  for (let step = 1; step < locations.length; step++) {
    let nearestIndex = -1;
    let nearestDistance = Infinity;
    
    for (let i = 0; i < locations.length; i++) {
      if (!visited[i]) {
        const distance = calculateDistance(
          parseFloat(locations[currentIndex]['ìœ„ë„']), parseFloat(locations[currentIndex]['ê²½ë„']),
          parseFloat(locations[i]['ìœ„ë„']), parseFloat(locations[i]['ê²½ë„'])
        );
        
        if (distance < nearestDistance) {
          nearestDistance = distance;
          nearestIndex = i;
        }
      }
    }
    
    if (nearestIndex >= 0) {
      totalDistance += nearestDistance;
      currentIndex = nearestIndex;
      visited[currentIndex] = true;
    }
  }
  
  return totalDistance;
}

// ê±°ë¦¬ ì œì•½ì„ ê³ ë ¤í•œ ë‚¨ì€ ë°ì´í„° ë°°ì¹˜
function distributeRemainingDataWithDistanceConstraint(clusters, remainingData, maxVisitsPerDay, minVisitsPerDay, maxDistance) {
  console.log(`ê±°ë¦¬ ì œì•½ ë‚¨ì€ ë°ì´í„° ë°°ì¹˜: ${remainingData.length}ê°œ`);
  
  remainingData.forEach(point => {
    let bestCluster = null;
    let bestScore = Infinity;
    
    // ì—¬ìœ  ê³µê°„ì´ ìˆëŠ” í´ëŸ¬ìŠ¤í„°ë“¤ ì¤‘ì—ì„œ ì„ íƒ
    const availableClusters = clusters.filter(cluster => cluster.locations.length < maxVisitsPerDay);
    
    availableClusters.forEach(cluster => {
      const testLocations = [...cluster.locations, point];
      const newTotalDistance = calculateClusterTotalDistance(testLocations);
      
      // ê±°ë¦¬ ì œì•½ì„ ë§Œì¡±í•˜ëŠ”ì§€ í™•ì¸
      if (newTotalDistance <= maxDistance) {
        const insertionScore = calculateInsertionScore(point, cluster);
        const cityMatch = cluster.cities.includes(point['ì‹œ'] || 'ê¸°íƒ€');
        const newCityCount = new Set([...cluster.cities, point['ì‹œ'] || 'ê¸°íƒ€']).size;
        
        let adjustedScore = insertionScore;
        if (cityMatch) adjustedScore *= 0.3; // ê°™ì€ ì‹œë©´ 70% í• ì¸
        if (newCityCount > 3) adjustedScore *= 3.0; // ì‹œ ê°œìˆ˜ ì´ˆê³¼ì‹œ í˜ë„í‹°
        
        // ê±°ë¦¬ íš¨ìœ¨ì„± ë³´ë„ˆìŠ¤
        const distanceEfficiency = 1.0 - (newTotalDistance / maxDistance);
        adjustedScore *= (1.0 + distanceEfficiency);
        
        if (adjustedScore < bestScore) {
          bestScore = adjustedScore;
          bestCluster = cluster;
        }
      }
    });
    
    if (bestCluster) {
      bestCluster.locations.push(point);
      const newCity = point['ì‹œ'] || 'ê¸°íƒ€';
      if (!bestCluster.cities.includes(newCity)) {
        bestCluster.cities.push(newCity);
      }
      bestCluster.centroid = calculateCentroid(bestCluster.locations);
      bestCluster.totalDistance = calculateClusterTotalDistance(bestCluster.locations);
    } else {
      // ê¸°ì¡´ í´ëŸ¬ìŠ¤í„°ì— ë°°ì¹˜í•  ìˆ˜ ì—†ìœ¼ë©´ ìƒˆë¡œìš´ í´ëŸ¬ìŠ¤í„° ìƒì„±
      clusters.push({
        locations: [point],
        cities: [point['ì‹œ'] || 'ê¸°íƒ€'],
        centroid: {
          lat: parseFloat(point['ìœ„ë„']),
          lng: parseFloat(point['ê²½ë„'])
        },
        totalDistance: 0,
        hasCapacity: true
      });
    }
  });
  
  // ì—¬ì „íˆ ì‘ì€ í´ëŸ¬ìŠ¤í„°ë“¤ì„ ê±°ë¦¬ ì œì•½ ë‚´ì—ì„œ ë³‘í•©
  mergeSmallClustersWithDistance(clusters, minVisitsPerDay, maxVisitsPerDay, maxDistance);
  
  console.log(`ë°°ì¹˜ ì™„ë£Œ: ${clusters.length}ê°œ í´ëŸ¬ìŠ¤í„°`);
}

// ê±°ë¦¬ ì œì•½ì„ ê³ ë ¤í•œ ì‘ì€ í´ëŸ¬ìŠ¤í„° ë³‘í•©
function mergeSmallClustersWithDistance(clusters, minVisitsPerDay, maxVisitsPerDay, maxDistance) {
  let attempts = 0;
  const maxAttempts = 10;
  
  while (attempts < maxAttempts) {
    attempts++;
    
    const smallClusters = clusters.filter(c => c.locations.length < minVisitsPerDay && c.locations.length > 0);
    
    if (smallClusters.length === 0) break;
    
    let merged = false;
    
    for (let i = 0; i < smallClusters.length - 1; i++) {
      const cluster1 = smallClusters[i];
      
      for (let j = i + 1; j < smallClusters.length; j++) {
        const cluster2 = smallClusters[j];
        
        const combinedLocations = [...cluster1.locations, ...cluster2.locations];
        const totalSize = combinedLocations.length;
        const combinedCities = new Set([...cluster1.cities, ...cluster2.cities]);
        const combinedDistance = calculateClusterTotalDistance(combinedLocations);
        
        if (totalSize <= maxVisitsPerDay && combinedCities.size <= 3 && combinedDistance <= maxDistance) {
          // ë³‘í•© ì‹¤í–‰
          cluster1.locations = combinedLocations;
          cluster1.cities = Array.from(combinedCities);
          cluster1.centroid = calculateCentroid(cluster1.locations);
          cluster1.totalDistance = combinedDistance;
          
          // cluster2 ë¹„ìš°ê¸°
          cluster2.locations = [];
          cluster2.cities = [];
          
          console.log(`ê±°ë¦¬ ì œì•½ ë³‘í•©: ${totalSize}ê°œì†Œ, ${combinedDistance.toFixed(1)}km`);
          merged = true;
          break;
        }
      }
      
      if (merged) break;
    }
    
    if (!merged) break;
  }
}

// í´ëŸ¬ìŠ¤í„°ì— ì ì„ ì¶”ê°€í–ˆì„ ë•Œì˜ íš¨ìœ¨ì„± ì ìˆ˜ ê³„ì‚°
function calculateInsertionScore(point, cluster) {
  const pointLat = parseFloat(point['ìœ„ë„']);
  const pointLng = parseFloat(point['ê²½ë„']);
  
  if (cluster.locations.length === 0) {
    return 0;
  }
  
  // í´ëŸ¬ìŠ¤í„° ë‚´ ëª¨ë“  ì ë“¤ê³¼ì˜ í‰ê·  ê±°ë¦¬
  let totalDistance = 0;
  cluster.locations.forEach(existing => {
    totalDistance += calculateDistance(
      pointLat, pointLng,
      parseFloat(existing['ìœ„ë„']), parseFloat(existing['ê²½ë„'])
    );
  });
  
  const avgDistance = totalDistance / cluster.locations.length;
  
  // í´ëŸ¬ìŠ¤í„° ì¤‘ì‹¬ì ê³¼ì˜ ê±°ë¦¬
  const distToCentroid = calculateDistance(
    pointLat, pointLng,
    cluster.centroid.lat, cluster.centroid.lng
  );
  
  // ìµœì¢… ì ìˆ˜: í‰ê·  ê±°ë¦¬ 70% + ì¤‘ì‹¬ì  ê±°ë¦¬ 30%
  return 0.7 * avgDistance + 0.3 * distToCentroid;
}

// í´ëŸ¬ìŠ¤í„° ì¤‘ì‹¬ì  ê³„ì‚°
function calculateCentroid(cluster) {
  if (cluster.length === 0) return { lat: 0, lng: 0 };
  
  const sumLat = cluster.reduce((sum, point) => sum + parseFloat(point['ìœ„ë„']), 0);
  const sumLng = cluster.reduce((sum, point) => sum + parseFloat(point['ê²½ë„']), 0);
  
  return {
    lat: sumLat / cluster.length,
    lng: sumLng / cluster.length
  };
}

// ìµœì í™” ì‹œì‘ ë˜í¼ í•¨ìˆ˜
function startOptimization() {
  console.log('startOptimization í˜¸ì¶œë¨');
  
  // ì…ë ¥ê°’ ê²€ì¦
  const maxWorkHours = document.getElementById('maxWorkHours').value;
  const maxVisitsPerDay = document.getElementById('maxVisitsPerDay').value;
  const avgStayTime = document.getElementById('avgStayTime').value;
  const startLocation = document.getElementById('startLocation').value;
  
  console.log('ì…ë ¥ê°’ ê²€ì¦:', {
    processedData: processedData ? processedData.length : 'null',
    maxWorkHours,
    maxVisitsPerDay,
    avgStayTime,
    startLocation
  });
  
  if (!processedData || processedData.length === 0) {
    alert("ë¨¼ì € ì£¼ì†Œ ë³€í™˜ì„ ì™„ë£Œí•´ì£¼ì„¸ìš”.");
    return;
  }
  
  if (!maxWorkHours || !maxVisitsPerDay || !avgStayTime) {
    alert("ëª¨ë“  ì„¤ì •ê°’ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.");
    return;
  }
  
  if (!startLocation.trim()) {
    alert("ì¶œë°œì§€ ì£¼ì†Œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.");
    document.getElementById('startLocation').focus();
    return;
  }
  
  // ì‹¤ì œ ìµœì í™” í•¨ìˆ˜ í˜¸ì¶œ
  optimizeSchedule();
}

// ìŠ¤ì¼€ì¤„ ìµœì í™”
async function optimizeSchedule() {
  console.log('optimizeSchedule ì‹œì‘');
  
  const maxWorkHours = parseInt(document.getElementById('maxWorkHours').value);
  const maxVisitsPerDay = parseInt(document.getElementById('maxVisitsPerDay').value);
  const avgStayTime = parseInt(document.getElementById('avgStayTime').value);
  const startLocation = document.getElementById('startLocation').value.trim();

  console.log('ìµœì í™” ì„¤ì •:', { 
    ë°ì´í„°ìˆ˜: processedData.length, 
    maxWorkHours, 
    maxVisitsPerDay, 
    avgStayTime, 
    startLocation 
  });

  // ë²„íŠ¼ ë¹„í™œì„±í™”
  const optimizeBtn = document.getElementById('optimizeBtn');
  optimizeBtn.disabled = true;
  optimizeBtn.innerHTML = '<div class="loading-spinner"></div> AI ì‹œë³„ ê²½ë¡œ ìµœì í™” ì¤‘...';

  try {
    activateStep(4);
    const scheduleContainer = document.getElementById('scheduleContainer');
    scheduleContainer.innerHTML = '<div class="result-card processing"><div class="loading-spinner"></div> AIê°€ ì‹œë³„ ìµœì  ê²½ë¡œë¥¼ ê³„ì‚°í•˜ê³  ìˆìŠµë‹ˆë‹¤...</div>';
    scheduleContainer.style.display = 'block';

    // ì¶œë°œì§€ ì¢Œí‘œ ë³€í™˜
    console.log('ì¶œë°œì§€ ì¢Œí‘œ ë³€í™˜ ì‹œì‘:', startLocation);
    let startCoords = null;
    
    await new Promise((resolve) => {
      geocoder.addressSearch(startLocation, function(result, status) {
        console.log('ì¶œë°œì§€ ê²€ìƒ‰ ê²°ê³¼:', status, result);
        if (status === kakao.maps.services.Status.OK && result.length > 0) {
          startCoords = { 
            ìœ„ë„: parseFloat(result[0].y), 
            ê²½ë„: parseFloat(result[0].x), 
            ì£¼ì†Œ: startLocation 
          };
          console.log('ì¶œë°œì§€ ì¢Œí‘œ ì„¤ì •:', startCoords);
          resolve();
        } else {
          console.error('ì¶œë°œì§€ ê²€ìƒ‰ ì‹¤íŒ¨');
          alert('ì¶œë°œì§€ ì£¼ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ' + startLocation);
          resetOptimizeButton();
          resolve();
        }
      });
    });

    if (!startCoords) {
      console.log('ì¶œë°œì§€ ì¢Œí‘œ ì—†ìŒ, ì¢…ë£Œ');
      return;
    }

    // ë°ì´í„° ì „ì²˜ë¦¬ - ìœ íš¨í•œ ì¢Œí‘œë§Œ í•„í„°ë§
    const validData = processedData.filter(item => {
      const lat = parseFloat(item['ìœ„ë„']);
      const lng = parseFloat(item['ê²½ë„']);
      return !isNaN(lat) && !isNaN(lng) && lat !== 0 && lng !== 0;
    });

    console.log('ìœ íš¨í•œ ë°ì´í„°:', validData.length, 'ê°œ');

    if (validData.length === 0) {
      alert('ìœ íš¨í•œ ìœ„ì¹˜ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
      resetOptimizeButton();
      return;
    }

    // ì‹œë³„ í´ëŸ¬ìŠ¤í„°ë§ ì ìš©
    console.log('ì‹œë³„ í´ëŸ¬ìŠ¤í„°ë§ ì‹œì‘...');
    const clusters = cityBasedClustering(validData, maxVisitsPerDay);
    console.log('ì‹œë³„ í´ëŸ¬ìŠ¤í„°ë§ ì™„ë£Œ:', clusters.length, 'ê°œ ê·¸ë£¹');
    
    optimizedSchedule = [];
    let totalDistance = 0;

    // ê° í´ëŸ¬ìŠ¤í„° ìµœì í™”
    for (let i = 0; i < clusters.length; i++) {
      if (clusters[i].length === 0) continue;
      
      console.log(`Day ${i + 1} ìµœì í™” ì‹œì‘: ${clusters[i].length}ê°œ ìœ„ì¹˜`);
      
      // ì¶œë°œì§€ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ì§€ì  ì°¾ê¸°
      let startIndex = 0;
      let minDistanceToStart = Infinity;
      
      clusters[i].forEach((location, index) => {
        const lat = parseFloat(location['ìœ„ë„']);
        const lng = parseFloat(location['ê²½ë„']);
        const distance = calculateDistance(startCoords.ìœ„ë„, startCoords.ê²½ë„, lat, lng);
        if (distance < minDistanceToStart) {
          minDistanceToStart = distance;
          startIndex = index;
        }
      });

      // ê°œì„ ëœ TSP ê²½ë¡œ ìµœì í™”
      const dayRoute = optimizedTSP(clusters[i], startCoords);
      
      // ë°©ë¬¸í•˜ëŠ” ì‹œ ëª©ë¡ ì¶”ì¶œ
      const visitedCities = [...new Set(dayRoute.map(location => location['ì‹œ']))];
      
      // ê±°ë¦¬ ë° ì‹œê°„ì€ ìµœì í™”ëœ ê²½ë¡œë¡œ ë‹¤ì‹œ ê³„ì‚°
      const dayDistance = calculateRouteDistance(dayRoute, startCoords);
      const dayTime = Math.round(dayDistance * 2) + (dayRoute.length * avgStayTime); // ì´ë™ì‹œê°„ + ì²´ë¥˜ì‹œê°„
      
      optimizedSchedule.push({
        day: i + 1,
        date: getWorkingDay(i),
        locations: dayRoute,
        cities: visitedCities,
        distance: Math.round(dayDistance * 10) / 10,
        estimatedTime: Math.round(dayTime),
        startLocation: startCoords
      });
      
      totalDistance += dayDistance;
      console.log(`Day ${i + 1} ì™„ë£Œ: ${dayRoute.length}ê³³, ë°©ë¬¸ ì‹œ: [${visitedCities.join(', ')}], ${Math.round(dayDistance * 10) / 10}km, ${Math.round(dayTime)}ë¶„`);
    }

    console.log('ì „ì²´ ìµœì í™” ì™„ë£Œ:', optimizedSchedule.length, 'ì¼');
    console.log('optimizedSchedule:', optimizedSchedule);
    
    displaySchedule();

  } catch (error) {
    console.error('ìµœì í™” ì¤‘ ì˜¤ë¥˜:', error);
    alert('ìµœì í™” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
  } finally {
    resetOptimizeButton();
  }
}

// ìµœì í™” ë²„íŠ¼ ë¦¬ì…‹
function resetOptimizeButton() {
  const optimizeBtn = document.getElementById('optimizeBtn');
  optimizeBtn.disabled = false;
  optimizeBtn.innerHTML = 'ğŸ¤– AI ì‹œë³„ ê²½ë¡œ ìµœì í™” ì‹œì‘';
}

// ê¸°ë³¸ TSP ì•Œê³ ë¦¬ì¦˜ (ìµœê·¼ì ‘ ì´ì›ƒë²•)
function nearestNeighborTSP(locations, startIndex = 0) {
  const n = locations.length;
  if (n <= 1) return locations;
  
  const visited = new Array(n).fill(false);
  const route = [];
  let current = startIndex;
  
  route.push(locations[current]);
  visited[current] = true;
  
  for (let i = 1; i < n; i++) {
    let nearest = -1;
    let minDistance = Infinity;
    
    for (let j = 0; j < n; j++) {
      if (!visited[j]) {
        const distance = calculateDistance(
          parseFloat(locations[current]['ìœ„ë„']), parseFloat(locations[current]['ê²½ë„']),
          parseFloat(locations[j]['ìœ„ë„']), parseFloat(locations[j]['ê²½ë„'])
        );
        if (distance < minDistance) {
          minDistance = distance;
          nearest = j;
        }
      }
    }
    
    if (nearest !== -1) {
      route.push(locations[nearest]);
      visited[nearest] = true;
      current = nearest;
    }
  }
  
  return route;
}

// ê°œì„ ëœ TSP ì•Œê³ ë¦¬ì¦˜ (Nearest Neighbor + 2-opt ê°œì„ )
function optimizedTSP(locations, startCoords) {
  console.log('ìµœì í™”ëœ TSP ì‹œì‘:', locations.length, 'ê°œ ìœ„ì¹˜');
  
  const n = locations.length;
  if (n <= 1) return locations;
  
  // 1ë‹¨ê³„: ì¶œë°œì§€ì—ì„œ ê°€ì¥ íš¨ìœ¨ì ì¸ ì‹œì‘ì  ì°¾ê¸°
  let bestStartIndex = 0;
  let bestTotalDistance = Infinity;
  
  // ì—¬ëŸ¬ ì‹œì‘ì ì„ ì‹œë„í•´ì„œ ìµœì  ì‹œì‘ì  ì°¾ê¸°
  for (let startIndex = 0; startIndex < Math.min(n, 3); startIndex++) {
    const route = nearestNeighborTSP(locations, startIndex);
    const totalDistance = calculateRouteDistance(route, startCoords);
    
    if (totalDistance < bestTotalDistance) {
      bestTotalDistance = totalDistance;
      bestStartIndex = startIndex;
    }
  }
  
  // 2ë‹¨ê³„: ìµœì  ì‹œì‘ì ìœ¼ë¡œ Nearest Neighbor TSP ì‹¤í–‰
  let initialRoute = nearestNeighborTSP(locations, bestStartIndex);
  
  // 3ë‹¨ê³„: 2-opt ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ê²½ë¡œ ê°œì„ 
  let improvedRoute = twoOptImprovement(initialRoute);
  
  console.log(`TSP ì™„ë£Œ: ${improvedRoute.length}ê°œ ìœ„ì¹˜, ì´ ê±°ë¦¬: ${calculateRouteDistance(improvedRoute, startCoords).toFixed(2)}km`);
  
  return improvedRoute;
}

// ì „ì²´ ê²½ë¡œì˜ ì´ ê±°ë¦¬ ê³„ì‚° (ì¶œë°œì§€ í¬í•¨)
function calculateRouteDistance(route, startCoords) {
  if (route.length === 0) return 0;
  
  let totalDistance = 0;
  
  // ì¶œë°œì§€ â†’ ì²« ë²ˆì§¸ ë°©ë¬¸ì§€
  totalDistance += calculateDistance(
    startCoords.ìœ„ë„, startCoords.ê²½ë„,
    parseFloat(route[0]['ìœ„ë„']), parseFloat(route[0]['ê²½ë„'])
  );
  
  // ë°©ë¬¸ì§€ë“¤ ê°„ ê±°ë¦¬
  for (let i = 1; i < route.length; i++) {
    totalDistance += calculateDistance(
      parseFloat(route[i-1]['ìœ„ë„']), parseFloat(route[i-1]['ê²½ë„']),
      parseFloat(route[i]['ìœ„ë„']), parseFloat(route[i]['ê²½ë„'])
    );
  }
  
  // ë§ˆì§€ë§‰ ë°©ë¬¸ì§€ â†’ ì¶œë°œì§€ (ë³µê·€)
  totalDistance += calculateDistance(
    parseFloat(route[route.length-1]['ìœ„ë„']), parseFloat(route[route.length-1]['ê²½ë„']),
    startCoords.ìœ„ë„, startCoords.ê²½ë„
  );
  
  return totalDistance;
}

// 2-opt ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ê²½ë¡œ ê°œì„ 
function twoOptImprovement(route) {
  if (route.length <= 3) return route;
  
  let improved = true;
  let bestRoute = [...route];
  let maxIterations = 50;
  let iteration = 0;
  
  while (improved && iteration < maxIterations) {
    improved = false;
    iteration++;
    
    for (let i = 1; i < bestRoute.length - 2; i++) {
      for (let j = i + 1; j < bestRoute.length; j++) {
        if (j - i === 1) continue; // ì¸ì ‘í•œ ì—£ì§€ëŠ” ìŠ¤í‚µ
        
        // í˜„ì¬ ê±°ë¦¬ ê³„ì‚°
        const currentDistance = 
          calculateDistance(
            parseFloat(bestRoute[i-1]['ìœ„ë„']), parseFloat(bestRoute[i-1]['ê²½ë„']),
            parseFloat(bestRoute[i]['ìœ„ë„']), parseFloat(bestRoute[i]['ê²½ë„'])
          ) +
          calculateDistance(
            parseFloat(bestRoute[j]['ìœ„ë„']), parseFloat(bestRoute[j]['ê²½ë„']),
            parseFloat(bestRoute[j === bestRoute.length - 1 ? 0 : j + 1]['ìœ„ë„']), 
            parseFloat(bestRoute[j === bestRoute.length - 1 ? 0 : j + 1]['ê²½ë„'])
          );
        
        // 2-opt ìŠ¤ì™‘ í›„ ê±°ë¦¬ ê³„ì‚°
        const newDistance = 
          calculateDistance(
            parseFloat(bestRoute[i-1]['ìœ„ë„']), parseFloat(bestRoute[i-1]['ê²½ë„']),
            parseFloat(bestRoute[j]['ìœ„ë„']), parseFloat(bestRoute[j]['ê²½ë„'])
          ) +
          calculateDistance(
            parseFloat(bestRoute[i]['ìœ„ë„']), parseFloat(bestRoute[i]['ê²½ë„']),
            parseFloat(bestRoute[j === bestRoute.length - 1 ? 0 : j + 1]['ìœ„ë„']), 
            parseFloat(bestRoute[j === bestRoute.length - 1 ? 0 : j + 1]['ê²½ë„'])
          );
        
        // ê°œì„ ë˜ë©´ ìŠ¤ì™‘ ì‹¤í–‰
        if (newDistance < currentDistance) {
          const newRoute = [...bestRoute];
          // ië¶€í„° jê¹Œì§€ êµ¬ê°„ì„ ë’¤ì§‘ê¸°
          for (let k = 0; k < Math.ceil((j - i + 1) / 2); k++) {
            const temp = newRoute[i + k];
            newRoute[i + k] = newRoute[j - k];
            newRoute[j - k] = temp;
          }
          
          bestRoute = newRoute;
          improved = true;
        }
      }
    }
  }
  
  console.log(`2-opt ê°œì„  ì™„ë£Œ: ${iteration}íšŒ ë°˜ë³µ`);
  return bestRoute;
}

// ìŠ¤ì¼€ì¤„ í‘œì‹œ
function displaySchedule() {
  console.log('displaySchedule ì‹œì‘, optimizedSchedule:', optimizedSchedule);
  
  if (!optimizedSchedule || optimizedSchedule.length === 0) {
    console.error('ìµœì í™”ëœ ìŠ¤ì¼€ì¤„ì´ ì—†ìŒ');
    alert('ìŠ¤ì¼€ì¤„ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
    return;
  }

  const scheduleContainer = document.getElementById('scheduleContainer');
  const downloadBtn = document.getElementById('downloadScheduleBtn');
  
  let html = '';
  let totalDistance = 0;
  let totalEstimatedTime = 0;
  let totalLocations = 0;

  optimizedSchedule.forEach((day, dayIndex) => {
    console.log(`Day ${day.day} í‘œì‹œ ì¤‘:`, day);
    
    totalDistance += day.distance || 0;
    totalEstimatedTime += day.estimatedTime || 0;
    totalLocations += day.locations ? day.locations.length : 0;
    
    html += `
      <div class="day-card">
        <div class="day-header">
          <div>
            <div class="day-title">ğŸ“… Day ${day.day} - ${day.date || 'ë‚ ì§œ ë¯¸ì„¤ì •'}</div>
            <div class="day-cities">ğŸ™ï¸ ë°©ë¬¸ ì§€ì—­: ${day.cities && day.cities.length > 0 ? day.cities.join(', ') : 'ë¯¸ì„¤ì •'}</div>
          </div>
          <div class="day-summary">${day.locations ? day.locations.length : 0}ê³³ ë°©ë¬¸ | ${day.distance || 0}km | ${Math.floor((day.estimatedTime || 0)/60)}ì‹œê°„ ${(day.estimatedTime || 0)%60}ë¶„</div>
        </div>
        <div class="day-content">
    `;
    
    // ì¶œë°œì§€ í‘œì‹œ
    html += `
      <div class="visit-item">
        <div class="visit-number">ğŸ </div>
        <div class="visit-details">
          <div class="visit-address">ğŸ“ ì¶œë°œì§€: ${day.startLocation ? day.startLocation.ì£¼ì†Œ : 'ì¶œë°œì§€ ë¯¸ì„¤ì •'}</div>
          <div class="visit-time">09:00 ì¶œë°œ</div>
        </div>
      </div>
    `;
    
    // ë°©ë¬¸ì§€ë“¤ í‘œì‹œ
    if (day.locations && day.locations.length > 0) {
      let currentTime = 9 * 60; // 9:00 AM in minutes
      const avgStayTime = parseInt(document.getElementById('avgStayTime').value) || 60;
      
      // ì²« ë²ˆì§¸ ì¥ì†Œê¹Œì§€ ì´ë™ì‹œê°„
      if (day.startLocation && day.locations[0]) {
        const travelTime = calculateDistance(
          day.startLocation.ìœ„ë„, day.startLocation.ê²½ë„,
          parseFloat(day.locations[0]['ìœ„ë„']), parseFloat(day.locations[0]['ê²½ë„'])
        ) * 2;
        currentTime += travelTime;
      }
      
      day.locations.forEach((location, index) => {
        const arrivalHour = Math.floor(currentTime / 60);
        const arrivalMin = Math.round(currentTime % 60);
        const departureTime = currentTime + avgStayTime;
        const departureHour = Math.floor(departureTime / 60);
        const departureMinute = Math.round(departureTime % 60);
        
        html += `
          <div class="visit-item">
            <div class="visit-number">${index + 1}</div>
            <div class="visit-details">
              <div class="visit-address">${location['ì£¼ì†Œ'] || 'ì£¼ì†Œ ë¯¸ì„¤ì •'}</div>
              <div class="visit-city">${location['ì‹œ'] || 'ì‹œ ë¯¸ì„¤ì •'}</div>
              <div class="visit-time">
                ${String(arrivalHour).padStart(2, '0')}:${String(arrivalMin).padStart(2, '0')} ë„ì°© â†’ 
                ${String(departureHour).padStart(2, '0')}:${String(departureMinute).padStart(2, '0')} ì¶œë°œ
              </div>
            </div>
          </div>
        `;
        
        // ë‹¤ìŒ ì¥ì†Œë¡œ ì´ë™ì‹œê°„ ê³„ì‚°
        if (index < day.locations.length - 1) {
          const lat1 = parseFloat(location['ìœ„ë„']);
          const lng1 = parseFloat(location['ê²½ë„']);
          const lat2 = parseFloat(day.locations[index + 1]['ìœ„ë„']);
          const lng2 = parseFloat(day.locations[index + 1]['ê²½ë„']);
          const travelTime = calculateDistance(lat1, lng1, lat2, lng2) * 2;
          currentTime = departureTime + travelTime;
        }
      });
    }
    
    html += `
        </div>
      </div>
    `;
  });

  // ì´ ìš”ì•½ ì •ë³´
  const avgDailyTime = optimizedSchedule.length > 0 ? Math.round(totalEstimatedTime / 60 / optimizedSchedule.length) : 0;
  const totalCitiesVisited = [...new Set(optimizedSchedule.flatMap(day => day.cities))].length;
  
  html += `
    <div class="total-summary">
      <h3>ğŸ“Š ì „ì²´ ì¼ì • ìš”ì•½</h3>
      <div class="summary-grid">
        <div class="summary-item">
          <div class="summary-value">${optimizedSchedule.length}</div>
          <div class="summary-label">ì´ ê·¼ë¬´ì¼</div>
        </div>
        <div class="summary-item">
          <div class="summary-value">${totalLocations}</div>
          <div class="summary-label">ì´ ë°©ë¬¸ì§€</div>
        </div>
        <div class="summary-item">
          <div class="summary-value">${totalCitiesVisited}</div>
          <div class="summary-label">ë°©ë¬¸ ì‹œ ìˆ˜</div>
        </div>
        <div class="summary-item">
          <div class="summary-value">${Math.round(totalDistance * 10) / 10}km</div>
          <div class="summary-label">ì´ ì´ë™ê±°ë¦¬</div>
        </div>
        <div class="summary-item">
          <div class="summary-value">${avgDailyTime}ì‹œê°„</div>
          <div class="summary-label">ì¼í‰ê·  ì—…ë¬´ì‹œê°„</div>
        </div>
      </div>
    </div>
  `;

  scheduleContainer.innerHTML = html;
  downloadBtn.style.display = 'block';
  
  console.log('ìŠ¤ì¼€ì¤„ í‘œì‹œ ì™„ë£Œ');
  console.log('ì´ê³„:', {
    ì¼ìˆ˜: optimizedSchedule.length,
    ë°©ë¬¸ì§€: totalLocations,
    ë°©ë¬¸ì‹œìˆ˜: totalCitiesVisited,
    ê±°ë¦¬: totalDistance,
    í‰ê· ì‹œê°„: avgDailyTime
  });
  
  // ìŠ¤ì¼€ì¤„ ì§€ë„ì— í‘œì‹œ
  displayScheduleOnMap();
}

// ìŠ¤ì¼€ì¤„ì„ ì§€ë„ì— í‘œì‹œ
function displayScheduleOnMap() {
  const mapDiv = document.getElementById("map");
  mapDiv.style.display = "block";
  
  // ê¸°ì¡´ ë§ˆì»¤ ì œê±°
  map = new kakao.maps.Map(document.getElementById("map"), {
    center: new kakao.maps.LatLng(37.413479, 127.125512),
    level: 4
  });
  
  const bounds = new kakao.maps.LatLngBounds();
  const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8'];
  
  optimizedSchedule.forEach((day, dayIndex) => {
    const color = colors[dayIndex % colors.length];
    
    // ì¶œë°œì§€ ë§ˆì»¤
    const startMarker = new kakao.maps.Marker({
      position: new kakao.maps.LatLng(day.startLocation.ìœ„ë„, day.startLocation.ê²½ë„),
      map: map,
      image: createMarkerImage('ğŸ ', '#2E8B57')
    });
    
    bounds.extend(new kakao.maps.LatLng(day.startLocation.ìœ„ë„, day.startLocation.ê²½ë„));
    
    // ë°©ë¬¸ì§€ ë§ˆì»¤ë“¤
    day.locations.forEach((location, index) => {
      const marker = new kakao.maps.Marker({
        position: new kakao.maps.LatLng(location['ìœ„ë„'], location['ê²½ë„']),
        map: map,
        image: createMarkerImage((index + 1).toString(), color)
      });
      
      const infowindow = new kakao.maps.InfoWindow({
        content: `
          <div style="padding:8px;font-size:12px;min-width:200px;">
            <strong>Day ${day.day} - ${index + 1}ë²ˆì§¸</strong><br>
            ${location['ì£¼ì†Œ']}<br>
            <small>ğŸ™ï¸ ${location['ì‹œ']}</small>
          </div>
        `
      });
      
      kakao.maps.event.addListener(marker, 'click', function() {
        infowindow.open(map, marker);
      });
      
      bounds.extend(new kakao.maps.LatLng(location['ìœ„ë„'], location['ê²½ë„']));
    });

    // ë°©ë¬¸ì§€ ê°„ ê²½ë¡œì„  ê·¸ë¦¬ê¸° (ì¶œë°œì§€ ì œì™¸, ë°©ë¬¸ì§€ 2ê°œ ì´ìƒì¼ ë•Œë§Œ)
    if (day.locations.length > 1) {
      const path = day.locations.map(loc => new kakao.maps.LatLng(loc['ìœ„ë„'], loc['ê²½ë„']));

      const polyline = new kakao.maps.Polyline({
        path: path,
        strokeWeight: 3,
        strokeColor: color,
        strokeOpacity: 0.8,
        strokeStyle: 'solid'
      });
      
      polyline.setMap(map);
    }
  });
  
  if (optimizedSchedule.length > 0) {
    map.setBounds(bounds);
  } else {
    map.setCenter(new kakao.maps.LatLng(37.413479, 127.125512));
  }
}

// ë§ˆì»¤ ì´ë¯¸ì§€ ìƒì„± í•¨ìˆ˜
function createMarkerImage(text, color) {
  const canvas = document.createElement('canvas');
  canvas.width = 30;
  canvas.height = 40;
  const ctx = canvas.getContext('2d');
  
  // ë§ˆì»¤ ë°°ê²½ ê·¸ë¦¬ê¸°
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(15, 0);
  ctx.lineTo(30, 15);
  ctx.lineTo(30, 25);
  ctx.lineTo(15, 40);
  ctx.lineTo(0, 25);
  ctx.lineTo(0, 15);
  ctx.closePath();
  ctx.fill();
  
  // í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸°
  ctx.fillStyle = 'white';
  ctx.font = text === 'ğŸ ' ? '16px Arial' : 'bold 12px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(text, 15, 20);
  
  const dataURL = canvas.toDataURL();
  return new kakao.maps.MarkerImage(dataURL, new kakao.maps.Size(30, 40));
}

// ìŠ¤ì¼€ì¤„ ë‹¤ìš´ë¡œë“œ
function downloadSchedule() {
  if (!optimizedSchedule || !processedData) return;

  // ì›ë³¸ ë°ì´í„° ë³µì‚¬ ë° ìŠ¤ì¼€ì¤„ ì •ë³´ ë§¤í•‘
  const enhancedData = processedData.map(originalRow => {
    // ì›ë³¸ ë°ì´í„°ì˜ ëª¨ë“  ì»¬ëŸ¼ì„ ìœ ì§€
    const newRow = { ...originalRow };
    
    // í•´ë‹¹ ì£¼ì†Œê°€ ìŠ¤ì¼€ì¤„ì— í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
    let scheduleInfo = null;
    let dayInfo = null;
    let visitOrder = null;
    
    for (let dayIndex = 0; dayIndex < optimizedSchedule.length; dayIndex++) {
      const day = optimizedSchedule[dayIndex];
      const locationIndex = day.locations.findIndex(loc => 
        loc['ì£¼ì†Œ'] === originalRow['ì£¼ì†Œ'] || 
        (loc['ìœ„ë„'] === originalRow['ìœ„ë„'] && loc['ê²½ë„'] === originalRow['ê²½ë„'])
      );
      
      if (locationIndex !== -1) {
        scheduleInfo = day;
        dayInfo = dayIndex + 1;
        visitOrder = locationIndex + 1;
        break;
      }
    }
    
    // ìŠ¤ì¼€ì¤„ ì •ë³´ ì¶”ê°€ (ìš°ì¸¡ ì»¬ëŸ¼ì—)
    if (scheduleInfo) {
      newRow['ë°©ë¬¸_ì¼ì°¨'] = `Day ${dayInfo}`;
      newRow['ë°©ë¬¸_ë‚ ì§œ'] = scheduleInfo.date || '';
      newRow['ë°©ë¬¸_ìˆœì„œ'] = visitOrder;
      newRow['ë°©ë¬¸_ë„ì‹œëª©ë¡'] = scheduleInfo.cities ? scheduleInfo.cities.join(', ') : '';
      newRow['ì˜ˆìƒ_ì²´ë¥˜ì‹œê°„(ë¶„)'] = document.getElementById('avgStayTime').value;
      newRow['ì¼ì¼_ì´ê±°ë¦¬(km)'] = visitOrder === 1 ? scheduleInfo.distance : '';
      newRow['ì¼ì¼_ì´ì‹œê°„(ë¶„)'] = visitOrder === 1 ? scheduleInfo.estimatedTime : '';
      newRow['ë°©ë¬¸_ì˜ˆì •ì‹œê°„'] = calculateVisitTime(scheduleInfo, visitOrder - 1);
    } else {
      // ìŠ¤ì¼€ì¤„ì— ì—†ëŠ” ê²½ìš° ë¹ˆ ê°’
      newRow['ë°©ë¬¸_ì¼ì°¨'] = '';
      newRow['ë°©ë¬¸_ë‚ ì§œ'] = '';
      newRow['ë°©ë¬¸_ìˆœì„œ'] = '';
      newRow['ë°©ë¬¸_ë„ì‹œëª©ë¡'] = '';
      newRow['ì˜ˆìƒ_ì²´ë¥˜ì‹œê°„(ë¶„)'] = '';
      newRow['ì¼ì¼_ì´ê±°ë¦¬(km)'] = '';
      newRow['ì¼ì¼_ì´ì‹œê°„(ë¶„)'] = '';
      newRow['ë°©ë¬¸_ì˜ˆì •ì‹œê°„'] = '';
    }
    
    return newRow;
  });

  const worksheet = XLSX.utils.json_to_sheet(enhancedData);
  const workbook = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(workbook, worksheet, "ì›ë³¸ë°ì´í„°_with_ìŠ¤ì¼€ì¤„");
  
  const now = new Date();
  const timestamp = now.toISOString().slice(0, 10);
  XLSX.writeFile(workbook, `ì‚¬ì—…ì¥_ë°©ë¬¸ìŠ¤ì¼€ì¤„_${timestamp}.xlsx`);
}

// ë°©ë¬¸ ì˜ˆì • ì‹œê°„ ê³„ì‚° í•¨ìˆ˜
function calculateVisitTime(daySchedule, locationIndex) {
  if (!daySchedule.locations || locationIndex < 0 || locationIndex >= daySchedule.locations.length) {
    return '';
  }
  
  const avgStayTime = parseInt(document.getElementById('avgStayTime').value) || 60;
  let currentTime = 9 * 60; // 9:00 AM in minutes
  
  // ì¶œë°œì§€ì—ì„œ ì²« ë²ˆì§¸ ì¥ì†Œê¹Œì§€ ì´ë™ì‹œê°„
  if (daySchedule.startLocation && daySchedule.locations[0]) {
    const travelTime = calculateDistance(
      daySchedule.startLocation.ìœ„ë„, daySchedule.startLocation.ê²½ë„,
      parseFloat(daySchedule.locations[0]['ìœ„ë„']), parseFloat(daySchedule.locations[0]['ê²½ë„'])
    ) * 2;
    currentTime += travelTime;
  }
  
  // í•´ë‹¹ ìœ„ì¹˜ê¹Œì§€ì˜ ëˆ„ì  ì‹œê°„ ê³„ì‚°
  for (let i = 0; i < locationIndex; i++) {
    // ì²´ë¥˜ì‹œê°„ ì¶”ê°€
    currentTime += avgStayTime;
    
    // ë‹¤ìŒ ì¥ì†Œë¡œ ì´ë™ì‹œê°„ ê³„ì‚°
    if (i < daySchedule.locations.length - 1) {
      const lat1 = parseFloat(daySchedule.locations[i]['ìœ„ë„']);
      const lng1 = parseFloat(daySchedule.locations[i]['ê²½ë„']);
      const lat2 = parseFloat(daySchedule.locations[i + 1]['ìœ„ë„']);
      const lng2 = parseFloat(daySchedule.locations[i + 1]['ê²½ë„']);
      const travelTime = calculateDistance(lat1, lng1, lat2, lng2) * 2;
      currentTime += travelTime;
    }
  }
  
  const arrivalHour = Math.floor(currentTime / 60);
  const arrivalMin = Math.round(currentTime % 60);
  const departureTime = currentTime + avgStayTime;
  const departureHour = Math.floor(departureTime / 60);
  const departureMinute = Math.round(departureTime % 60);
  
  return `${String(arrivalHour).padStart(2, '0')}:${String(arrivalMin).padStart(2, '0')} ë„ì°© â†’ ${String(departureHour).padStart(2, '0')}:${String(departureMinute).padStart(2, '0')} ì¶œë°œ`;
}

// UI ë¦¬ì…‹
function resetUI() {
  const convertBtn = document.getElementById("convertBtn");
  convertBtn.disabled = false;
  convertBtn.innerHTML = 'ì£¼ì†Œ â†’ ìœ„ê²½ë„ ë³€í™˜ ì‹œì‘';
}

window.onload = function() {
  console.log('í˜ì´ì§€ ë¡œë“œ ì™„ë£Œ');
  initMap();
  initFileUpload();
};
</script>
</body>
</html>
