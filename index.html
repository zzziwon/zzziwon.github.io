<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì¶œì¥ ê²½ë¡œ ìµœì í™”</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=0c62e9a12c740ee7f1620f92ec4659bf&libraries=services"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #3fa8e0 0%, #5ec9ff 50%, #a0e65f 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #3fa8e0 0%, #5ec9ff 50%, #a0e65f 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .content {
            padding: 30px;
        }
        
        .section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        
        .section h2 {
            color: #3fa8e0;
            margin-bottom: 20px;
            font-size: 1.5em;
            border-bottom: 3px solid #a0e65f;
            padding-bottom: 10px;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }
        
        .input-group input, .input-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }
        
        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #5ec9ff;
        }
        
        .input-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        
        button {
            background: linear-gradient(135deg, #3fa8e0 0%, #5ec9ff 50%, #a0e65f 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(63, 168, 224, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            background: #999;
            cursor: not-allowed;
            transform: none;
        }
        
        .file-upload {
            border: 3px dashed #a0e65f;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .file-upload:hover {
            background: #f0fff4;
        }
        
        .file-upload input[type="file"] {
            display: none;
        }
        
        .status {
            margin-top: 15px;
            padding: 12px;
            border-radius: 8px;
            font-weight: 500;
        }
        
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        #map {
            width: 100%;
            height: 600px;
            border-radius: 12px;
            margin-top: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e0e0e0;
            border-radius: 15px;
            overflow: hidden;
            margin: 15px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3fa8e0 0%, #5ec9ff 50%, #a0e65f 100%);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
        }
        
        .route-list {
            margin-top: 20px;
        }
        
        .day-schedule {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
        }
        
        .day-schedule h3 {
            color: #3fa8e0;
            margin-bottom: 15px;
        }
        
        .visit-item {
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .visit-item:hover {
            background: #e9ecef;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .conversion-stats {
            display: flex;
            gap: 20px;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        
        .stat-box {
            flex: 1;
            min-width: 150px;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        
        .stat-box.success {
            background: #d1fae5;
            border: 2px solid #a0e65f;
        }
        
        .stat-box.fail {
            background: #fee2e2;
            border: 2px solid #ef4444;
        }
        
        .stat-box.total {
            background: #dbeafe;
            border: 2px solid #5ec9ff;
        }
        
        .stat-number {
            font-size: 2em;
            font-weight: bold;
            margin: 5px 0;
        }
        
        .stat-label {
            font-size: 0.9em;
            color: #666;
        }
        
        .legend {
            display: flex;
            gap: 15px;
            margin: 15px 0;
            flex-wrap: wrap;
            padding: 15px;
            background: white;
            border-radius: 8px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸš— ì¶œì¥ ê²½ë¡œ ìµœì í™” ì‹œìŠ¤í…œ</h1>
            <p>ì—‘ì…€ íŒŒì¼ì„ ì—…ë¡œë“œí•˜ì—¬ ìµœì ì˜ ë°©ë¬¸ ê²½ë¡œë¥¼ ê³„íší•˜ì„¸ìš”</p>
        </div>
        
        <div class="content">
            <!-- 1ë‹¨ê³„: ì—‘ì…€ ì—…ë¡œë“œ ë° ë³€í™˜ -->
            <div class="section">
                <h2>ğŸ“ 1ë‹¨ê³„: ì—‘ì…€ íŒŒì¼ ì—…ë¡œë“œ ë° ì£¼ì†Œ ë³€í™˜</h2>
                <div class="file-upload" onclick="document.getElementById('excelFile').click()">
                    <p style="font-size: 1.2em; margin-bottom: 10px;">ğŸ“¤ í´ë¦­í•˜ì—¬ ì—‘ì…€ íŒŒì¼ ì—…ë¡œë“œ</p>
                    <p style="color: #666;">ì£¼ì†Œê°€ í¬í•¨ëœ ì—‘ì…€ íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”</p>
                    <input type="file" id="excelFile" accept=".xlsx,.xls" onchange="handleFileUpload(event)">
                </div>
                <div id="uploadStatus"></div>
                
                <!-- ì£¼ì†Œ ì—´ ì„ íƒ -->
                <div id="previewSection" style="display: none;">
                    <div class="input-group" style="margin-top: 20px;">
                        <label>ì£¼ì†Œê°€ í¬í•¨ëœ ì—´ì„ ì„ íƒí•˜ì„¸ìš”</label>
                        <select id="addressColumn">
                            <option value="">-- ì£¼ì†Œ ì—´ ì„ íƒ --</option>
                        </select>
                    </div>
                </div>
                
                <!-- ë³€í™˜ ì§„í–‰ ìƒí™© -->
                <div id="conversionStats" style="display: none;">
                    <div class="conversion-stats">
                        <div class="stat-box total">
                            <div class="stat-label">ì „ì²´</div>
                            <div class="stat-number" id="totalCount">0</div>
                        </div>
                        <div class="stat-box success">
                            <div class="stat-label">âœ… ì„±ê³µ</div>
                            <div class="stat-number" id="successCount">0</div>
                        </div>
                        <div class="stat-box fail">
                            <div class="stat-label">âŒ ì‹¤íŒ¨</div>
                            <div class="stat-number" id="failCount">0</div>
                        </div>
                    </div>
                    <div id="currentAddress" style="padding: 10px; background: #d1fae5; border-radius: 8px; margin-top: 10px; border-left: 4px solid #a0e65f;"></div>
                </div>
                
                <div id="progressBar" style="display: none;">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill">0%</div>
                    </div>
                </div>
                <div class="button-group" style="margin-top: 20px;">
                    <button id="convertBtn" onclick="convertAddresses()" disabled>ğŸ”„ ì£¼ì†Œ ë³€í™˜ ì‹œì‘</button>
                    <button id="downloadBtn" onclick="downloadExcel()" disabled>ğŸ’¾ ë³€í™˜ëœ íŒŒì¼ ë‹¤ìš´ë¡œë“œ</button>
                </div>
            </div>
            
            <!-- 2ë‹¨ê³„: ë°©ë¬¸ ì¼ì • ì„¤ì • -->
            <div class="section">
                <h2>ğŸ“… 2ë‹¨ê³„: ë°©ë¬¸ ì¼ì • ì„¤ì •</h2>
                <div class="input-row">
                    <div class="input-group">
                        <label>ì¼ì¼ ìµœëŒ€ ì—…ë¬´ì‹œê°„ (ì‹œê°„)</label>
                        <input type="number" id="maxHours" value="8" min="1" max="24">
                    </div>
                    <div class="input-group">
                        <label>ì¼ì¼ ë°©ë¬¸ ì—…ì²´ìˆ˜ (ê°œ)</label>
                        <input type="number" id="maxVisits" value="5" min="1" max="20">
                    </div>
                    <div class="input-group">
                        <label>í‰ê·  ì²´ë¥˜ì‹œê°„ (ë¶„)</label>
                        <input type="number" id="avgStay" value="30" min="5" max="180">
                    </div>
                </div>
                <div class="input-group">
                    <label>ì¶œë°œì§€ ì£¼ì†Œ</label>
                    <input type="text" id="startAddress" value="ê²½ê¸°ë„ ì„±ë‚¨ì‹œ ì¥ë¯¸ë¡œ 42" placeholder="ì˜ˆ: ì„œìš¸íŠ¹ë³„ì‹œ ê°•ë‚¨êµ¬ í…Œí—¤ë€ë¡œ 123">
                </div>
                <button id="optimizeBtn" onclick="optimizeRoute()" disabled>ğŸ¯ ê²½ë¡œ ìµœì í™” ì‹¤í–‰</button>
                <div id="optimizeStatus"></div>
                
                <!-- ìµœì í™” ì§„í–‰ ìƒí™© -->
                <div id="optimizeProgress" style="display: none;">
                    <div style="padding: 15px; background: #e3f2fd; border-radius: 8px; margin-top: 15px; border-left: 4px solid #5ec9ff;">
                        <div id="optimizeCurrentCity" style="font-weight: bold; margin-bottom: 10px;"></div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="optimizeProgressFill">0%</div>
                        </div>
                        <div id="optimizeDetail" style="margin-top: 10px; font-size: 0.9em; color: #666;"></div>
                    </div>
                </div>
            </div>
            
            <!-- 3ë‹¨ê³„: ê²°ê³¼ ë° ì§€ë„ -->
            <div class="section">
                <h2>ğŸ—ºï¸ 3ë‹¨ê³„: ìµœì í™”ëœ ê²½ë¡œ</h2>
                <div id="legendSection" style="display: none;">
                    <div class="legend" id="legend"></div>
                </div>
                <div id="routeResult"></div>
                <div id="map"></div>
            </div>
        </div>
    </div>

    <script>
        let uploadedData = [];
        let convertedData = [];
        let map = null;
        let markers = [];
        let geocoder = null;
        let startPoint = null;
        let selectedColumn = 0;
        
        // ë‚ ì§œë³„ ìƒ‰ìƒ ì •ì˜
        const dayColors = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8',
            '#F06292', '#BA68C8', '#9575CD', '#7986CB', '#64B5F6',
            '#4FC3F7', '#4DD0E1', '#4DB6AC', '#81C784', '#AED581'
        ];
        
        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì§€ë„ ë° Geocoder ì´ˆê¸°í™”
        window.onload = function() {
            if (typeof kakao === 'undefined') {
                showStatus('uploadStatus', 'âŒ ì¹´ì¹´ì˜¤ SDKê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. API í‚¤ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.', 'error');
                console.error('Kakao SDK not loaded');
                return;
            }
            
            console.log('Kakao SDK ë¡œë“œ ì™„ë£Œ');
            
            kakao.maps.load(function() {
                try {
                    geocoder = new kakao.maps.services.Geocoder();
                    initMap();
                    console.log('âœ… ì§€ë„ ë° Geocoder ì´ˆê¸°í™” ì™„ë£Œ');
                    testGeocoderAPI();
                } catch (error) {
                    console.error('ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
                    showStatus('uploadStatus', 'âŒ ì§€ë„ ì´ˆê¸°í™” ì‹¤íŒ¨: ' + error.message, 'error');
                }
            });
        };
        
        async function testGeocoderAPI() {
            console.log('\nğŸ§ª API í…ŒìŠ¤íŠ¸ ì‹œì‘...');
            const testAddress = 'ê²½ê¸° ê´‘ì£¼ì‹œ ê³¤ì§€ì•”ì ë§Œì‚¼ë¡œ 103-7';
            const result = await geocodeAddress(testAddress);
            if (result) {
                console.log('âœ… API í…ŒìŠ¤íŠ¸ ì„±ê³µ!', result);
                showStatus('uploadStatus', `âœ… API ì—°ê²° ì„±ê³µ! íŒŒì¼ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”.`, 'success');
            } else {
                console.log('âŒ API í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨');
                showStatus('uploadStatus', `âš ï¸ API í‚¤ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.`, 'error');
            }
        }
        
        function initMap() {
            const container = document.getElementById('map');
            const options = {
                center: new kakao.maps.LatLng(37.5665, 126.9780),
                level: 8
            };
            map = new kakao.maps.Map(container, options);
        }
        
        function showStatus(elementId, message, type) {
            const element = document.getElementById(elementId);
            element.innerHTML = `<div class="status ${type}">${message}</div>`;
        }
        
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            showStatus('uploadStatus', 'ğŸ“– íŒŒì¼ì„ ì½ëŠ” ì¤‘...', 'info');
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, {type: 'array'});
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    const jsonData = XLSX.utils.sheet_to_json(firstSheet, {header: 1});
                    
                    uploadedData = jsonData.filter(row => row.length > 0);
                    
                    if (uploadedData.length === 0) {
                        showStatus('uploadStatus', 'âŒ íŒŒì¼ì— ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.', 'error');
                        return;
                    }
                    
                    showStatus('uploadStatus', 
                        `âœ… íŒŒì¼ ì—…ë¡œë“œ ì™„ë£Œ! ì´ ${uploadedData.length}ê°œì˜ í–‰ì´ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤.`, 
                        'success');
                    
                    showColumnSelector();
                    
                } catch (error) {
                    showStatus('uploadStatus', `âŒ íŒŒì¼ ì½ê¸° ì‹¤íŒ¨: ${error.message}`, 'error');
                }
            };
            reader.readAsArrayBuffer(file);
        }
        
        function showColumnSelector() {
            const previewSection = document.getElementById('previewSection');
            const addressColumnSelect = document.getElementById('addressColumn');
            
            previewSection.style.display = 'block';
            
            addressColumnSelect.innerHTML = '<option value="">-- ì£¼ì†Œ ì—´ ì„ íƒ --</option>';
            if (uploadedData.length > 0) {
                const headerRow = uploadedData[0];
                headerRow.forEach((header, i) => {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = `${header} (ì—´ ${i + 1})`;
                    addressColumnSelect.appendChild(option);
                });
            }
            
            addressColumnSelect.onchange = function() {
                selectedColumn = parseInt(this.value);
                if (!isNaN(selectedColumn)) {
                    document.getElementById('convertBtn').disabled = false;
                }
            };
        }
        
        async function convertAddresses() {
            if (!geocoder) {
                showStatus('uploadStatus', 'âŒ ì§€ë„ê°€ ë¡œë”© ì¤‘ì…ë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.', 'error');
                return;
            }
            
            if (uploadedData.length <= 1) {
                showStatus('uploadStatus', 'âŒ ì—…ë¡œë“œëœ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.', 'error');
                return;
            }
            
            if (isNaN(selectedColumn)) {
                showStatus('uploadStatus', 'âŒ ì£¼ì†Œ ì—´ì„ ì„ íƒí•´ì£¼ì„¸ìš”.', 'error');
                return;
            }
            
            document.getElementById('convertBtn').disabled = true;
            document.getElementById('progressBar').style.display = 'block';
            document.getElementById('conversionStats').style.display = 'block';
            
            convertedData = [];
            let successCount = 0;
            let failCount = 0;
            
            const headerRow = [...uploadedData[0], 'ìœ„ë„', 'ê²½ë„'];
            convertedData.push(headerRow);
            
            const dataRows = uploadedData.slice(1);
            
            document.getElementById('totalCount').textContent = dataRows.length;
            document.getElementById('successCount').textContent = '0';
            document.getElementById('failCount').textContent = '0';
            
            for (let i = 0; i < dataRows.length; i++) {
                const row = dataRows[i];
                const address = row[selectedColumn];
                
                document.getElementById('currentAddress').innerHTML = 
                    `ğŸ”„ ë³€í™˜ ì¤‘ (${i + 1}/${dataRows.length}): <strong>${address || '(ë¹ˆ ê°’)'}</strong>`;
                
                if (!address || typeof address !== 'string') {
                    convertedData.push([...row, 'ë³€í™˜ ì‹¤íŒ¨', 'ë³€í™˜ ì‹¤íŒ¨']);
                    failCount++;
                    document.getElementById('failCount').textContent = failCount;
                    continue;
                }
                
                try {
                    const result = await geocodeAddress(address);
                    if (result) {
                        convertedData.push([...row, result.y, result.x]);
                        successCount++;
                        document.getElementById('successCount').textContent = successCount;
                        console.log(`âœ… ìµœì¢… ì„±ê³µ: ${address}`);
                    } else {
                        convertedData.push([...row, 'ë³€í™˜ ì‹¤íŒ¨', 'ë³€í™˜ ì‹¤íŒ¨']);
                        failCount++;
                        document.getElementById('failCount').textContent = failCount;
                        console.log(`âŒ ìµœì¢… ì‹¤íŒ¨: ${address}`);
                    }
                } catch (error) {
                    convertedData.push([...row, 'ì˜¤ë¥˜', 'ì˜¤ë¥˜']);
                    failCount++;
                    document.getElementById('failCount').textContent = failCount;
                    console.error(`ì˜¤ë¥˜ ë°œìƒ: ${address}`, error);
                }
                
                const progress = Math.round(((i + 1) / dataRows.length) * 100);
                document.getElementById('progressFill').style.width = progress + '%';
                document.getElementById('progressFill').textContent = progress + '%';
                
                await sleep(300);
            }
            
            document.getElementById('currentAddress').innerHTML = `âœ… ë³€í™˜ ì™„ë£Œ!`;
            
            showStatus('uploadStatus', 
                `âœ… ë³€í™˜ ì™„ë£Œ! ${successCount}/${dataRows.length}ê°œ ì£¼ì†Œ ë³€í™˜ ì„±ê³µ (ì‹¤íŒ¨: ${failCount}ê°œ)`, 
                'success');
            
            document.getElementById('downloadBtn').disabled = false;
            document.getElementById('optimizeBtn').disabled = false;
            document.getElementById('convertBtn').disabled = false;
        }
        
        function geocodeAddress(address) {
            return new Promise((resolve) => {
                if (!geocoder) {
                    resolve(null);
                    return;
                }
                
                if (!address || typeof address !== 'string' || address.trim() === '') {
                    resolve(null);
                    return;
                }
                
                const originalAddress = address.trim();
                console.log(`\nğŸ” ì›ë³¸ ì£¼ì†Œ: "${originalAddress}"`);
                
                const cleaningSteps = [
                    (addr) => addr,
                    (addr) => addr.replace(/\([^)]*\)/g, '').trim(),
                    (addr) => addr.replace(/\([^)]*\)/g, '').replace(/[\.Â·,]+$/g, '').trim(),
                    (addr) => {
                        const cleaned = addr.replace(/\([^)]*\)/g, '').replace(/[\.Â·,]+$/g, '').trim();
                        const parts = cleaned.split(' ');
                        if (parts.length > 3) {
                            return parts.slice(0, -1).join(' ');
                        }
                        return cleaned;
                    },
                    (addr) => {
                        const cleaned = addr.replace(/\([^)]*\)/g, '').replace(/[\.Â·,]+$/g, '').trim();
                        const parts = cleaned.split(' ');
                        if (parts.length > 4) {
                            return parts.slice(0, -2).join(' ');
                        }
                        return null;
                    },
                    (addr) => {
                        const cleaned = addr.replace(/\([^)]*\)/g, '').trim();
                        const match = cleaned.match(/(.*?[ì‹œêµ°êµ¬].*?[ìë©´ë™ë¦¬])\s+[\d-]+/);
                        if (match) {
                            return match[0];
                        }
                        return null;
                    }
                ];
                
                attemptGeocodeSequentially(originalAddress, cleaningSteps, 0, resolve);
            });
        }
        
        function attemptGeocodeSequentially(originalAddress, cleaningSteps, stepIndex, finalResolve) {
            if (stepIndex >= cleaningSteps.length) {
                console.log('  âŒ ëª¨ë“  ì‹œë„ ì‹¤íŒ¨');
                finalResolve(null);
                return;
            }
            
            const cleanedAddress = cleaningSteps[stepIndex](originalAddress);
            
            if (!cleanedAddress || cleanedAddress === '') {
                attemptGeocodeSequentially(originalAddress, cleaningSteps, stepIndex + 1, finalResolve);
                return;
            }
            
            if (stepIndex > 0) {
                console.log(`  ì‹œë„ ${stepIndex + 1}: "${cleanedAddress}"`);
            }
            
            geocoder.addressSearch(cleanedAddress, function(result, status) {
                if (status === kakao.maps.services.Status.OK && result && result.length > 0) {
                    console.log(`  âœ… ì„±ê³µ! (ì‹œë„ ${stepIndex + 1}) ì¢Œí‘œ: (${result[0].y}, ${result[0].x})`);
                    finalResolve({
                        x: result[0].x,
                        y: result[0].y,
                        address: result[0].address_name
                    });
                } else {
                    console.log(`  âŒ ì‹¤íŒ¨ (ì‹œë„ ${stepIndex + 1}, ìƒíƒœ: ${status})`);
                    attemptGeocodeSequentially(originalAddress, cleaningSteps, stepIndex + 1, finalResolve);
                }
            });
        }
        
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        function downloadExcel() {
            if (convertedData.length === 0) {
                alert('ë³€í™˜ëœ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }
            
            const ws = XLSX.utils.aoa_to_sheet(convertedData);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'ë³€í™˜ê²°ê³¼');
            
            const fileName = 'ì£¼ì†Œ_ìœ„ê²½ë„_ë³€í™˜_' + new Date().toISOString().slice(0,10) + '.xlsx';
            XLSX.writeFile(wb, fileName);
            
            showStatus('uploadStatus', 'âœ… íŒŒì¼ì´ ë‹¤ìš´ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤!', 'success');
        }
        
        async function optimizeRoute() {
            if (!geocoder) {
                showStatus('optimizeStatus', 'âŒ ì§€ë„ê°€ ë¡œë”© ì¤‘ì…ë‹ˆë‹¤.', 'error');
                return;
            }
            
            if (convertedData.length === 0) {
                showStatus('optimizeStatus', 'âŒ ë¨¼ì € ì£¼ì†Œë¥¼ ë³€í™˜í•´ì£¼ì„¸ìš”.', 'error');
                return;
            }
            
            const startAddress = document.getElementById('startAddress').value.trim();
            if (!startAddress) {
                showStatus('optimizeStatus', 'âŒ ì¶œë°œì§€ ì£¼ì†Œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.', 'error');
                return;
            }
            
            // ì§„í–‰ ìƒí™© UI í‘œì‹œ
            document.getElementById('optimizeProgress').style.display = 'block';
            document.getElementById('optimizeBtn').disabled = true;
            
            showStatus('optimizeStatus', 'ğŸ” ì¶œë°œì§€ ìœ„ì¹˜ë¥¼ ê²€ìƒ‰í•˜ëŠ” ì¤‘...', 'info');
            
            startPoint = await geocodeAddress(startAddress);
            if (!startPoint) {
                showStatus('optimizeStatus', 'âŒ ì¶œë°œì§€ ì£¼ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', 'error');
                document.getElementById('optimizeProgress').style.display = 'none';
                document.getElementById('optimizeBtn').disabled = false;
                return;
            }
            
            showStatus('optimizeStatus', 'ğŸ¯ ê²½ë¡œë¥¼ ìµœì í™”í•˜ëŠ” ì¤‘...', 'info');
            
            const maxHours = parseInt(document.getElementById('maxHours').value);
            const maxVisits = parseInt(document.getElementById('maxVisits').value);
            const avgStay = parseInt(document.getElementById('avgStay').value);
            
            const validLocations = convertedData.slice(1).filter(row => {
                const lat = parseFloat(row[row.length - 2]);
                const lng = parseFloat(row[row.length - 1]);
                return !isNaN(lat) && !isNaN(lng);
            });
            
            if (validLocations.length === 0) {
                showStatus('optimizeStatus', 'âŒ ìœ íš¨í•œ ìœ„ê²½ë„ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.', 'error');
                document.getElementById('optimizeProgress').style.display = 'none';
                document.getElementById('optimizeBtn').disabled = false;
                return;
            }
            
            const optimizedSchedule = await createOptimizedScheduleWithRealDistance(
                validLocations, 
                startPoint, 
                maxHours, 
                maxVisits, 
                avgStay
            );
            
            document.getElementById('optimizeProgress').style.display = 'none';
            
            displaySchedule(optimizedSchedule);
            displayMarkersOnMap(optimizedSchedule, startPoint);
            displayLegend(optimizedSchedule);
            
            showStatus('optimizeStatus', 'âœ… ê²½ë¡œ ìµœì í™” ì™„ë£Œ!', 'success');
            document.getElementById('optimizeBtn').disabled = false;
        }
        
        async function createOptimizedScheduleWithRealDistance(locations, start, maxHours, maxVisits, avgStay) {
            console.log(`ğŸ“Š ì´ ${locations.length}ê°œ ìœ„ì¹˜ ìµœì í™” ì‹œì‘`);
            
            // 1ë‹¨ê³„: ì‹œ/êµ°/êµ¬ë³„ë¡œ êµ°ì§‘í™”
            const clusters = clusterByCity(locations);
            console.log(`ğŸ“ ${clusters.length}ê°œ ì§€ì—­ìœ¼ë¡œ êµ°ì§‘í™” ì™„ë£Œ`);
            clusters.forEach(cluster => {
                console.log(`  - ${cluster.city}: ${cluster.locations.length}ê°œ`);
            });
            
            // 2ë‹¨ê³„: ì¶œë°œì§€ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ êµ°ì§‘ë¶€í„° ë°©ë¬¸ ìˆœì„œ ê²°ì •
            const orderedClusters = await orderClustersByDistance(clusters, start);
            console.log(`ğŸ—ºï¸ êµ°ì§‘ ë°©ë¬¸ ìˆœì„œ ê²°ì • ì™„ë£Œ`);
            
            // 3ë‹¨ê³„: ê° êµ°ì§‘ì„ ì¼ì¼ ìµœëŒ€ ë°©ë¬¸ìˆ˜ì— ë§ì¶° ë¶„í• 
            const schedule = [];
            let currentDay = 1;
            let currentDayVisits = [];
            let currentPosition = start;
            
            let totalProcessed = 0;
            const totalLocations = locations.length;
            
            for (let clusterIdx = 0; clusterIdx < orderedClusters.length; clusterIdx++) {
                const cluster = orderedClusters[clusterIdx];
                console.log(`\nğŸ™ï¸ ${cluster.city} ì§€ì—­ ìµœì í™” ì¤‘ (${cluster.locations.length}ê°œ)`);
                
                // ì§„í–‰ ìƒí™© ì—…ë°ì´íŠ¸
                document.getElementById('optimizeCurrentCity').textContent = 
                    `ğŸ™ï¸ ${cluster.city} ì§€ì—­ ì²˜ë¦¬ ì¤‘ (${clusterIdx + 1}/${orderedClusters.length})`;
                
                // êµ°ì§‘ì„ ì—¬ëŸ¬ ë‚ ë¡œ ë¶„í• í• ì§€ ê²°ì •
                let remainingInCluster = [...cluster.locations];
                
                while (remainingInCluster.length > 0) {
                    // í˜„ì¬ ë‚ ì˜ ë‚¨ì€ ìš©ëŸ‰ ê³„ì‚°
                    const remainingCapacity = maxVisits - currentDayVisits.length;
                    const remainingTime = (maxHours * 60) - currentDayVisits.reduce((sum, v) => sum + parseFloat(v.time), 0);
                    
                    console.log(`  ğŸ“… ${currentDay}ì¼ì°¨: í˜„ì¬ ${currentDayVisits.length}/${maxVisits}ê°œ, ë‚¨ì€ ìš©ëŸ‰: ${remainingCapacity}ê°œ`);
                    
                    // í˜„ì¬ ë‚ ì— ì¶”ê°€í•  ìˆ˜ ìˆëŠ” ìµœëŒ€ ê°œìˆ˜ ê²°ì •
                    const batchSize = Math.min(remainingCapacity, remainingInCluster.length);
                    
                    if (batchSize === 0 || remainingTime < 30) {
                        // í˜„ì¬ ë‚ ì´ ê½‰ ì°¼ìœ¼ë©´ ë‹¤ìŒ ë‚ ë¡œ
                        if (currentDayVisits.length > 0) {
                            console.log(`  âœ… ${currentDay}ì¼ì°¨ ì™„ë£Œ: ${currentDayVisits.length}ê°œ ë°©ë¬¸`);
                            schedule.push({
                                day: currentDay,
                                visits: currentDayVisits
                            });
                            currentDay++;
                            currentDayVisits = [];
                            currentPosition = start;
                        }
                        continue;
                    }
                    
                    // batchSizeë§Œí¼ ìµœì  ê²½ë¡œë¡œ ì¶”ê°€
                    let addedCount = 0;
                    while (addedCount < batchSize && remainingInCluster.length > 0) {
                        let nearestIndex = -1;
                        let minDuration = Infinity;
                        let nearestDistance = 0;
                        
                        // ì§„í–‰ ìƒí™© ì—…ë°ì´íŠ¸
                        const progress = Math.round((totalProcessed / totalLocations) * 100);
                        document.getElementById('optimizeProgressFill').style.width = progress + '%';
                        document.getElementById('optimizeProgressFill').textContent = progress + '%';
                        document.getElementById('optimizeDetail').textContent = 
                            `${totalProcessed}/${totalLocations}ê°œ ì™„ë£Œ | ${cluster.city} ë‚´ ${remainingInCluster.length}ê°œ ë‚¨ìŒ`;
                        
                        // ë‚¨ì€ êµ°ì§‘ ë‚´ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ê³³ ì°¾ê¸° (ì‹¤ì‹œê°„ ê²½ë¡œ ê¸°ë°˜)
                        for (let i = 0; i < remainingInCluster.length; i++) {
                            const loc = remainingInCluster[i];
                            const lat = parseFloat(loc[loc.length - 2]);
                            const lng = parseFloat(loc[loc.length - 1]);
                            
                            const routeInfo = await getRouteDuration(currentPosition.y, currentPosition.x, lat, lng);
                            
                            if (routeInfo && routeInfo.duration < minDuration) {
                                minDuration = routeInfo.duration;
                                nearestDistance = routeInfo.distance;
                                nearestIndex = i;
                            }
                            
                            await sleep(100);
                        }
                        
                        if (nearestIndex === -1) break;
                        
                        const nearest = remainingInCluster[nearestIndex];
                        const lat = parseFloat(nearest[nearest.length - 2]);
                        const lng = parseFloat(nearest[nearest.length - 1]);
                        
                        const estimatedTime = minDuration + avgStay;
                        const currentTotalTime = currentDayVisits.reduce((sum, v) => sum + parseFloat(v.time), 0);
                        const newTotalTime = currentTotalTime + estimatedTime;
                        
                        console.log(`    ğŸ• í˜„ì¬ ëˆ„ì : ${(currentTotalTime/60).toFixed(1)}ì‹œê°„, ì¶”ê°€ì‹œ: ${(newTotalTime/60).toFixed(1)}ì‹œê°„ (ì´ë™: ${minDuration}ë¶„, ì²´ë¥˜: ${avgStay}ë¶„)`);
                        
                        // ì‹œê°„ ì œí•œ í™•ì¸ - ì¶”ê°€í–ˆì„ ë•Œ ì´ˆê³¼í•˜ëŠ”ì§€ë§Œ ì²´í¬
                        if (newTotalTime > maxHours * 60 && currentDayVisits.length > 0) {
                            console.log(`  â° ì‹œê°„ ì´ˆê³¼ ì˜ˆìƒ (${(newTotalTime/60).toFixed(1)}ì‹œê°„ > ${maxHours}ì‹œê°„), ë‹¤ìŒ ë‚ ë¡œ ì´ë™`);
                            break;
                        }
                        
                        currentDayVisits.push({
                            address: nearest[selectedColumn] || nearest[0],
                            lat: lat,
                            lng: lng,
                            distance: nearestDistance.toFixed(2),
                            travelTime: minDuration.toFixed(0),
                            time: estimatedTime.toFixed(0),
                            data: nearest
                        });
                        
                        console.log(`    â• ${nearest[selectedColumn]?.substring(0, 30)} (${nearestDistance.toFixed(1)}km, ${minDuration}ë¶„)`);
                        
                        currentPosition = { x: lng, y: lat };
                        remainingInCluster.splice(nearestIndex, 1);
                        addedCount++;
                        totalProcessed++;
                        
                        // ìµœëŒ€ ë°©ë¬¸ìˆ˜ ë„ë‹¬í•˜ë©´ ë‚ ì§œ ì „í™˜
                        if (currentDayVisits.length >= maxVisits) {
                            const finalTotalTime = currentDayVisits.reduce((sum, v) => sum + parseFloat(v.time), 0);
                            console.log(`  âœ… ${currentDay}ì¼ì°¨ ì™„ë£Œ: ${currentDayVisits.length}ê°œ ë°©ë¬¸, ì´ ${(finalTotalTime/60).toFixed(1)}ì‹œê°„`);
                            schedule.push({
                                day: currentDay,
                                visits: currentDayVisits
                            });
                            currentDay++;
                            currentDayVisits = [];
                            currentPosition = start;
                            break;
                        }
                    }
                    
                    // êµ°ì§‘ ë‚´ ëª¨ë“  ì¥ì†Œë¥¼ ì²˜ë¦¬í–ˆê±°ë‚˜ ì‹œê°„ ì´ˆê³¼ë¡œ breakëœ ê²½ìš°
                    if (remainingInCluster.length === 0 || (addedCount === 0 && currentDayVisits.length > 0)) {
                        // í˜„ì¬ ë‚ ì§œ ì €ì¥í•˜ê³  ë‹¤ìŒìœ¼ë¡œ
                        if (currentDayVisits.length > 0 && remainingInCluster.length > 0) {
                            console.log(`  âœ… ${currentDay}ì¼ì°¨ ì™„ë£Œ: ${currentDayVisits.length}ê°œ ë°©ë¬¸`);
                            schedule.push({
                                day: currentDay,
                                visits: currentDayVisits
                            });
                            currentDay++;
                            currentDayVisits = [];
                            currentPosition = start;
                        }
                    }
                }
            }
            
            // ë§ˆì§€ë§‰ ë‚  ì¶”ê°€
            if (currentDayVisits.length > 0) {
                console.log(`  âœ… ${currentDay}ì¼ì°¨ ì™„ë£Œ: ${currentDayVisits.length}ê°œ ë°©ë¬¸`);
                schedule.push({
                    day: currentDay,
                    visits: currentDayVisits
                });
            }
            
            console.log(`\nğŸ‰ ì´ ${schedule.length}ì¼ ì¼ì • ìƒì„± ì™„ë£Œ!`);
            return schedule;
        }
        
        // ì‹œ/êµ°/êµ¬ë³„ë¡œ êµ°ì§‘í™” (ê°œì„  ë²„ì „)
        function clusterByCity(locations) {
            const clustersMap = {};
            
            locations.forEach(loc => {
                const address = loc[selectedColumn] || loc[0];
                let city = 'ê¸°íƒ€';
                
                // ì£¼ì†Œ ì •ê·œí™” (ê³µë°±, íŠ¹ìˆ˜ë¬¸ì ì œê±°)
                const normalized = address.replace(/\s+/g, ' ').trim();
                
                // ì„œìš¸íŠ¹ë³„ì‹œëŠ” êµ¬ ë‹¨ìœ„ë¡œ êµ°ì§‘í™”
                const seoulMatch = normalized.match(/ì„œìš¸íŠ¹ë³„ì‹œ\s*([ê°€-í£]+êµ¬)/);
                if (seoulMatch) {
                    city = `ì„œìš¸íŠ¹ë³„ì‹œ ${seoulMatch[1]}`;
                } else {
                    // ì¼ë°˜ì ì¸ ì‹œ/êµ°/êµ¬ ì¶”ì¶œ
                    const cityMatch = normalized.match(/(.*?[ì‹œêµ°êµ¬])/);
                    if (cityMatch) {
                        city = cityMatch[1];
                        // "ê²½ê¸° ê´‘ì£¼ì‹œ", "ê²½ê¸°ë„ ê´‘ì£¼ì‹œ" í†µì¼
                        city = city.replace(/^ê²½ê¸°ë„?\s*/, 'ê²½ê¸° ');
                        
                        // "ê²½ê¸° ì‹œ", "ê²½ê¸° êµ°" ê°™ì€ ë¶ˆì™„ì „í•œ ë§¤ì¹­ ë°©ì§€
                        if (city === 'ê²½ê¸° ì‹œ' || city === 'ê²½ê¸° êµ°' || city === 'ê²½ê¸° êµ¬') {
                            // ë” ìƒì„¸í•œ ì£¼ì†Œ ì¶”ì¶œ ì‹œë„
                            const detailedMatch = normalized.match(/ê²½ê¸°ë„?\s*([ê°€-í£]+[ì‹œêµ°])/);
                            if (detailedMatch) {
                                city = `ê²½ê¸° ${detailedMatch[1]}`;
                            } else {
                                city = 'ê¸°íƒ€';
                            }
                        }
                    }
                }
                
                if (!clustersMap[city]) {
                    clustersMap[city] = {
                        city: city,
                        locations: []
                    };
                }
                clustersMap[city].locations.push(loc);
            });
            
            console.log('ğŸ—‚ï¸ êµ°ì§‘í™” ê²°ê³¼:', Object.keys(clustersMap));
            return Object.values(clustersMap);
        }
        
        // ì¶œë°œì§€ì—ì„œ ê° êµ°ì§‘ê¹Œì§€ì˜ í‰ê·  ê±°ë¦¬ ê³„ì‚° í›„ ì •ë ¬ (ê°œì„  ë²„ì „)
        async function orderClustersByDistance(clusters, start) {
            const clusterDistances = [];
            
            for (const cluster of clusters) {
                // ê° êµ°ì§‘ì˜ ì¤‘ì‹¬ì  ê³„ì‚°
                const centerLat = cluster.locations.reduce((sum, loc) => 
                    sum + parseFloat(loc[loc.length - 2]), 0) / cluster.locations.length;
                const centerLng = cluster.locations.reduce((sum, loc) => 
                    sum + parseFloat(loc[loc.length - 1]), 0) / cluster.locations.length;
                
                const distance = calculateDistance(start.y, start.x, centerLat, centerLng);
                
                // êµ°ì§‘ ë‚´ë¶€ ì¥ì†Œë“¤ì˜ í‰ê·  ê±°ë¦¬ ê³„ì‚° (ë°€ì§‘ë„)
                let totalInternalDistance = 0;
                let count = 0;
                for (let i = 0; i < cluster.locations.length; i++) {
                    for (let j = i + 1; j < cluster.locations.length; j++) {
                        const loc1 = cluster.locations[i];
                        const loc2 = cluster.locations[j];
                        const lat1 = parseFloat(loc1[loc1.length - 2]);
                        const lng1 = parseFloat(loc1[loc1.length - 1]);
                        const lat2 = parseFloat(loc2[loc2.length - 2]);
                        const lng2 = parseFloat(loc2[loc2.length - 1]);
                        
                        totalInternalDistance += calculateDistance(lat1, lng1, lat2, lng2);
                        count++;
                    }
                }
                const avgInternalDistance = count > 0 ? totalInternalDistance / count : 0;
                
                clusterDistances.push({
                    ...cluster,
                    centerDistance: distance,
                    density: avgInternalDistance
                });
                
                console.log(`  ${cluster.city}: ì¶œë°œì§€ê¹Œì§€ ${distance.toFixed(1)}km, ë°€ì§‘ë„ ${avgInternalDistance.toFixed(1)}km`);
            }
            
            // ê±°ë¦¬ìˆœ ì •ë ¬ (ë°€ì§‘ë„ê°€ ë†’ì€ ê²ƒ ìš°ì„ , ê·¸ ë‹¤ìŒ ì¶œë°œì§€ ê±°ë¦¬)
            return clusterDistances.sort((a, b) => {
                // ì¶œë°œì§€ ê±°ë¦¬ ì°¨ì´ê°€ 20km ì´ë‚´ë©´ ë°€ì§‘ë„ ìš°ì„ 
                if (Math.abs(a.centerDistance - b.centerDistance) < 20) {
                    return a.density - b.density; // ë°€ì§‘ë„ê°€ ë‚®ì€ ê²ƒ(ë” ê°€ê¹Œìš´ ê²ƒ) ìš°ì„ 
                }
                return a.centerDistance - b.centerDistance;
            });
        }
        
        // ì¹´ì¹´ì˜¤ë§µ APIë¡œ ì‹¤ì œ ê²½ë¡œ ì‹œê°„ ê³„ì‚°
        function getRouteDuration(startLat, startLng, endLat, endLng) {
            return new Promise((resolve) => {
                // Directions APIëŠ” REST APIì´ë¯€ë¡œ fetch ì‚¬ìš©
                const url = `https://apis-navi.kakaomobility.com/v1/directions?origin=${startLng},${startLat}&destination=${endLng},${endLat}&priority=RECOMMEND`;
                
                fetch(url, {
                    headers: {
                        'Authorization': 'KakaoAK e7993bf34b2b04dcdeaf01bb36f06a85',
                        'Content-Type': 'application/json'
                    }
                })
                .then(response => response.json())
                .then(data => {
                    if (data.routes && data.routes.length > 0) {
                        const route = data.routes[0];
                        const duration = Math.round(route.summary.duration / 60); // ì´ˆ -> ë¶„
                        const distance = (route.summary.distance / 1000); // ë¯¸í„° -> km
                        resolve({ duration, distance });
                    } else {
                        // API ì‹¤íŒ¨ì‹œ ì§ì„ ê±°ë¦¬ë¡œ ëŒ€ì²´
                        const distance = calculateDistance(startLat, startLng, endLat, endLng);
                        const duration = (distance / 40) * 60; // ì‹œì† 40km ê°€ì •
                        resolve({ duration, distance });
                    }
                })
                .catch(error => {
                    console.error('ê²½ë¡œ API ì˜¤ë¥˜:', error);
                    // ì˜¤ë¥˜ì‹œ ì§ì„ ê±°ë¦¬ë¡œ ëŒ€ì²´
                    const distance = calculateDistance(startLat, startLng, endLat, endLng);
                    const duration = (distance / 40) * 60;
                    resolve({ duration, distance });
                });
            });
        }
        
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371;
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        function displaySchedule(schedule) {
            let html = '<div class="route-list">';
            
            schedule.forEach(day => {
                const totalDistance = day.visits.reduce((sum, v) => sum + parseFloat(v.distance), 0);
                const totalTime = day.visits.reduce((sum, v) => sum + parseFloat(v.time), 0);
                const color = dayColors[(day.day - 1) % dayColors.length];
                
                html += `
                    <div class="day-schedule" style="border-left: 5px solid ${color};">
                        <h3>ğŸ“ ${day.day}ì¼ì°¨ (${day.visits.length}ê°œ ë°©ë¬¸ | ${totalDistance.toFixed(1)}km | ${(totalTime/60).toFixed(1)}ì‹œê°„)</h3>
                `;
                
                day.visits.forEach((visit, index) => {
                    html += `
                        <div class="visit-item">
                            <div>
                                <strong>${index + 1}. ${visit.address}</strong><br>
                                <small>ê±°ë¦¬: ${visit.distance}km | ì´ë™: ${visit.travelTime}ë¶„ | ì²´ë¥˜: ${document.getElementById('avgStay').value}ë¶„</small>
                            </div>
                        </div>
                    `;
                });
                
                html += '</div>';
            });
            
            html += '</div>';
            document.getElementById('routeResult').innerHTML = html;
        }
        
        function displayLegend(schedule) {
            const legendSection = document.getElementById('legendSection');
            const legend = document.getElementById('legend');
            
            let html = '<strong style="margin-right: 15px;">ğŸ“ ì¼ì°¨ë³„ ìƒ‰ìƒ:</strong>';
            
            schedule.forEach(day => {
                const color = dayColors[(day.day - 1) % dayColors.length];
                html += `
                    <div class="legend-item">
                        <div class="legend-color" style="background: ${color};"></div>
                        <span>${day.day}ì¼ì°¨</span>
                    </div>
                `;
            });
            
            legend.innerHTML = html;
            legendSection.style.display = 'block';
        }
        
        function displayMarkersOnMap(schedule, start) {
            if (!map) return;
            
            // ê¸°ì¡´ ë§ˆì»¤ ë° ì„  ì œê±°
            markers.forEach(marker => {
                try {
                    if (marker.setMap) {
                        marker.setMap(null);
                    } else if (marker.overlay) {
                        marker.overlay.setMap(null);
                    }
                } catch (e) {
                    console.warn('ë§ˆì»¤ ì œê±° ì¤‘ ì˜¤ë¥˜:', e);
                }
            });
            markers = [];
            
            const bounds = new kakao.maps.LatLngBounds();
            
            // ì¶œë°œì§€ ë§ˆì»¤
            const startMarkerImage = new kakao.maps.MarkerImage(
                'https://t1.daumcdn.net/localimg/localimages/07/mapapidoc/markerStar.png',
                new kakao.maps.Size(24, 35)
            );
            
            const startMarker = new kakao.maps.Marker({
                position: new kakao.maps.LatLng(start.y, start.x),
                map: map,
                image: startMarkerImage
            });
            
            const startInfowindow = new kakao.maps.InfoWindow({
                content: '<div style="padding:5px;font-size:12px;font-weight:bold;">ğŸ  ì¶œë°œì§€</div>'
            });
            startInfowindow.open(map, startMarker);
            
            markers.push(startMarker);
            bounds.extend(new kakao.maps.LatLng(start.y, start.x));
            
            // ê° ë°©ë¬¸ì§€ ë§ˆì»¤ ë° ê²½ë¡œì„  (ë‚ ì§œë³„ ìƒ‰ìƒ)
            schedule.forEach((day, dayIndex) => {
                const color = dayColors[(day.day - 1) % dayColors.length];
                
                day.visits.forEach((visit, visitIndex) => {
                    const position = new kakao.maps.LatLng(visit.lat, visit.lng);
                    
                    // ë°©ë¬¸ì§€ ê°„ ê²½ë¡œì„ ë§Œ ê·¸ë¦¬ê¸° (ì¶œë°œì§€ ì—°ê²°ì„  ì œì™¸)
                    if (visitIndex > 0) {
                        const prevVisit = day.visits[visitIndex - 1];
                        const linePath = [
                            new kakao.maps.LatLng(prevVisit.lat, prevVisit.lng),
                            position
                        ];
                        
                        const polyline = new kakao.maps.Polyline({
                            path: linePath,
                            strokeWeight: 3,
                            strokeColor: color,
                            strokeOpacity: 0.7,
                            strokeStyle: 'solid'
                        });
                        polyline.setMap(map);
                        markers.push(polyline);
                    }
                    
                    // ì»¤ìŠ¤í…€ ë§ˆì»¤ ìƒì„±
                    const markerContent = document.createElement('div');
                    markerContent.style.cssText = `
                        width: 30px;
                        height: 30px;
                        background: ${color};
                        border: 3px solid white;
                        border-radius: 50%;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-weight: bold;
                        color: white;
                        font-size: 14px;
                        box-shadow: 0 2px 5px rgba(0,0,0,0.3);
                        cursor: pointer;
                    `;
                    markerContent.textContent = visitIndex + 1;
                    
                    const customOverlay = new kakao.maps.CustomOverlay({
                        position: position,
                        content: markerContent,
                        yAnchor: 1
                    });
                    
                    customOverlay.setMap(map);
                    
                    const infowindow = new kakao.maps.InfoWindow({
                        content: `<div style="padding:8px;font-size:12px;min-width:150px;">
                            <strong style="color:${color};">${day.day}ì¼ì°¨ - ${visitIndex + 1}ë²ˆì§¸</strong><br>
                            ${visit.address}<br>
                            <small>ğŸš— ${visit.travelTime}ë¶„ | ğŸ“ ${visit.distance}km</small>
                        </div>`
                    });
                    
                    markerContent.addEventListener('click', function() {
                        // ê¸°ì¡´ ì¸í¬ìœˆë„ìš° ë‹«ê¸°
                        markers.forEach(m => {
                            if (m.infowindow) {
                                m.infowindow.close();
                            }
                        });
                        infowindow.open(map, customOverlay);
                    });
                    
                    markers.push({ overlay: customOverlay, infowindow: infowindow });
                    bounds.extend(position);
                });
            });
            
            map.setBounds(bounds);
        }
    </script>
</body>
</html>
