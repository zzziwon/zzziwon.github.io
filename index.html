<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì¶œì¥ ê³„íš ìˆ˜ë¦½ ì—…ë¬´ ìë™í™” í”„ë¡¬í”„íŠ¸</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=0c62e9a12c740ee7f1620f92ec4659bf&libraries=services"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #e3f2fd 0%, #f0f9ff 50%, #f5fffa 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #a0e65f 0%, #5ec9ff 50%, #3fa8e0 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }
        
        /* ìë™ì°¨ ì•„ì´ì½˜ í˜¸ë²„ íš¨ê³¼ */
        .car-icon {
            display: inline-block;
            transition: transform 0.3s ease;
            cursor: pointer;
        }
        
        .car-icon:hover {
            transform: scale(1.3);
        }
        
        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .content {
            padding: 30px;
        }
        
        /* 1ë‹¨ê³„ì™€ 2ë‹¨ê³„ë¥¼ ì–‘ì˜†ì— ë°°ì¹˜ (1:1 ë¹„ìœ¨ë¡œ 2ë‹¨ê³„ ë„“í˜) */
        .steps-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin-bottom: 25px;
            align-items: start;
        }
        
        @media (max-width: 1024px) {
            .steps-container {
                grid-template-columns: 1fr;
            }
        }
        
        .section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            min-height: 620px;
        }
        
        .section h2 {
            color: #3fa8e0;
            margin-bottom: 15px;
            font-size: 1.3em;
            border-bottom: 3px solid #a0e65f;
            padding-bottom: 8px;
        }
        
        /* 1ë‹¨ê³„ ë‚´ë¶€ 1ë‹¨ ë°°ì¹˜ (ìœ„ì•„ë˜ë¡œ) */
        .step1-content {
            display: flex;
            flex-direction: column;
            gap: 15px;
            flex: 1;
        }
        
        .step1-left {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .step1-right {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .input-group {
            margin-bottom: 8px;
        }
        
        /* 2ë‹¨ê³„ ì „ìš© ê°„ê²© ì¡°ì • */
        .section .input-row {
            margin-bottom: 15px;
        }
        
        .section .input-row + .input-group {
            margin-bottom: 12px;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 4px;
            font-weight: 600;
            color: #333;
            font-size: 0.85em;
        }
        
        .input-group input, .input-group select {
            width: 100%;
            padding: 8px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 0.9em;
            transition: border-color 0.3s;
        }
        
        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #5ec9ff;
        }
        
        #customAddressInput {
            margin-top: 5px;
            background-color: #f5f5f5;
            cursor: not-allowed;
        }
        
        #customAddressInput:enabled {
            background-color: white;
            cursor: text;
        }
        
        #previewSection {
            min-height: 120px;
        }
        
        #previewSection .input-group {
            margin-bottom: 10px;
        }
        
        .input-row {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        button {
            background: linear-gradient(135deg, #3fa8e0 0%, #5ec9ff 50%, #a0e65f 100%);
            color: white;
            border: none;
            padding: 8px 20px;
            border-radius: 8px;
            font-size: 0.9em;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(63, 168, 224, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            background: #999;
            cursor: not-allowed;
            transform: none;
        }
        
        .file-upload {
            border: 3px dashed #a0e65f;
            border-radius: 12px;
            padding: 18px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        .file-upload:hover {
            background: #f0fff4;
            border-color: #5ec9ff;
        }
        
        .file-upload.drag-over {
            background: #e6f7ff;
            border-color: #3fa8e0;
            border-style: solid;
            transform: scale(1.02);
        }
        
        .file-upload input[type="file"] {
            display: none;
        }
        
        .file-upload-icon {
            font-size: 2.5em;
            margin-bottom: 8px;
            transition: transform 0.3s;
        }
        
        .file-upload:hover .file-upload-icon {
            transform: scale(1.1);
        }
        
        .file-upload p {
            font-size: 0.9em;
            margin-bottom: 5px;
        }
        
        .file-upload p:first-of-type {
            font-weight: 600;
        }
        
        /* ìƒíƒœ í‘œì‹œ ì˜ì—­ */
        .status {
            padding: 12px;
            border-radius: 8px;
            font-weight: 500;
            font-size: 0.9em;
            margin-bottom: 12px;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        .status.empty {
            background: #f8f9fa;
            color: #999;
            border: 1px solid #e0e0e0;
        }
        
        .conversion-stats {
            display: flex;
            gap: 10px;
            margin-bottom: 12px;
        }
        
        .stat-box {
            flex: 1;
            min-width: 80px;
            padding: 12px 10px;
            border-radius: 10px;
            text-align: center;
        }
        
        .stat-box.success {
            background: #d1fae5;
            border: 2px solid #a0e65f;
        }
        
        .stat-box.fail {
            background: #fee2e2;
            border: 2px solid #ef4444;
        }
        
        .stat-box.total {
            background: #dbeafe;
            border: 2px solid #5ec9ff;
        }
        
        .stat-number {
            font-size: 1.6em;
            font-weight: bold;
            margin: 5px 0;
        }
        
        .stat-label {
            font-size: 0.85em;
            color: #666;
        }
        
        #currentAddress {
            padding: 12px;
            background: #d1fae5;
            border-radius: 8px;
            margin-bottom: 12px;
            border-left: 4px solid #a0e65f;
            font-size: 0.9em;
            min-height: 55px;
            display: flex;
            align-items: center;
        }
        
        #currentAddress.empty {
            background: #f8f9fa;
            border-left-color: #e0e0e0;
            color: #999;
        }
        
        #optimizeStatus {
            padding: 12px;
            background: #d1fae5;
            border-radius: 8px;
            margin-top: 12px;
            margin-bottom: 12px;
            border-left: 4px solid #a0e65f;
            font-size: 0.9em;
            min-height: 55px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        #optimizeStatus.empty {
            background: #f8f9fa;
            border-left-color: #e0e0e0;
            color: #999;
            align-items: center;
            justify-content: center;
        }
        
        #optimizeStatus.processing {
            background: #e3f2fd;
            border-left-color: #5ec9ff;
            color: #0c5460;
            align-items: flex-start;
        }
        
        #optimizeStatus.success {
            background: #d4edda;
            color: #155724;
            border-left-color: #c3e6cb;
            align-items: center;
            justify-content: center;
        }
        
        #optimizeStatus.error {
            background: #f8d7da;
            color: #721c24;
            border-left-color: #f5c6cb;
            align-items: center;
            justify-content: center;
        }
        
        #optimizeStatus.info {
            background: #d1ecf1;
            color: #0c5460;
            border-left-color: #bee5eb;
            align-items: center;
            justify-content: center;
        }
        
        .optimize-main {
            font-weight: bold;
            font-size: 0.95em;
        }
        
        .optimize-detail {
            font-size: 0.85em;
            color: #666;
        }
        
        .progress-bar {
            width: 100%;
            height: 28px;
            background: #e0e0e0;
            border-radius: 15px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3fa8e0 0%, #5ec9ff 50%, #a0e65f 100%);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 0.9em;
            width: 0%;
        }
        
        #map {
            width: 100%;
            height: 600px;
            border-radius: 12px;
            margin-top: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .route-list {
            margin-top: 20px;
        }
        
        .day-schedule {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 3px 15px rgba(0,0,0,0.08);
        }
        
        .day-schedule h3 {
            color: #3fa8e0;
            margin-bottom: 20px;
            font-size: 1.4em;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .day-stats {
            display: flex;
            gap: 15px;
            margin-bottom: 25px;
            flex-wrap: wrap;
        }
        
        .stat-card {
            flex: 1;
            min-width: 120px;
            padding: 12px;
            border-radius: 10px;
            text-align: center;
            background: linear-gradient(135deg, #f5f5f5 0%, #eeeeee 100%);
            border: 2px solid #e0e0e0;
        }
        
        .stat-card .label {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 5px;
        }
        
        .stat-card .value {
            font-size: 1.3em;
            font-weight: bold;
            color: #424242;
        }
        
        .timeline {
            position: relative;
            padding-left: 0;
        }
        
        .timeline-item {
            position: relative;
            margin-bottom: 12px;
            animation: fadeInUp 0.5s ease forwards;
            opacity: 0;
        }
        
        @keyframes fadeInUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
            from {
                opacity: 0;
                transform: translateY(20px);
            }
        }
        
        .timeline-item:nth-child(1) { animation-delay: 0.1s; }
        .timeline-item:nth-child(2) { animation-delay: 0.15s; }
        .timeline-item:nth-child(3) { animation-delay: 0.2s; }
        .timeline-item:nth-child(4) { animation-delay: 0.25s; }
        .timeline-item:nth-child(5) { animation-delay: 0.3s; }
        .timeline-item:nth-child(6) { animation-delay: 0.35s; }
        .timeline-item:nth-child(7) { animation-delay: 0.4s; }
        .timeline-item:nth-child(8) { animation-delay: 0.45s; }
        
        .timeline-icon {
            position: absolute;
            left: 0;
            top: 0;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 2;
        }
        
        .timeline-icon.start {
            background: linear-gradient(135deg, #a0e65f 0%, #7dd64f 100%);
        }
        
        .timeline-icon.visit {
            background: linear-gradient(135deg, #5ec9ff 0%, #3fa8e0 100%);
            color: white;
            font-weight: bold;
            font-size: 0.9em;
        }
        
        .timeline-icon.end {
            background: linear-gradient(135deg, #9e9e9e 0%, #757575 100%);
        }
        
        .timeline-content {
            background: white;
            padding: 12px 15px;
            margin-left: 50px;
            border-radius: 12px;
            border-left: 4px solid #5ec9ff;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            transition: transform 0.2s, box-shadow 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
        }
        
        .timeline-content:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.12);
        }
        
        .timeline-content.start-point {
            border-left-color: #a0e65f;
            background: linear-gradient(90deg, #f0fff4 0%, white 100%);
        }
        
        .timeline-content.end-point {
            border-left-color: #9e9e9e;
            background: linear-gradient(90deg, #f5f5f5 0%, white 100%);
        }
        
        .timeline-info {
            flex: 1;
            min-width: 0;
        }
        
        .timeline-title {
            font-weight: 600;
            font-size: 0.95em;
            color: #1e293b;
            margin-bottom: 5px;
            line-height: 1.4;
        }
        
        .timeline-company {
            font-weight: 700;
            font-size: 0.95em;
            color: #0f172a;
            margin-bottom: 5px;
        }
        
        .timeline-meta {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            font-size: 0.85em;
            color: #64748b;
        }
        
        .timeline-meta span {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .travel-info {
            display: flex;
            gap: 12px;
            font-size: 1em;
            color: #000;
            white-space: nowrap;
            padding: 6px 12px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }
        
        .travel-info span {
            display: flex;
            align-items: center;
            gap: 4px;
            font-weight: 600;
        }
        
        .button-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .footer {
            background: #6c757d;
            color: white;
            text-align: center;
            padding: 20px;
            font-size: 0.9em;
        }
        
        .footer a {
            color: #5ec9ff;
            text-decoration: none;
        }
        
        .footer a:hover {
            text-decoration: underline;
        }
        
        #optimizeProgress {
            padding: 10px;
            background: #e3f2fd;
            border-radius: 8px;
            margin-top: 8px;
            margin-bottom: 12px;
            border-left: 4px solid #5ec9ff;
            min-height: 70px;
            visibility: hidden;
        }
        
        #optimizeProgress.active {
            visibility: visible;
        }
        
        #optimizeCurrentCity {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        
        #optimizeDetail {
            margin-top: 5px;
            font-size: 0.85em;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>
                <span class="car-icon">ğŸš—</span>
                ë”°ë¼ì™€ ìŠ¤ë§ˆíŠ¸ ì¶œì¥ ê²½ë¡œ ìµœì í™”
            </h1>
            <p>ì—‘ì…€íŒŒì¼ì„ ì—…ë¡œë“œí•˜ì—¬ íš¨ìœ¨ì ì¸ ì¶œì¥ê²½ë¡œë¥¼ ìë™ìœ¼ë¡œ ìƒì„±í•˜ì„¸ìš”</p>
        </div>
        
        <div class="content">
            <!-- 1ë‹¨ê³„ì™€ 2ë‹¨ê³„ë¥¼ ì–‘ì˜†ì— ë°°ì¹˜ -->
            <div class="steps-container">
                <!-- 1ë‹¨ê³„ -->
                <div class="section">
                    <h2>ğŸ“ 1ë‹¨ê³„: ì§€ë¦¬ì  ì¢Œí‘œ ë³€í™˜ (GCT)</h2>
                    
                    <div class="step1-content">
                        <!-- ìœ„: íŒŒì¼ ì—…ë¡œë“œ ë° ì—´ ì„ íƒ -->
                        <div class="step1-left">
                            <div class="file-upload" id="fileUploadArea">
                                <div class="file-upload-icon">ğŸ“¤</div>
                                <p>íŒŒì¼ ì—…ë¡œë“œ</p>
                                <p style="color: #666; font-size: 0.85em;">í´ë¦­ ë˜ëŠ” ë“œë˜ê·¸</p>
                                <input type="file" id="excelFile" accept=".xlsx,.xls">
                            </div>
                            
                            <div id="uploadStatus" class="status empty">ğŸ“‚ ì—‘ì…€ íŒŒì¼ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”</div>
                            
                            <div id="previewSection">
                                <div class="input-group">
                                    <label>ì£¼ì†Œ ì—´ ì„ íƒ</label>
                                    <select id="addressColumn">
                                        <option value="">-- ì£¼ì†Œ ì—´ ì„ íƒ --</option>
                                    </select>
                                </div>
                                <div class="input-group">
                                    <label>ì—…ì²´ëª… ì—´ (ì„ íƒì‚¬í•­)</label>
                                    <select id="companyColumn">
                                        <option value="">-- ì—…ì²´ëª… ì—´ ì„ íƒ --</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                        
                        <!-- ì•„ë˜: ë²„íŠ¼ ë° ë³€í™˜ ìƒíƒœ -->
                        <div class="step1-right">
                            <div class="button-group">
                                <button id="convertBtn" onclick="convertAddresses()" disabled>ğŸ”„ ë³€í™˜ ì‹œì‘</button>
                                <button id="downloadBtn" onclick="downloadExcel()" disabled>ğŸ’¾ ë‹¤ìš´ë¡œë“œ</button>
                            </div>
                            
                            <div class="conversion-stats">
                                <div class="stat-box total">
                                    <div class="stat-label">ì „ì²´</div>
                                    <div class="stat-number" id="totalCount">0</div>
                                </div>
                                <div class="stat-box success">
                                    <div class="stat-label">âœ… ì„±ê³µ</div>
                                    <div class="stat-number" id="successCount">0</div>
                                </div>
                                <div class="stat-box fail">
                                    <div class="stat-label">âŒ ì‹¤íŒ¨</div>
                                    <div class="stat-number" id="failCount">0</div>
                                </div>
                            </div>
                            
                            <div id="currentAddress" class="empty">ë³€í™˜ ëŒ€ê¸° ì¤‘</div>
                            
                            <div class="progress-bar">
                                <div class="progress-fill" id="progressFill">0%</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 2ë‹¨ê³„ -->
                <div class="section">
                    <h2>ğŸ“… 2ë‹¨ê³„: ë°©ë¬¸ ì¼ì • ì„¤ì •</h2>
                    <div class="input-row">
                        <div class="input-group">
                            <label>ì¼ì¼ ìµœëŒ€ ì—…ë¬´ì‹œê°„ (ì‹œê°„)</label>
                            <input type="number" id="maxHours" value="8" min="1" max="24">
                        </div>
                        <div class="input-group">
                            <label>í‰ê·  ì²´ë¥˜ì‹œê°„ (ë¶„)</label>
                            <input type="number" id="avgStay" value="30" min="5" max="180">
                        </div>
                        <div class="input-group">
                            <label>ì¼ì¼ ë°©ë¬¸ ì—…ì²´ìˆ˜ (ê°œ)</label>
                            <input type="number" id="maxVisits" value="5" min="1" max="20">
                        </div>
                    </div>
                    <div class="input-group">
                        <label>ì¶œë°œì§€ ì„ íƒ</label>
                        <select id="startLocation" onchange="toggleCustomAddress()">
                            <option value="ì¸ì²œ ì„œêµ¬ í™˜ê²½ë¡œ 42" data-name="ë³¸ì‚¬">ë³¸ì‚¬</option>
                            <option value="ê²½ê¸°ë„ ì„±ë‚¨ì‹œ ë¶„ë‹¹êµ¬ ì¥ë¯¸ë¡œ 42" data-name="ìˆ˜ë„ê¶Œë™ë¶€í™˜ê²½ë³¸ë¶€" selected>ìˆ˜ë„ê¶Œë™ë¶€í™˜ê²½ë³¸ë¶€</option>
                            <option value="ì„œìš¸ ê°•ì„œêµ¬ í™”ê³¡ë¡œ68ê¸¸ 82" data-name="ìˆ˜ë„ê¶Œì„œë¶€í™˜ê²½ë³¸ë¶€">ìˆ˜ë„ê¶Œì„œë¶€í™˜ê²½ë³¸ë¶€</option>
                            <option value="ë¶€ì‚° ë¶êµ¬ ë‚™ë™ë¶ë¡œ 681ë²ˆê¸¸ 34" data-name="ë¶€ì‚°ìš¸ì‚°ê²½ë‚¨í™˜ê²½ë³¸ë¶€">ë¶€ì‚°ìš¸ì‚°ê²½ë‚¨í™˜ê²½ë³¸ë¶€</option>
                            <option value="ëŒ€êµ¬ ìˆ˜ì„±êµ¬ ë¬´í•™ë¡œ 209" data-name="ëŒ€êµ¬ê²½ë¶í™˜ê²½ë³¸ë¶€">ëŒ€êµ¬ê²½ë¶í™˜ê²½ë³¸ë¶€</option>
                            <option value="ëŒ€ì „ ì„œêµ¬ ì²­ì‚¬ë¡œ 156" data-name="ì¶©ì²­ê¶Œí™˜ê²½ë³¸ë¶€">ì¶©ì²­ê¶Œí™˜ê²½ë³¸ë¶€</option>
                            <option value="ê´‘ì£¼ ê´‘ì‚°êµ¬ ë¬´ì§„ëŒ€ë¡œ 217" data-name="ê´‘ì£¼ì „ë‚¨ì œì£¼í™˜ê²½ë³¸ë¶€">ê´‘ì£¼ì „ë‚¨ì œì£¼í™˜ê²½ë³¸ë¶€</option>
                            <option value="ê°•ì› ì¶˜ì²œì‹œ ê²½ì¶˜ë¡œ 2370" data-name="ê°•ì›í™˜ê²½ë³¸ë¶€">ê°•ì›í™˜ê²½ë³¸ë¶€</option>
                            <option value="ì „ë¶ ì „ì£¼ì‹œ ì™„ì‚°êµ¬ ì„œê³¡ë¡œ 100" data-name="ì „ë¶í™˜ê²½ë³¸ë¶€">ì „ë¶í™˜ê²½ë³¸ë¶€</option>
                            <option value="custom">ê¸°íƒ€(ì§ì ‘ ì…ë ¥)</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label>ì¶œë°œì§€ ì£¼ì†Œ (ì§ì ‘ ì…ë ¥)</label>
                        <input type="text" id="customAddressInput" placeholder="ì¶œë°œì§€ ì£¼ì†Œë¥¼ ì…ë ¥í•˜ì„¸ìš”" disabled>
                    </div>
                    <div class="button-group" style="margin-top: 15px; margin-bottom: 15px;">
                        <button id="optimizeBtn" onclick="optimizeRoute()" disabled>ğŸ¯ ê²½ë¡œ ìµœì í™” ì‹¤í–‰</button>
                    </div>
                    <div id="optimizeStatus" class="empty">ì‹¤í–‰ ëŒ€ê¸° ì¤‘</div>
                    
                    <div class="progress-bar">
                        <div class="progress-fill" id="optimizeProgressFill">0%</div>
                    </div>
                </div>
            </div>
            
            <!-- 3ë‹¨ê³„ -->
            <div class="section">
                <h2>ğŸ—ºï¸ 3ë‹¨ê³„: ìµœì í™”ëœ ê²½ë¡œ</h2>
                <div id="routeResult"></div>
                <div id="scheduleButtons" style="display: none; margin: 20px 0;">
                    <button onclick="downloadScheduleExcel()">ğŸ“¥ ì¼ì • íŒŒì¼ ë‹¤ìš´ë¡œë“œ</button>
                </div>
                <div id="map"></div>
            </div>
        </div>
        
        <div class="footer">
            <p>Â© 2025 ë”°ë¼ì™€. All rights reserved.</p>
            <p>Developed by <strong>BTS</strong> (Business Trip Secretary)</p>
        </div>
    </div>

    <script>
        let uploadedData = [];
        let convertedData = [];
        let map = null;
        let markers = [];
        let geocoder = null;
        let startPoint = null;
        let selectedColumn = 0;
        let companyColumn = -1;
        let finalSchedule = null;
        let startLocationName = '';
        let optimizeStartTime = 0;
        
        // ğŸš€ ê²½ë¡œ ìºì‹œ ì¶”ê°€ (ì†ë„ ê°œì„ )
        const routeCache = new Map();
        
        const dayColors = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8',
            '#F06292', '#BA68C8', '#9575CD', '#7986CB', '#64B5F6',
            '#4FC3F7', '#4DD0E1', '#4DB6AC', '#81C784', '#AED581'
        ];
        
        window.onload = function() {
            if (typeof kakao === 'undefined') {
                showStatus('uploadStatus', 'âŒ ì¹´ì¹´ì˜¤ SDK ë¡œë“œ ì‹¤íŒ¨', 'error');
                return;
            }
            
            kakao.maps.load(function() {
                geocoder = new kakao.maps.services.Geocoder();
                initMap();
                showStatus('uploadStatus', 'ğŸ“‚ ì—‘ì…€ íŒŒì¼ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”.', 'info');
            });
            
            // ë“œë˜ê·¸ì•¤ë“œë¡­ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
            setupDragAndDrop();
            
            // ì´ˆê¸° ì¶œë°œì§€ ì´ë¦„ ì„¤ì •
            const select = document.getElementById('startLocation');
            const selectedOption = select.options[select.selectedIndex];
            startLocationName = selectedOption.getAttribute('data-name') || 'ì¶œë°œì§€';
        };
        
        function toggleCustomAddress() {
            const select = document.getElementById('startLocation');
            const customInput = document.getElementById('customAddressInput');
            
            if (select.value === 'custom') {
                customInput.disabled = false;
                customInput.focus();
                startLocationName = 'ì¶œë°œì§€';
            } else {
                customInput.disabled = true;
                customInput.value = '';
                const selectedOption = select.options[select.selectedIndex];
                startLocationName = selectedOption.getAttribute('data-name') || 'ì¶œë°œì§€';
            }
        }
        
        function getStartAddress() {
            const select = document.getElementById('startLocation');
            const customInput = document.getElementById('customAddressInput');
            
            if (select.value === 'custom') {
                startLocationName = customInput.value.trim() || 'ì¶œë°œì§€';
                return customInput.value.trim();
            } else {
                const selectedOption = select.options[select.selectedIndex];
                startLocationName = selectedOption.getAttribute('data-name') || 'ì¶œë°œì§€';
                return select.value.trim();
            }
        }
        
        function setupDragAndDrop() {
            const uploadArea = document.getElementById('fileUploadArea');
            const fileInput = document.getElementById('excelFile');
            
            // í´ë¦­ ì´ë²¤íŠ¸
            uploadArea.addEventListener('click', function(e) {
                if (e.target.tagName !== 'INPUT') {
                    fileInput.click();
                }
            });
            
            // ë“œë˜ê·¸ ì˜¤ë²„
            uploadArea.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.add('drag-over');
            });
            
            // ë“œë˜ê·¸ ë‚˜ê°€ê¸°
            uploadArea.addEventListener('dragleave', function(e) {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.remove('drag-over');
            });
            
            // ë“œë¡­
            uploadArea.addEventListener('drop', function(e) {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.remove('drag-over');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    if (file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {
                        handleFile(file);
                    } else {
                        showStatus('uploadStatus', 'âŒ ì—‘ì…€ íŒŒì¼(.xlsx, .xls)ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤.', 'error');
                    }
                }
            });
            
            // íŒŒì¼ input ë³€ê²½
            fileInput.addEventListener('change', function(e) {
                if (e.target.files.length > 0) {
                    handleFile(e.target.files[0]);
                }
            });
        }
        
        function handleFile(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    
                    // ì—¬ëŸ¬ ì˜µì…˜ìœ¼ë¡œ ì‹œë„
                    let workbook = null;
                    let jsonData = null;
                    
                    // ì‹œë„ 1: ê¸°ë³¸ ì½ê¸°
                    try {
                        workbook = XLSX.read(data, {type: 'array'});
                        const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                        jsonData = XLSX.utils.sheet_to_json(firstSheet, {header: 1, defval: '', raw: false});
                    } catch (e1) {
                        console.log('ê¸°ë³¸ ì½ê¸° ì‹¤íŒ¨, ë‹¤ë¥¸ ë°©ë²• ì‹œë„...');
                        
                        // ì‹œë„ 2: cellDates ì˜µì…˜ ì‚¬ìš©
                        try {
                            workbook = XLSX.read(data, {type: 'array', cellDates: true, cellNF: false, cellText: false});
                            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                            jsonData = XLSX.utils.sheet_to_json(firstSheet, {header: 1, defval: '', raw: false});
                        } catch (e2) {
                            console.log('cellDates ì˜µì…˜ ì‹¤íŒ¨, ì„¸ ë²ˆì§¸ ë°©ë²• ì‹œë„...');
                            
                            // ì‹œë„ 3: binary íƒ€ì…ìœ¼ë¡œ ì½ê¸°
                            try {
                                const binary = new TextDecoder('latin1').decode(data);
                                workbook = XLSX.read(binary, {type: 'binary'});
                                const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                                jsonData = XLSX.utils.sheet_to_json(firstSheet, {header: 1, defval: '', raw: false});
                            } catch (e3) {
                                throw new Error('íŒŒì¼ì„ ì½ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. íŒŒì¼ì´ ì†ìƒë˜ì—ˆê±°ë‚˜ ì§€ì›ë˜ì§€ ì•ŠëŠ” í˜•ì‹ì…ë‹ˆë‹¤.');
                            }
                        }
                    }
                    
                    if (!jsonData || jsonData.length === 0) {
                        throw new Error('íŒŒì¼ì— ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
                    }
                    
                    // ë¹ˆ í–‰ í•„í„°ë§
                    uploadedData = jsonData.filter(row => {
                        if (!row || row.length === 0) return false;
                        // ëª¨ë“  ì…€ì´ ë¹ˆ ê°’ì¸ì§€ í™•ì¸
                        return row.some(cell => cell !== null && cell !== undefined && cell !== '');
                    });
                    
                    if (uploadedData.length === 0) {
                        throw new Error('ìœ íš¨í•œ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
                    }
                    
                    showStatus('uploadStatus', `âœ… ${uploadedData.length}ê°œ í–‰ ì—…ë¡œë“œ ì™„ë£Œ`, 'success');
                    showColumnSelector();
                    
                } catch (error) {
                    console.error('íŒŒì¼ ì½ê¸° ì˜¤ë¥˜:', error);
                    showStatus('uploadStatus', `âŒ íŒŒì¼ ì½ê¸° ì‹¤íŒ¨: ${error.message}`, 'error');
                    uploadedData = [];
                }
            };
            
            reader.onerror = function() {
                showStatus('uploadStatus', 'âŒ íŒŒì¼ì„ ì½ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', 'error');
            };
            
            reader.readAsArrayBuffer(file);
        }
        
        function initMap() {
            const container = document.getElementById('map');
            const options = {
                center: new kakao.maps.LatLng(37.5665, 126.9780),
                level: 8
            };
            map = new kakao.maps.Map(container, options);
        }
        
        function showStatus(elementId, message, type) {
            const element = document.getElementById(elementId);
            if (elementId === 'optimizeStatus') {
                // optimizeStatusëŠ” currentAddressì™€ ë™ì¼í•œ ë°©ì‹
                element.className = type;
                element.textContent = message;
            } else {
                // uploadStatusëŠ” ê¸°ì¡´ ë°©ì‹
                element.className = 'status ' + type;
                element.textContent = message;
            }
        }
        
        function showColumnSelector() {
            const addressColumnSelect = document.getElementById('addressColumn');
            const companyColumnSelect = document.getElementById('companyColumn');
            
            addressColumnSelect.innerHTML = '<option value="">-- ì£¼ì†Œ ì—´ ì„ íƒ --</option>';
            companyColumnSelect.innerHTML = '<option value="">-- ì—…ì²´ëª… ì—´ ì„ íƒ --</option>';
            
            if (uploadedData.length > 0) {
                const headerRow = uploadedData[0];
                headerRow.forEach((header, i) => {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = `${header} (ì—´ ${i + 1})`;
                    addressColumnSelect.appendChild(option);
                    
                    const option2 = document.createElement('option');
                    option2.value = i;
                    option2.textContent = `${header} (ì—´ ${i + 1})`;
                    companyColumnSelect.appendChild(option2);
                });
            }
            
            addressColumnSelect.onchange = function() {
                selectedColumn = parseInt(this.value);
                if (!isNaN(selectedColumn)) {
                    document.getElementById('convertBtn').disabled = false;
                }
            };
            
            companyColumnSelect.onchange = function() {
                const val = parseInt(this.value);
                companyColumn = isNaN(val) ? -1 : val;
            };
        }
        
        async function convertAddresses() {
            if (uploadedData.length <= 1 || isNaN(selectedColumn)) return;
            
            document.getElementById('convertBtn').disabled = true;
            showStatus('uploadStatus', 'ğŸ”„ ë³€í™˜ ì¤‘...', 'info');
            
            // currentAddress ì´ˆê¸°í™”
            const currentAddressEl = document.getElementById('currentAddress');
            currentAddressEl.className = '';
            
            convertedData = [];
            let successCount = 0, failCount = 0;
            
            const headerRow = [...uploadedData[0], 'ìœ„ë„', 'ê²½ë„'];
            convertedData.push(headerRow);
            
            const dataRows = uploadedData.slice(1);
            document.getElementById('totalCount').textContent = dataRows.length;
            
            console.log(`\nğŸš€ === ì£¼ì†Œ ë³€í™˜ ì‹œì‘ (${dataRows.length}ê°œ) ===`);
            const startTime = Date.now();
            
            // ğŸš€ ë°°ì¹˜ í¬ê¸° ì„¤ì • (í•œ ë²ˆì— ì²˜ë¦¬í•  ê°œìˆ˜)
            const BATCH_SIZE = 3;
            const BATCH_DELAY = 100; // ë°°ì¹˜ ê°„ ë”œë ˆì´ (ms)
            
            for (let batchStart = 0; batchStart < dataRows.length; batchStart += BATCH_SIZE) {
                const batchEnd = Math.min(batchStart + BATCH_SIZE, dataRows.length);
                const batch = dataRows.slice(batchStart, batchEnd);
                
                // ğŸš€ ë°°ì¹˜ ë‚´ì—ì„œ ë³‘ë ¬ ì²˜ë¦¬
                const batchPromises = batch.map(async (row, batchIndex) => {
                    const i = batchStart + batchIndex;
                    const address = row[selectedColumn];
                    
                    currentAddressEl.innerHTML = 
                        `ğŸ”„ (${i + 1}/${dataRows.length}): <strong>${address || 'ë¹ˆ ê°’'}</strong>`;
                    
                    if (!address) {
                        return { row, result: null };
                    }
                    
                    const result = await geocodeAddress(address);
                    return { row, result };
                });
                
                // ë°°ì¹˜ ì™„ë£Œ ëŒ€ê¸°
                const batchResults = await Promise.all(batchPromises);
                
                // ê²°ê³¼ ì €ì¥
                batchResults.forEach(({ row, result }) => {
                    if (!row[selectedColumn]) {
                        convertedData.push([...row, '', '']);
                        failCount++;
                    } else if (result) {
                        convertedData.push([...row, result.y, result.x]);
                        successCount++;
                    } else {
                        convertedData.push([...row, 'ë³€í™˜ ì‹¤íŒ¨', 'ë³€í™˜ ì‹¤íŒ¨']);
                        failCount++;
                    }
                });
                
                // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
                document.getElementById('successCount').textContent = successCount;
                document.getElementById('failCount').textContent = failCount;
                
                const progress = Math.round(((batchEnd) / dataRows.length) * 100);
                document.getElementById('progressFill').style.width = progress + '%';
                document.getElementById('progressFill').textContent = progress + '%';
                
                // ë°°ì¹˜ ê°„ ë”œë ˆì´ (API ì œí•œ ë°©ì§€)
                if (batchEnd < dataRows.length) {
                    await sleep(BATCH_DELAY);
                }
            }
            
            const endTime = Date.now();
            const totalSeconds = ((endTime - startTime) / 1000).toFixed(1);
            
            console.log(`âœ… ë³€í™˜ ì™„ë£Œ: ${totalSeconds}ì´ˆ ì†Œìš”`);
            console.log(`   ì„±ê³µ: ${successCount}ê°œ, ì‹¤íŒ¨: ${failCount}ê°œ`);
            console.log(`   í‰ê· : ${(totalSeconds / dataRows.length).toFixed(2)}ì´ˆ/ê°œ`);
            
            showStatus('uploadStatus', `âœ… ì™„ë£Œ! ${successCount}/${dataRows.length}ê°œ ì„±ê³µ`, 'success');
            currentAddressEl.innerHTML = `âœ… ë³€í™˜ ì™„ë£Œ (${totalSeconds}ì´ˆ)`;
            
            document.getElementById('downloadBtn').disabled = false;
            document.getElementById('optimizeBtn').disabled = false;
            document.getElementById('convertBtn').disabled = false;
        }
        
        function geocodeAddress(address) {
            return new Promise((resolve) => {
                if (!geocoder || !address || typeof address !== 'string') {
                    resolve(null);
                    return;
                }
                
                const originalAddress = address.trim();
                console.log(`\nğŸ” ì›ë³¸ ì£¼ì†Œ: "${originalAddress}"`);
                
                const cleaningSteps = [
                    (addr) => addr,
                    (addr) => addr.replace(/\([^)]*\)/g, '').trim(),
                    (addr) => addr.replace(/\([^)]*\)/g, '').replace(/[\.Â·,]+$/g, '').trim(),
                    (addr) => {
                        const cleaned = addr.replace(/\([^)]*\)/g, '').replace(/[\.Â·,]+$/g, '').trim();
                        const parts = cleaned.split(' ');
                        if (parts.length > 3) {
                            return parts.slice(0, -1).join(' ');
                        }
                        return cleaned;
                    },
                    (addr) => {
                        const cleaned = addr.replace(/\([^)]*\)/g, '').replace(/[\.Â·,]+$/g, '').trim();
                        const parts = cleaned.split(' ');
                        if (parts.length > 4) {
                            return parts.slice(0, -2).join(' ');
                        }
                        return null;
                    },
                    (addr) => {
                        const cleaned = addr.replace(/\([^)]*\)/g, '').trim();
                        const match = cleaned.match(/(.*?[ì‹œêµ°êµ¬].*?[ìë©´ë™ë¦¬])\s+[\d-]+/);
                        if (match) {
                            return match[0];
                        }
                        return null;
                    }
                ];
                
                attemptGeocodeSequentially(originalAddress, cleaningSteps, 0, resolve);
            });
        }
        
        function attemptGeocodeSequentially(originalAddress, cleaningSteps, stepIndex, finalResolve) {
            if (stepIndex >= cleaningSteps.length) {
                console.log('  âŒ ëª¨ë“  ì‹œë„ ì‹¤íŒ¨');
                finalResolve(null);
                return;
            }
            
            const cleanedAddress = cleaningSteps[stepIndex](originalAddress);
            
            if (!cleanedAddress || cleanedAddress === '') {
                attemptGeocodeSequentially(originalAddress, cleaningSteps, stepIndex + 1, finalResolve);
                return;
            }
            
            if (stepIndex > 0) {
                console.log(`  ì‹œë„ ${stepIndex + 1}: "${cleanedAddress}"`);
            }
            
            geocoder.addressSearch(cleanedAddress, function(result, status) {
                if (status === kakao.maps.services.Status.OK && result && result.length > 0) {
                    console.log(`  âœ… ì„±ê³µ! (ì‹œë„ ${stepIndex + 1}) ì¢Œí‘œ: (${result[0].y}, ${result[0].x})`);
                    finalResolve({ x: result[0].x, y: result[0].y, address: result[0].address_name });
                } else {
                    console.log(`  âŒ ì‹¤íŒ¨ (ì‹œë„ ${stepIndex + 1}, ìƒíƒœ: ${status})`);
                    attemptGeocodeSequentially(originalAddress, cleaningSteps, stepIndex + 1, finalResolve);
                }
            });
        }
        
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        function downloadExcel() {
            const ws = XLSX.utils.aoa_to_sheet(convertedData);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'ë³€í™˜ê²°ê³¼');
            XLSX.writeFile(wb, 'ì£¼ì†Œ_ìœ„ê²½ë„_ë³€í™˜_' + new Date().toISOString().slice(0,10) + '.xlsx');
        }
        
        async function optimizeRoute() {
            if (!geocoder || convertedData.length === 0) return;
            
            const startAddress = getStartAddress();
            if (!startAddress) {
                showStatus('optimizeStatus', 'âŒ ì¶œë°œì§€ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.', 'error');
                return;
            }
            
            console.log(`ğŸš€ ê²½ë¡œ ìºì‹œ: ${routeCache.size}ê°œ ì €ì¥ë¨`);
            
            showStatus('optimizeStatus', 'ğŸ”„ ìµœì í™” ì§„í–‰ ì¤‘...', 'processing');
            document.getElementById('optimizeBtn').disabled = true;
            optimizeStartTime = Date.now();
            
            startPoint = await geocodeAddress(startAddress);
            if (!startPoint) {
                showStatus('optimizeStatus', 'âŒ ì¶œë°œì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', 'error');
                document.getElementById('optimizeBtn').disabled = false;
                return;
            }
            
            const maxHours = parseInt(document.getElementById('maxHours').value);
            const maxVisits = parseInt(document.getElementById('maxVisits').value);
            const avgStay = parseInt(document.getElementById('avgStay').value);
            
            const validLocations = convertedData.slice(1).filter(row => {
                const lat = parseFloat(row[row.length - 2]);
                const lng = parseFloat(row[row.length - 1]);
                return !isNaN(lat) && !isNaN(lng);
            });
            
            if (validLocations.length === 0) {
                showStatus('optimizeStatus', 'âŒ ìœ íš¨í•œ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.', 'error');
                document.getElementById('optimizeBtn').disabled = false;
                return;
            }
            
            const schedule = await createSmartSchedule(validLocations, startPoint, maxHours, maxVisits, avgStay);
            finalSchedule = schedule;
            
            const endTime = Date.now();
            const totalSeconds = ((endTime - optimizeStartTime) / 1000).toFixed(1);
            
            displaySchedule(schedule);
            displayMarkersOnMap(schedule, startPoint);
            document.getElementById('scheduleButtons').style.display = 'block';
            
            showStatus('optimizeStatus', `âœ… ìµœì í™” ì™„ë£Œ! (${totalSeconds}ì´ˆ)`, 'success');
            document.getElementById('optimizeBtn').disabled = false;
        }
        
        async function createSmartSchedule(locations, start, maxHours, maxVisits, avgStay) {
            console.log(`\nğŸ“Š === ê°œì„ ëœ 2ë‹¨ê³„ ìµœì í™” ì‹œì‘ ===`);
            console.log(`ì´ ${locations.length}ê°œ ìœ„ì¹˜, ì¼ì¼ ìµœëŒ€ ${maxVisits}ê°œ ë°©ë¬¸`);
            
            // 1ë‹¨ê³„: ìƒì„¸ ì§€ì—­ë³„ ê·¸ë£¹í™”
            const cityGroups = groupByDetailedRegion(locations);
            console.log(`\nğŸ“ 1ë‹¨ê³„: ${cityGroups.length}ê°œ ì§€ì—­ìœ¼ë¡œ ë¶„ë¥˜ ì™„ë£Œ`);
            cityGroups.forEach(g => console.log(`  - ${g.name}: ${g.locations.length}ê°œ`));
            
            // 2ë‹¨ê³„: ê° ê·¸ë£¹ì˜ ì¤‘ì‹¬ì ê¹Œì§€ ì‹¤ì œ ê±°ë¦¬ ê³„ì‚°
            const groupsWithDistance = await calculateGroupDistances(cityGroups, start);
            
            // 3ë‹¨ê³„: ì¶œë°œì§€ì—ì„œ ê°€ê¹Œìš´ ìˆœìœ¼ë¡œ ì •ë ¬
            const orderedGroups = groupsWithDistance.sort((a, b) => a.distance - b.distance);
            console.log(`\nğŸš— ì¶œë°œì§€ ê¸°ì¤€ ì •ë ¬ ì™„ë£Œ`);
            orderedGroups.forEach(g => console.log(`  ${g.name}: ${g.distance.toFixed(1)}km`));
            
            // 4ë‹¨ê³„: ê° ê·¸ë£¹ ë‚´ì—ì„œ Greedy ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ì¼ì • ìƒì„±
            const schedule = await buildScheduleByGroups(orderedGroups, start, maxHours, maxVisits, avgStay, locations.length);
            
            const scheduledCount = schedule.reduce((sum, day) => sum + day.visits.length, 0);
            console.log(`\nğŸ“Š === ìµœì í™” ê²°ê³¼ ===`);
            console.log(`ì´ ${schedule.length}ì¼ ì¼ì •`);
            console.log(`ìŠ¤ì¼€ì¤„: ${scheduledCount}ê°œ / ì›ë³¸: ${locations.length}ê°œ`);
            
            if (scheduledCount !== locations.length) {
                console.error(`âš ï¸ ${locations.length - scheduledCount}ê°œ ìœ„ì¹˜ ëˆ„ë½!`);
            } else {
                console.log(`âœ… ëª¨ë“  ìœ„ì¹˜ í¬í•¨ ì™„ë£Œ!`);
            }
            
            return schedule;
        }
        
        function groupByDetailedRegion(locations) {
            const groups = {};
            
            locations.forEach(loc => {
                const addr = loc[selectedColumn] || loc[0];
                const normalized = addr.replace(/\s+/g, ' ').trim();
                
                let regionName = 'ê¸°íƒ€';
                
                // ë„ ë‹¨ìœ„ ì¶”ì¶œ íŒ¨í„´
                const provincePatterns = [
                    { pattern: /ì„œìš¸íŠ¹ë³„ì‹œ\s*([ê°€-í£]+êµ¬)/, prefix: 'ì„œìš¸' },
                    { pattern: /ê²½ê¸°ë„?\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ê²½ê¸°' },
                    { pattern: /ì¸ì²œê´‘ì—­ì‹œ\s*([ê°€-í£]+[êµ¬êµ°])/, prefix: 'ì¸ì²œ' },
                    { pattern: /ì¶©ì²­ë‚¨ë„\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ì¶©ë‚¨' },
                    { pattern: /ì¶©ë‚¨\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ì¶©ë‚¨' },
                    { pattern: /ì¶©ì²­ë¶ë„\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ì¶©ë¶' },
                    { pattern: /ì¶©ë¶\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ì¶©ë¶' },
                    { pattern: /ê°•ì›[ë„íŠ¹ë³„ìì¹˜ë„]*\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ê°•ì›' },
                    { pattern: /ì „ë¼ë‚¨ë„\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ì „ë‚¨' },
                    { pattern: /ì „ë‚¨\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ì „ë‚¨' },
                    { pattern: /ì „ë¼ë¶ë„\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ì „ë¶' },
                    { pattern: /ì „ë¶\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ì „ë¶' },
                    { pattern: /ê²½ìƒë‚¨ë„\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ê²½ë‚¨' },
                    { pattern: /ê²½ë‚¨\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ê²½ë‚¨' },
                    { pattern: /ê²½ìƒë¶ë„\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ê²½ë¶' },
                    { pattern: /ê²½ë¶\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ê²½ë¶' },
                    { pattern: /ì œì£¼[ë„íŠ¹ë³„ìì¹˜ë„]*\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ì œì£¼' },
                    { pattern: /ë¶€ì‚°ê´‘ì—­ì‹œ\s*([ê°€-í£]+[êµ¬êµ°])/, prefix: 'ë¶€ì‚°' },
                    { pattern: /ëŒ€êµ¬ê´‘ì—­ì‹œ\s*([ê°€-í£]+[êµ¬êµ°])/, prefix: 'ëŒ€êµ¬' },
                    { pattern: /ëŒ€ì „ê´‘ì—­ì‹œ\s*([ê°€-í£]+êµ¬)/, prefix: 'ëŒ€ì „' },
                    { pattern: /ê´‘ì£¼ê´‘ì—­ì‹œ\s*([ê°€-í£]+êµ¬)/, prefix: 'ê´‘ì£¼' },
                    { pattern: /ìš¸ì‚°ê´‘ì—­ì‹œ\s*([ê°€-í£]+[êµ¬êµ°])/, prefix: 'ìš¸ì‚°' },
                    { pattern: /ì„¸ì¢…íŠ¹ë³„ìì¹˜ì‹œ/, prefix: 'ì„¸ì¢…', noCity: true }
                ];
                
                // íŒ¨í„´ ë§¤ì¹­
                for (const { pattern, prefix, noCity } of provincePatterns) {
                    const match = normalized.match(pattern);
                    if (match) {
                        if (noCity) {
                            regionName = prefix;
                        } else {
                            regionName = `${prefix} ${match[1]}`;
                        }
                        break;
                    }
                }
                
                // ë§¤ì¹­ ì‹¤íŒ¨ ì‹œ ê¸°ë³¸ ì‹œ/êµ°/êµ¬ ì¶”ì¶œ
                if (regionName === 'ê¸°íƒ€') {
                    const basicMatch = normalized.match(/([ê°€-í£]+[ì‹œêµ°êµ¬])/);
                    if (basicMatch) {
                        regionName = basicMatch[1];
                    }
                }
                
                if (!groups[regionName]) {
                    groups[regionName] = [];
                }
                groups[regionName].push(loc);
            });
            
            // ê·¸ë£¹ ë°°ì—´ë¡œ ë³€í™˜ ë° ì¤‘ì‹¬ì  ê³„ì‚°
            return Object.entries(groups).map(([name, locs]) => {
                const centerLat = locs.reduce((s, l) => s + parseFloat(l[l.length - 2]), 0) / locs.length;
                const centerLng = locs.reduce((s, l) => s + parseFloat(l[l.length - 1]), 0) / locs.length;
                
                return {
                    name,
                    locations: locs,
                    center: { lat: centerLat, lng: centerLng }
                };
            });
        }
        
        async function calculateGroupDistances(groups, start) {
            const result = [];
            
            console.log(`\nğŸ” ê° ì§€ì—­ ì¤‘ì‹¬ì ê¹Œì§€ ì‹¤ì œ ê±°ë¦¬ ê³„ì‚° ì¤‘...`);
            
            for (const group of groups) {
                const routeInfo = await getKakaoRoute(
                    start.y, start.x,
                    group.center.lat, group.center.lng
                );
                
                result.push({
                    ...group,
                    distance: routeInfo.distance,
                    duration: routeInfo.duration
                });
                
                console.log(`  ${group.name}: ${routeInfo.distance.toFixed(1)}km (${routeInfo.duration}ë¶„)`);
            }
            
            return result;
        }
        
        async function buildScheduleByGroups(orderedGroups, start, maxHours, maxVisits, avgStay, totalCount) {
            let schedule = [];
            let currentDay = 1;
            let currentDayVisits = [];
            let currentPosition = start;
            let totalProcessed = 0;
            
            const maxMinutes = (maxHours + 0.3) * 60;
            
            console.log(`\nğŸ¯ === ê·¸ë£¹ë³„ Greedy ìµœì í™” ì‹œì‘ ===`);
            console.log(`ì¼ì¼ ìµœëŒ€ ì—…ë¬´ì‹œê°„: ${maxHours}ì‹œê°„ + 0.3ì‹œê°„ = ${(maxHours + 0.3).toFixed(1)}ì‹œê°„ (${maxMinutes.toFixed(0)}ë¶„)`);
            console.log(`í‰ê·  ì²´ë¥˜ì‹œê°„: ${avgStay}ë¶„`);
            console.log(`ì¼ì¼ ìµœëŒ€ ë°©ë¬¸: ${maxVisits}ê°œ`);
            
            for (let groupIdx = 0; groupIdx < orderedGroups.length; groupIdx++) {
                const group = orderedGroups[groupIdx];
                let remainingInGroup = [...group.locations];
                
                console.log(`\nğŸ™ï¸ ${group.name} ì²˜ë¦¬ ì¤‘ (${group.locations.length}ê°œ)`);
                
                const statusEl = document.getElementById('optimizeStatus');
                statusEl.className = 'processing';
                statusEl.innerHTML = `<div class="optimize-main">${group.name} ì²˜ë¦¬ ì¤‘ (${groupIdx + 1}/${orderedGroups.length})</div><div class="optimize-detail">ì¤€ë¹„ ì¤‘...</div>`;
                
                while (remainingInGroup.length > 0) {
                    const currentTime = currentDayVisits.reduce((s, v) => s + parseFloat(v.time), 0);
                    const remainTime = maxMinutes - currentTime;
                    
                    if (remainTime < avgStay && currentDayVisits.length > 0) {
                        console.log(`  â° ì‹œê°„ ë¶€ì¡±, ë‹¤ìŒ ë‚ ë¡œ`);
                        
                        const firstVisit = currentDayVisits[0];
                        const lastVisit = currentDayVisits[currentDayVisits.length - 1];
                        
                        const toFirst = await getKakaoRoute(start.y, start.x, firstVisit.lat, firstVisit.lng);
                        const toStart = await getKakaoRoute(lastVisit.lat, lastVisit.lng, start.y, start.x);
                        
                        schedule.push({
                            day: currentDay,
                            visits: currentDayVisits,
                            departureTime: toFirst.duration,
                            returnTime: toStart.duration
                        });
                        
                        console.log(`  âœ… ${currentDay}ì¼ì°¨ ì™„ë£Œ: ${currentDayVisits.length}ê°œ`);
                        currentDay++;
                        currentDayVisits = [];
                        currentPosition = start;
                        continue;
                    }
                    
                    const progress = Math.round((totalProcessed / totalCount) * 100);
                    document.getElementById('optimizeProgressFill').style.width = progress + '%';
                    document.getElementById('optimizeProgressFill').textContent = progress + '%';
                    
                    const statusEl = document.getElementById('optimizeStatus');
                    statusEl.innerHTML = `<div class="optimize-main">${group.name} ì²˜ë¦¬ ì¤‘ (${groupIdx + 1}/${orderedGroups.length})</div><div class="optimize-detail">${totalProcessed}/${totalCount}ê°œ ì™„ë£Œ | ${group.name} ë‚´ ${remainingInGroup.length}ê°œ ë‚¨ìŒ</div>`;
                    
                    const candidates = remainingInGroup
                        .map((loc, idx) => {
                            const lat = parseFloat(loc[loc.length - 2]);
                            const lng = parseFloat(loc[loc.length - 1]);
                            
                            if (isNaN(lat) || isNaN(lng)) return null;
                            
                            const straightDist = calculateDistance(
                                parseFloat(currentPosition.y), parseFloat(currentPosition.x),
                                lat, lng
                            );
                            
                            return { idx, loc, lat, lng, straightDist };
                        })
                        .filter(c => c !== null)
                        .sort((a, b) => a.straightDist - b.straightDist)
                        .slice(0, Math.min(5, remainingInGroup.length));
                    
                    if (candidates.length === 0) {
                        console.error(`  âŒ ${group.name}ì—ì„œ ìœ íš¨í•œ ê²½ë¡œ ì—†ìŒ`);
                        break;
                    }
                    
                    let nearestIdx = -1;
                    let minDuration = Infinity;
                    let nearestDistance = 0;
                    
                    const routePromises = candidates.map(async (candidate) => {
                        const routeInfo = await getKakaoRoute(
                            currentPosition.y, currentPosition.x, 
                            candidate.lat, candidate.lng
                        );
                        return { ...candidate, routeInfo };
                    });
                    
                    const routeResults = await Promise.all(routePromises);
                    
                    for (const result of routeResults) {
                        if (result.routeInfo.duration < minDuration) {
                            minDuration = result.routeInfo.duration;
                            nearestDistance = result.routeInfo.distance;
                            nearestIdx = result.idx;
                        }
                    }
                    
                    if (nearestIdx === -1) {
                        console.error(`  âŒ ${group.name}ì—ì„œ ìœ íš¨í•œ ê²½ë¡œ ì—†ìŒ`);
                        break;
                    }
                    
                    const nearest = remainingInGroup[nearestIdx];
                    const lat = parseFloat(nearest[nearest.length - 2]);
                    const lng = parseFloat(nearest[nearest.length - 1]);
                    
                    const estimatedTime = minDuration + avgStay;
                    const newTotalTime = currentTime + estimatedTime;
                    
                    if (nearestDistance > 20 && currentDayVisits.length > 0) {
                        console.log(`  ğŸ“ ê±°ë¦¬ ì´ˆê³¼, ë‹¤ìŒ ë‚ ë¡œ`);
                        
                        const firstVisit = currentDayVisits[0];
                        const lastVisit = currentDayVisits[currentDayVisits.length - 1];
                        
                        const toFirst = await getKakaoRoute(start.y, start.x, firstVisit.lat, firstVisit.lng);
                        const toStart = await getKakaoRoute(lastVisit.lat, lastVisit.lng, start.y, start.x);
                        
                        schedule.push({
                            day: currentDay,
                            visits: currentDayVisits,
                            departureTime: toFirst.duration,
                            returnTime: toStart.duration
                        });
                        
                        currentDay++;
                        currentDayVisits = [];
                        currentPosition = start;
                        continue;
                    }
                    
                    if (newTotalTime > maxMinutes && currentDayVisits.length > 0) {
                        console.log(`  â° ì‹œê°„ ì´ˆê³¼, ë‹¤ìŒ ë‚ ë¡œ`);
                        
                        const firstVisit = currentDayVisits[0];
                        const lastVisit = currentDayVisits[currentDayVisits.length - 1];
                        
                        const toFirst = await getKakaoRoute(start.y, start.x, firstVisit.lat, firstVisit.lng);
                        const toStart = await getKakaoRoute(lastVisit.lat, lastVisit.lng, start.y, start.x);
                        
                        schedule.push({
                            day: currentDay,
                            visits: currentDayVisits,
                            departureTime: toFirst.duration,
                            returnTime: toStart.duration
                        });
                        
                        currentDay++;
                        currentDayVisits = [];
                        currentPosition = start;
                        continue;
                    }
                    
                    if (currentDayVisits.length >= maxVisits) {
                        console.log(`  â„¹ï¸ ë°©ë¬¸ ìˆ˜ ${currentDayVisits.length}ê°œ, ì‹œê°„ì´ í—ˆë½í•˜ë©´ ê³„ì†`);
                    }
                    
                    const companyName = (companyColumn >= 0 && nearest[companyColumn]) ? nearest[companyColumn] : '';
                    
                    currentDayVisits.push({
                        address: nearest[selectedColumn] || nearest[0],
                        company: companyName,
                        lat, lng,
                        distance: nearestDistance.toFixed(2),
                        travelTime: minDuration.toFixed(0),
                        time: estimatedTime.toFixed(0),
                        data: nearest
                    });
                    
                    console.log(`    â• ${nearest[selectedColumn]?.substring(0, 30)} (${nearestDistance.toFixed(1)}km)`);
                    
                    currentPosition = { x: lng, y: lat };
                    remainingInGroup.splice(nearestIdx, 1);
                    totalProcessed++;
                }
                
                console.log(`  âœ… ${group.name} ì™„ë£Œ (${group.locations.length}ê°œ ì²˜ë¦¬)`);
            }
            
            if (currentDayVisits.length > 0) {
                const firstVisit = currentDayVisits[0];
                const lastVisit = currentDayVisits[currentDayVisits.length - 1];
                
                const toFirst = await getKakaoRoute(start.y, start.x, firstVisit.lat, firstVisit.lng);
                const toStart = await getKakaoRoute(lastVisit.lat, lastVisit.lng, start.y, start.x);
                
                schedule.push({
                    day: currentDay,
                    visits: currentDayVisits,
                    departureTime: toFirst.duration,
                    returnTime: toStart.duration
                });
                
                console.log(`  âœ… ${currentDay}ì¼ì°¨ ì™„ë£Œ (ë§ˆì§€ë§‰)`);
            }
            
            console.log(`\nğŸ”„ === ì¼ì • ì¬ì¡°ì • ì‹œì‘ ===`);
            schedule = await rebalanceSchedule(schedule, maxVisits, start);
            
            return schedule;
        }
        
        async function rebalanceSchedule(schedule, maxVisits, start) {
            const threshold = Math.floor(maxVisits * 0.5);
            console.log(`\nğŸ”„ === ì¼ì • ì¬ì¡°ì • ì‹œì‘ ===`);
            console.log(`ì¬ì¡°ì • ê¸°ì¤€: ${threshold}ê°œ ì´í•˜`);
            console.log(`í˜„ì¬ ì¼ì •: ${schedule.length}ì¼`);
            
            schedule.forEach(day => {
                const status = day.visits.length <= threshold ? 'â—ì¬ì¡°ì • ëŒ€ìƒ' : 'âœ…ì •ìƒ';
                console.log(`  ${day.day}ì¼ì°¨: ${day.visits.length}ê°œ ${status}`);
            });
            
            let changed = true;
            let iterations = 0;
            const maxIterations = 5;
            
            while (changed && iterations < maxIterations) {
                changed = false;
                iterations++;
                console.log(`\nğŸ”„ ì¬ì¡°ì • ${iterations}íšŒì°¨ ì‹œì‘`);
                
                const sortedDays = schedule
                    .map((day, idx) => ({ day, originalIdx: idx }))
                    .filter(item => item.day.visits.length <= threshold)
                    .sort((a, b) => a.day.visits.length - b.day.visits.length);
                
                if (sortedDays.length === 0) {
                    console.log('  âœ… ì¬ì¡°ì • ëŒ€ìƒ ì—†ìŒ');
                    break;
                }
                
                console.log(`  ì¬ì¡°ì • ëŒ€ìƒ: ${sortedDays.length}ì¼`);
                
                for (const { day: sourceDay, originalIdx: sourceIdx } of sortedDays) {
                    console.log(`\n  ğŸ“Œ ${sourceDay.day}ì¼ì°¨ ì²˜ë¦¬ (${sourceDay.visits.length}ê°œ)`);
                    
                    const sourceCenter = calculateCenter(sourceDay.visits);
                    
                    let bestTarget = null;
                    let bestDistance = Infinity;
                    
                    for (let j = 0; j < schedule.length; j++) {
                        if (j === sourceIdx) continue;
                        
                        const targetDay = schedule[j];
                        
                        if (targetDay.visits.length + sourceDay.visits.length > maxVisits) {
                            console.log(`    â­ï¸ ${targetDay.day}ì¼ì°¨: ìš©ëŸ‰ ì´ˆê³¼`);
                            continue;
                        }
                        
                        const targetCenter = calculateCenter(targetDay.visits);
                        
                        const centerDistance = calculateDistance(
                            sourceCenter.lat, sourceCenter.lng,
                            targetCenter.lat, targetCenter.lng
                        );
                        
                        console.log(`    ğŸ“ ${targetDay.day}ì¼ì°¨: ì¤‘ì‹¬ì  ê±°ë¦¬ ${centerDistance.toFixed(1)}km`);
                        
                        if (centerDistance <= 30 && centerDistance < bestDistance) {
                            const maxPairDistance = getMaxPairDistance(sourceDay.visits, targetDay.visits);
                            
                            if (maxPairDistance <= 40) {
                                bestTarget = j;
                                bestDistance = centerDistance;
                                console.log(`      âœ… ë³‘í•© í›„ë³´ (ìµœëŒ€ ê±°ë¦¬: ${maxPairDistance.toFixed(1)}km)`);
                            } else {
                                console.log(`      âŒ ìµœëŒ€ ê±°ë¦¬ ì´ˆê³¼: ${maxPairDistance.toFixed(1)}km > 40km`);
                            }
                        } else if (centerDistance > 30) {
                            console.log(`      âŒ ì¤‘ì‹¬ì  ê±°ë¦¬ ì´ˆê³¼`);
                        }
                    }
                    
                    if (bestTarget !== null) {
                        const targetDay = schedule[bestTarget];
                        console.log(`\n    ğŸ¯ ${sourceDay.day}ì¼ì°¨ â†’ ${targetDay.day}ì¼ì°¨ ë³‘í•© ì‹¤í–‰`);
                        
                        targetDay.visits.push(...sourceDay.visits);
                        
                        console.log(`      ë³‘í•© ì „ ìˆœì„œ ìµœì í™” ì¤‘...`);
                        targetDay.visits = await reorderVisits(targetDay.visits, start);
                        
                        const firstVisit = targetDay.visits[0];
                        const lastVisit = targetDay.visits[targetDay.visits.length - 1];
                        const toFirst = await getKakaoRoute(start.y, start.x, firstVisit.lat, firstVisit.lng);
                        const toStart = await getKakaoRoute(lastVisit.lat, lastVisit.lng, start.y, start.x);
                        targetDay.departureTime = toFirst.duration;
                        targetDay.returnTime = toStart.duration;
                        
                        schedule.splice(sourceIdx, 1);
                        
                        schedule.forEach((d, idx) => d.day = idx + 1);
                        
                        changed = true;
                        console.log(`      âœ… ë³‘í•© ì™„ë£Œ! (${targetDay.visits.length}ê°œ)`);
                        break;
                    } else {
                        console.log(`    âŒ ë³‘í•© ê°€ëŠ¥í•œ ë‚ ì§œ ì—†ìŒ`);
                    }
                }
                
                if (!changed) {
                    console.log('\n  â„¹ï¸ ë” ì´ìƒ ë³‘í•©í•  ë‚ ì§œ ì—†ìŒ');
                }
            }
            
            console.log(`\nâœ… ì¬ì¡°ì • ì™„ë£Œ: ${schedule.length}ì¼ ì¼ì •`);
            console.log(`ğŸ“Š ìºì‹œ íˆíŠ¸: ${routeCache.size}ê°œ ê²½ë¡œ ì €ì¥ë¨`);
            
            console.log('\nğŸ“‹ ìµœì¢… ì¼ì •:');
            schedule.forEach(day => {
                console.log(`  ${day.day}ì¼ì°¨: ${day.visits.length}ê°œ ë°©ë¬¸`);
            });
            
            return schedule;
        }
        
        function calculateCenter(visits) {
            const sumLat = visits.reduce((sum, v) => sum + parseFloat(v.lat), 0);
            const sumLng = visits.reduce((sum, v) => sum + parseFloat(v.lng), 0);
            return {
                lat: sumLat / visits.length,
                lng: sumLng / visits.length
            };
        }
        
        function getMaxPairDistance(visits1, visits2) {
            let maxDist = 0;
            
            for (const v1 of visits1) {
                for (const v2 of visits2) {
                    const dist = calculateDistance(
                        parseFloat(v1.lat), parseFloat(v1.lng),
                        parseFloat(v2.lat), parseFloat(v2.lng)
                    );
                    if (dist > maxDist) maxDist = dist;
                }
            }
            
            return maxDist;
        }
        
        async function reorderVisits(visits, start) {
            const ordered = [];
            const remaining = [...visits];
            let currentPos = start;
            
            while (remaining.length > 0) {
                const candidates = remaining
                    .map((visit, idx) => {
                        const straightDist = calculateDistance(
                            parseFloat(currentPos.y), parseFloat(currentPos.x),
                            parseFloat(visit.lat), parseFloat(visit.lng)
                        );
                        return { idx, visit, straightDist };
                    })
                    .sort((a, b) => a.straightDist - b.straightDist)
                    .slice(0, Math.min(5, remaining.length));
                
                const routePromises = candidates.map(async (candidate) => {
                    const route = await getKakaoRoute(
                        parseFloat(currentPos.y), 
                        parseFloat(currentPos.x),
                        parseFloat(candidate.visit.lat), 
                        parseFloat(candidate.visit.lng)
                    );
                    return { ...candidate, route };
                });
                
                const routeResults = await Promise.all(routePromises);
                
                let bestResult = routeResults[0];
                for (const result of routeResults) {
                    if (result.route.distance < bestResult.route.distance) {
                        bestResult = result;
                    }
                }
                
                const nearest = remaining.splice(bestResult.idx, 1)[0];
                
                nearest.distance = bestResult.route.distance.toFixed(2);
                nearest.travelTime = bestResult.route.duration.toFixed(0);
                const avgStay = parseInt(document.getElementById('avgStay').value) || 30;
                nearest.time = (bestResult.route.duration + avgStay).toFixed(0);
                
                ordered.push(nearest);
                currentPos = { y: nearest.lat, x: nearest.lng };
            }
            
            return ordered;
        }
        
        async function getKakaoRoute(startLat, startLng, endLat, endLng) {
            startLat = parseFloat(startLat);
            startLng = parseFloat(startLng);
            endLat = parseFloat(endLat);
            endLng = parseFloat(endLng);
            
            if (isNaN(startLat) || isNaN(startLng) || isNaN(endLat) || isNaN(endLng)) {
                console.error('Invalid coordinates:', { startLat, startLng, endLat, endLng });
                return { duration: 0, distance: 0 };
            }
            
            const cacheKey = `${startLat.toFixed(4)},${startLng.toFixed(4)}-${endLat.toFixed(4)},${endLng.toFixed(4)}`;
            
            if (routeCache.has(cacheKey)) {
                return routeCache.get(cacheKey);
            }
            
            try {
                const url = `https://apis-navi.kakaomobility.com/v1/directions?origin=${startLng},${startLat}&destination=${endLng},${endLat}&priority=RECOMMEND`;
                const response = await fetch(url, {
                    headers: { 'Authorization': 'KakaoAK e7993bf34b2b04dcdeaf01bb36f06a85' }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    
                    if (data && data.routes && data.routes.length > 0) {
                        const route = data.routes[0];
                        
                        if (route.summary) {
                            const duration = route.summary.duration;
                            const distance = route.summary.distance;
                            
                            if (typeof duration === 'number' && typeof distance === 'number' && 
                                !isNaN(duration) && !isNaN(distance)) {
                                
                                const result = {
                                    duration: Math.round(duration / 60),
                                    distance: distance / 1000
                                };
                                
                                routeCache.set(cacheKey, result);
                                return result;
                            } else {
                                console.warn('Invalid duration/distance values:', { duration, distance });
                            }
                        } else {
                            console.warn('No summary in route:', route);
                        }
                    } else {
                        console.warn('No routes in response:', data);
                    }
                } else {
                    console.warn(`API response not ok: ${response.status} ${response.statusText}`);
                }
            } catch (error) {
                console.warn('Route API error:', error.message);
            }
            
            const distance = calculateDistance(startLat, startLng, endLat, endLng);
            const result = { 
                duration: Math.round((distance / 40) * 60), 
                distance 
            };
            
            routeCache.set(cacheKey, result);
            return result;
        }
        
        function calculateDistance(lat1, lon1, lat2, lon2) {
            lat1 = parseFloat(lat1);
            lon1 = parseFloat(lon1);
            lat2 = parseFloat(lat2);
            lon2 = parseFloat(lon2);
            
            if (isNaN(lat1) || isNaN(lon1) || isNaN(lat2) || isNaN(lon2)) {
                return 0;
            }
            
            const R = 6371;
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        function displaySchedule(schedule) {
            let html = '<div class="route-list">';
            
            schedule.forEach(day => {
                const totalDistance = day.visits.reduce((s, v) => s + parseFloat(v.distance), 0);
                const travelTime = day.visits.reduce((s, v) => s + parseFloat(v.travelTime), 0);
                const avgStay = parseInt(document.getElementById('avgStay').value);
                const totalTime = travelTime + (day.returnTime || 0) + (day.visits.length * avgStay);
                const color = dayColors[(day.day - 1) % dayColors.length];
                
                html += `
                    <div class="day-schedule" style="border-top: 5px solid ${color};">
                        <h3>
                            <span style="background: ${color}; color: white; padding: 8px 15px; border-radius: 8px;">
                                ${day.day}ì¼ì°¨
                            </span>
                        </h3>
                        
                        <div class="day-stats">
                            <div class="stat-card">
                                <div class="label">ë°©ë¬¸ ì—…ì²´</div>
                                <div class="value">${day.visits.length}ê°œ</div>
                            </div>
                            <div class="stat-card">
                                <div class="label">ì´ ê±°ë¦¬</div>
                                <div class="value">${totalDistance.toFixed(1)}km</div>
                            </div>
                            <div class="stat-card">
                                <div class="label">ì´ë™ ì‹œê°„</div>
                                <div class="value">${Math.round(travelTime)}ë¶„</div>
                            </div>
                            <div class="stat-card">
                                <div class="label">ì´ ì†Œìš”ì‹œê°„</div>
                                <div class="value">${(totalTime/60).toFixed(1)}ì‹œê°„</div>
                            </div>
                        </div>
                        
                        <div class="timeline">
                `;
                
                day.visits.forEach((visit, index) => {
                    html += `
                        <div class="timeline-item">
                            <div class="timeline-icon visit" style="background: linear-gradient(135deg, ${color} 0%, ${color} 100%);">${index + 1}</div>
                            <div class="timeline-content" style="border-left-color: ${color};">
                                <div class="timeline-info">
                                    ${visit.company ? `<div class="timeline-company">${visit.company}</div>` : ''}
                                    <div class="timeline-title">${visit.address}</div>
                                </div>
                                <div class="travel-info">
                                    <span>ğŸš— ${visit.travelTime}ë¶„</span>
                                    <span>ğŸ“ ${visit.distance}km</span>
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                html += `
                        <div class="timeline-item">
                            <div class="timeline-icon end" style="background: linear-gradient(135deg, #9e9e9e 0%, #757575 100%);">ğŸ</div>
                            <div class="timeline-content end-point" style="border-left-color: #9e9e9e;">
                                <div class="timeline-info">
                                    <div class="timeline-title">ê·€ê°€</div>
                                </div>
                                <div class="travel-info">
                                    <span>ğŸš— ${day.returnTime}ë¶„</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                `;
            });
            
            html += '</div>';
            document.getElementById('routeResult').innerHTML = html;
        }
        
        function displayMarkersOnMap(schedule, start) {
            if (!map) return;
            
            markers.forEach(marker => {
                try {
                    if (marker && marker.setMap) {
                        marker.setMap(null);
                    }
                } catch (e) {
                    console.log('ë§ˆì»¤ ì œê±° ì¤‘ ì˜¤ë¥˜:', e);
                }
            });
            markers = [];
            
            const bounds = new kakao.maps.LatLngBounds();
            
            try {
                const startPos = new kakao.maps.LatLng(parseFloat(start.y), parseFloat(start.x));
                const startMarker = new kakao.maps.Marker({
                    position: startPos,
                    map: map,
                    image: new kakao.maps.MarkerImage(
                        'https://t1.daumcdn.net/localimg/localimages/07/mapapidoc/markerStar.png',
                        new kakao.maps.Size(24, 35)
                    )
                });
                
                const startInfowindow = new kakao.maps.InfoWindow({
                    content: '<div style="padding:5px;font-size:12px;">ğŸ  ì¶œë°œì§€</div>'
                });
                startInfowindow.open(map, startMarker);
                markers.push(startMarker);
                bounds.extend(startPos);
            } catch (e) {
                console.error('ì¶œë°œì§€ ë§ˆì»¤ ìƒì„± ì˜¤ë¥˜:', e);
            }
            
            schedule.forEach((day) => {
                const color = dayColors[(day.day - 1) % dayColors.length];
                
                day.visits.forEach((visit, visitIndex) => {
                    try {
                        const lat = parseFloat(visit.lat);
                        const lng = parseFloat(visit.lng);
                        
                        if (isNaN(lat) || isNaN(lng)) {
                            console.warn(`ìœ íš¨í•˜ì§€ ì•Šì€ ì¢Œí‘œ: ${visit.address}`);
                            return;
                        }
                        
                        const position = new kakao.maps.LatLng(lat, lng);
                        
                        if (visitIndex > 0) {
                            const prevVisit = day.visits[visitIndex - 1];
                            const prevLat = parseFloat(prevVisit.lat);
                            const prevLng = parseFloat(prevVisit.lng);
                            
                            if (!isNaN(prevLat) && !isNaN(prevLng)) {
                                const polyline = new kakao.maps.Polyline({
                                    path: [
                                        new kakao.maps.LatLng(prevLat, prevLng),
                                        position
                                    ],
                                    strokeWeight: 3,
                                    strokeColor: color,
                                    strokeOpacity: 0.7
                                });
                                polyline.setMap(map);
                                markers.push(polyline);
                            }
                        }
                        
                        const markerContent = document.createElement('div');
                        markerContent.style.cssText = `
                            width: 36px;
                            height: 36px;
                            background: ${color};
                            border: 3px solid white;
                            border-radius: 50%;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-weight: bold;
                            color: white;
                            font-size: 14px;
                            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
                            cursor: pointer;
                            position: relative;
                        `;
                        markerContent.textContent = visitIndex + 1;
                        
                        const customOverlay = new kakao.maps.CustomOverlay({
                            position: position,
                            content: markerContent,
                            yAnchor: 0.5,
                            zIndex: 3
                        });
                        
                        customOverlay.setMap(map);
                        
                        const infoContent = visit.company 
                            ? `<div style="padding:8px;font-size:12px;min-width:150px;">
                                <strong style="color:${color};">${day.day}ì¼ì°¨-${visitIndex + 1}</strong><br>
                                <strong>${visit.company}</strong><br>
                                ${visit.address}<br>
                                <small>ğŸš— ${visit.travelTime}ë¶„ | ğŸ“ ${visit.distance}km</small>
                            </div>`
                            : `<div style="padding:8px;font-size:12px;min-width:150px;">
                                <strong style="color:${color};">${day.day}ì¼ì°¨-${visitIndex + 1}</strong><br>
                                ${visit.address}<br>
                                <small>ğŸš— ${visit.travelTime}ë¶„ | ğŸ“ ${visit.distance}km</small>
                            </div>`;
                        
                        const infowindow = new kakao.maps.InfoWindow({
                            content: infoContent,
                            removable: false
                        });
                        
                        markerContent.addEventListener('click', function() {
                            markers.forEach(m => {
                                if (m.infowindow && m.infowindow.close) {
                                    m.infowindow.close();
                                }
                            });
                            
                            const tempMarker = new kakao.maps.Marker({
                                position: position,
                                map: null
                            });
                            
                            infowindow.open(map, tempMarker);
                            
                            setTimeout(() => {
                                infowindow.close();
                            }, 3000);
                        });
                        
                        markers.push({
                            overlay: customOverlay,
                            infowindow: infowindow,
                            setMap: function(m) {
                                if (this.overlay) this.overlay.setMap(m);
                            }
                        });
                        
                        bounds.extend(position);
                        
                    } catch (e) {
                        console.error(`ë§ˆì»¤ ìƒì„± ì˜¤ë¥˜ (${visit.address}):`, e);
                    }
                });
            });
            
            try {
                map.setBounds(bounds);
            } catch (e) {
                console.error('ì§€ë„ ë²”ìœ„ ì¡°ì • ì˜¤ë¥˜:', e);
            }
        }
        
        function downloadScheduleExcel() {
            if (!finalSchedule || !convertedData) return;
            
            console.log('\nğŸ“¥ === ì¼ì • íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì‹œì‘ ===');
            console.log(`convertedData í–‰ ìˆ˜: ${convertedData.length} (í—¤ë” í¬í•¨)`);
            console.log(`ë°ì´í„° í–‰ ìˆ˜: ${convertedData.length - 1}`);
            
            const scheduleData = convertedData.map(row => [...row]);
            
            scheduleData[0].push('ì¼ì •');
            
            const scheduleMap = new Map();
            const usedRows = new Set();
            let totalScheduledVisits = 0;
            
            finalSchedule.forEach(day => {
                day.visits.forEach((visit, idx) => {
                    totalScheduledVisits++;
                    
                    for (let i = 1; i < convertedData.length; i++) {
                        if (usedRows.has(i)) continue;
                        
                        const row = convertedData[i];
                        const rowLat = parseFloat(row[row.length - 2]);
                        const rowLng = parseFloat(row[row.length - 1]);
                        
                        if (isNaN(rowLat) || isNaN(rowLng)) continue;
                        
                        if (Math.abs(rowLat - visit.lat) < 0.0001 && 
                            Math.abs(rowLng - visit.lng) < 0.0001) {
                            
                            const scheduleLabel = `Day${day.day}-${idx + 1}`;
                            scheduleMap.set(i, scheduleLabel);
                            usedRows.add(i);
                            console.log(`  ë§¤ì¹­: í–‰${i} â†’ ${scheduleLabel} (${visit.address?.substring(0, 30)}...)`);
                            break;
                        }
                    }
                });
            });
            
            console.log(`\nì´ ìŠ¤ì¼€ì¤„ëœ ë°©ë¬¸: ${totalScheduledVisits}ê°œ`);
            console.log(`ë§¤ì¹­ëœ í–‰: ${scheduleMap.size}ê°œ`);
            
            if (totalScheduledVisits !== scheduleMap.size) {
                console.warn(`âš ï¸ ë§¤ì¹­ ëˆ„ë½: ${totalScheduledVisits - scheduleMap.size}ê°œ`);
            }
            
            let addedCount = 0;
            for (let i = 1; i < scheduleData.length; i++) {
                const scheduleLabel = scheduleMap.get(i) || '';
                scheduleData[i].push(scheduleLabel);
                if (scheduleLabel) {
                    addedCount++;
                }
            }
            
            console.log(`ì¼ì •ì´ ì¶”ê°€ëœ í–‰: ${addedCount}ê°œ`);
            console.log(`ì²˜ë¦¬ëœ ì „ì²´ í–‰: ${scheduleData.length - 1}ê°œ (í—¤ë” ì œì™¸)`);
            
            const sortedData = [];
            
            sortedData.push([...scheduleData[0]]);
            
            finalSchedule.forEach(day => {
                day.visits.forEach((visit, idx) => {
                    for (let i = 1; i < scheduleData.length; i++) {
                        const scheduleLabel = scheduleData[i][scheduleData[i].length - 1];
                        if (scheduleLabel === `Day${day.day}-${idx + 1}`) {
                            sortedData.push([...scheduleData[i]]);
                            break;
                        }
                    }
                });
            });
            
            console.log(`\nSheet2 ìƒì„±: ${sortedData.length - 1}ê°œ í–‰ (í—¤ë” ì œì™¸)`);
            
            const wb = XLSX.utils.book_new();
            
            const ws1 = XLSX.utils.aoa_to_sheet(scheduleData);
            XLSX.utils.book_append_sheet(wb, ws1, 'ì›ë³¸ìˆœì„œ');
            
            const ws2 = XLSX.utils.aoa_to_sheet(sortedData);
            XLSX.utils.book_append_sheet(wb, ws2, 'ì¼ì •ìˆœì„œ');
            
            XLSX.writeFile(wb, 'ì¶œì¥ì¼ì •_' + new Date().toISOString().slice(0,10) + '.xlsx');
            
            console.log('\nâœ… ì¼ì • íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì™„ë£Œ (2ê°œ ì‹œíŠ¸)');
        }
    </script>
</body>
</html>
