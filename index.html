<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì¶œì¥ ê³„íš ìˆ˜ë¦½ ì—…ë¬´ ìë™í™” í”„ë¡¬í”„íŠ¸</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=0c62e9a12c740ee7f1620f92ec4659bf&libraries=services"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #e3f2fd 0%, #f0f9ff 50%, #f5fffa 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #a0e65f 0%, #5ec9ff 50%, #3fa8e0 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .content {
            padding: 30px;
        }
        
        .section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        
        .section h2 {
            color: #3fa8e0;
            margin-bottom: 20px;
            font-size: 1.5em;
            border-bottom: 3px solid #a0e65f;
            padding-bottom: 10px;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }
        
        .input-group input, .input-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }
        
        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #5ec9ff;
        }
        
        #customAddressInput {
            display: none;
            margin-top: 10px;
        }
        
        .input-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        
        button {
            background: linear-gradient(135deg, #3fa8e0 0%, #5ec9ff 50%, #a0e65f 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(63, 168, 224, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            background: #999;
            cursor: not-allowed;
            transform: none;
        }
        
        .file-upload {
            border: 3px dashed #a0e65f;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }
        
        .file-upload:hover {
            background: #f0fff4;
            border-color: #5ec9ff;
        }
        
        .file-upload.drag-over {
            background: #e6f7ff;
            border-color: #3fa8e0;
            border-style: solid;
            transform: scale(1.02);
        }
        
        .file-upload input[type="file"] {
            display: none;
        }
        
        .file-upload-icon {
            font-size: 3em;
            margin-bottom: 10px;
            transition: transform 0.3s;
        }
        
        .file-upload:hover .file-upload-icon {
            transform: scale(1.1);
        }
        
        .status {
            margin-top: 15px;
            padding: 12px;
            border-radius: 8px;
            font-weight: 500;
        }
        
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        #map {
            width: 100%;
            height: 600px;
            border-radius: 12px;
            margin-top: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e0e0e0;
            border-radius: 15px;
            overflow: hidden;
            margin: 15px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3fa8e0 0%, #5ec9ff 50%, #a0e65f 100%);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
        }
        
        .route-list {
            margin-top: 20px;
        }
        
        .day-schedule {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 3px 15px rgba(0,0,0,0.08);
        }
        
        .day-schedule h3 {
            color: #3fa8e0;
            margin-bottom: 20px;
            font-size: 1.4em;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .day-stats {
            display: flex;
            gap: 15px;
            margin-bottom: 25px;
            flex-wrap: wrap;
        }
        
        .stat-card {
            flex: 1;
            min-width: 120px;
            padding: 12px;
            border-radius: 10px;
            text-align: center;
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border: 2px solid #bae6fd;
        }
        
        .stat-card .label {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 5px;
        }
        
        .stat-card .value {
            font-size: 1.3em;
            font-weight: bold;
            color: #0369a1;
        }
        
        .timeline {
            position: relative;
            padding-left: 0;
        }
        
        .timeline-item {
            position: relative;
            margin-bottom: 12px;
            animation: fadeInUp 0.5s ease forwards;
            opacity: 0;
        }
        
        @keyframes fadeInUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
            from {
                opacity: 0;
                transform: translateY(20px);
            }
        }
        
        .timeline-item:nth-child(1) { animation-delay: 0.1s; }
        .timeline-item:nth-child(2) { animation-delay: 0.15s; }
        .timeline-item:nth-child(3) { animation-delay: 0.2s; }
        .timeline-item:nth-child(4) { animation-delay: 0.25s; }
        .timeline-item:nth-child(5) { animation-delay: 0.3s; }
        .timeline-item:nth-child(6) { animation-delay: 0.35s; }
        .timeline-item:nth-child(7) { animation-delay: 0.4s; }
        .timeline-item:nth-child(8) { animation-delay: 0.45s; }
        
        .timeline-icon {
            position: absolute;
            left: 0;
            top: 0;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            z-index: 2;
        }
        
        .timeline-icon.start {
            background: linear-gradient(135deg, #a0e65f 0%, #7dd64f 100%);
        }
        
        .timeline-icon.visit {
            background: linear-gradient(135deg, #5ec9ff 0%, #3fa8e0 100%);
            color: white;
            font-weight: bold;
            font-size: 0.9em;
        }
        
        .timeline-icon.end {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
        }
        
        .timeline-content {
            background: white;
            padding: 12px 15px;
            margin-left: 50px;
            border-radius: 12px;
            border-left: 4px solid #5ec9ff;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            transition: transform 0.2s, box-shadow 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
        }
        
        .timeline-content:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.12);
        }
        
        .timeline-content.start-point {
            border-left-color: #a0e65f;
            background: linear-gradient(90deg, #f0fff4 0%, white 100%);
        }
        
        .timeline-content.end-point {
            border-left-color: #ff6b6b;
            background: linear-gradient(90deg, #fff0f0 0%, white 100%);
        }
        
        .timeline-info {
            flex: 1;
            min-width: 0;
        }
        
        .timeline-title {
            font-weight: 600;
            font-size: 0.95em;
            color: #1e293b;
            margin-bottom: 5px;
            line-height: 1.4;
        }
        
        .timeline-company {
            font-weight: 700;
            font-size: 1.1em;
            color: #0f172a;
            margin-bottom: 5px;
        }
        
        .timeline-meta {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            font-size: 0.85em;
            color: #64748b;
        }
        
        .timeline-meta span {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .travel-info {
            display: flex;
            gap: 12px;
            font-size: 0.9em;
            color: #64748b;
            white-space: nowrap;
            padding: 6px 12px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }
        
        .travel-info span {
            display: flex;
            align-items: center;
            gap: 4px;
            font-weight: 600;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .conversion-stats {
            display: flex;
            gap: 20px;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        
        .stat-box {
            flex: 1;
            min-width: 150px;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        
        .stat-box.success {
            background: #d1fae5;
            border: 2px solid #a0e65f;
        }
        
        .stat-box.fail {
            background: #fee2e2;
            border: 2px solid #ef4444;
        }
        
        .stat-box.total {
            background: #dbeafe;
            border: 2px solid #5ec9ff;
        }
        
        .stat-number {
            font-size: 2em;
            font-weight: bold;
            margin: 5px 0;
        }
        
        .stat-label {
            font-size: 0.9em;
            color: #666;
        }
        
        .footer {
            background: #6c757d;
            color: white;
            text-align: center;
            padding: 20px;
            font-size: 0.9em;
        }
        
        .footer a {
            color: #5ec9ff;
            text-decoration: none;
        }
        
        .footer a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸš— ë”°ë¼ì™€ ìŠ¤ë§ˆíŠ¸ ì¶œì¥ ê²½ë¡œ ìµœì í™”</h1>
            <p>ì—‘ì…€íŒŒì¼ì„ ì—…ë¡œë“œí•˜ì—¬ íš¨ìœ¨ì ì¸ ì¶œì¥ê²½ë¡œë¥¼ ìë™ìœ¼ë¡œ ìƒì„±í•˜ì„¸ìš”</p>
        </div>
        
        <div class="content">
            <div class="section">
                <h2>ğŸ“ 1ë‹¨ê³„: ì—‘ì…€ íŒŒì¼ ì—…ë¡œë“œ ë° ì£¼ì†Œ ë³€í™˜</h2>
                <div class="file-upload" id="fileUploadArea">
                    <div class="file-upload-icon">ğŸ“¤</div>
                    <p style="font-size: 1.2em; margin-bottom: 10px; font-weight: 600;">í´ë¦­ ë˜ëŠ” ë“œë˜ê·¸í•˜ì—¬ ì—‘ì…€ íŒŒì¼ ì—…ë¡œë“œ</p>
                    <p style="color: #666;">ì£¼ì†Œê°€ í¬í•¨ëœ ì—‘ì…€ íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”</p>
                    <p style="color: #999; font-size: 0.9em; margin-top: 10px;">.xlsx, .xls íŒŒì¼ ì§€ì›</p>
                    <input type="file" id="excelFile" accept=".xlsx,.xls">
                </div>
                <div id="uploadStatus"></div>
                
                <div id="previewSection" style="display: none;">
                    <div class="input-group" style="margin-top: 20px;">
                        <label>ì£¼ì†Œê°€ í¬í•¨ëœ ì—´ì„ ì„ íƒí•˜ì„¸ìš”</label>
                        <select id="addressColumn">
                            <option value="">-- ì£¼ì†Œ ì—´ ì„ íƒ --</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label>ì—…ì²´ëª…ì´ í¬í•¨ëœ ì—´ì„ ì„ íƒí•˜ì„¸ìš” (ì„ íƒì‚¬í•­)</label>
                        <select id="companyColumn">
                            <option value="">-- ì—…ì²´ëª… ì—´ ì„ íƒ (ì„ íƒì‚¬í•­) --</option>
                        </select>
                    </div>
                </div>
                
                <div id="conversionStats" style="display: none;">
                    <div class="conversion-stats">
                        <div class="stat-box total">
                            <div class="stat-label">ì „ì²´</div>
                            <div class="stat-number" id="totalCount">0</div>
                        </div>
                        <div class="stat-box success">
                            <div class="stat-label">âœ… ì„±ê³µ</div>
                            <div class="stat-number" id="successCount">0</div>
                        </div>
                        <div class="stat-box fail">
                            <div class="stat-label">âŒ ì‹¤íŒ¨</div>
                            <div class="stat-number" id="failCount">0</div>
                        </div>
                    </div>
                    <div id="currentAddress" style="padding: 10px; background: #d1fae5; border-radius: 8px; margin-top: 10px; border-left: 4px solid #a0e65f;"></div>
                </div>
                
                <div id="progressBar" style="display: none;">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill">0%</div>
                    </div>
                </div>
                <div class="button-group" style="margin-top: 20px;">
                    <button id="convertBtn" onclick="convertAddresses()" disabled>ğŸ”„ ì£¼ì†Œ ë³€í™˜ ì‹œì‘</button>
                    <button id="downloadBtn" onclick="downloadExcel()" disabled>ğŸ’¾ ë³€í™˜ëœ íŒŒì¼ ë‹¤ìš´ë¡œë“œ</button>
                </div>
            </div>
            
            <div class="section">
                <h2>ğŸ“… 2ë‹¨ê³„: ë°©ë¬¸ ì¼ì • ì„¤ì •</h2>
                <div class="input-row">
                    <div class="input-group">
                        <label>ì¼ì¼ ìµœëŒ€ ì—…ë¬´ì‹œê°„ (ì‹œê°„)</label>
                        <input type="number" id="maxHours" value="8" min="1" max="24">
                    </div>
                    <div class="input-group">
                        <label>ì¼ì¼ ë°©ë¬¸ ì—…ì²´ìˆ˜ (ê°œ)</label>
                        <input type="number" id="maxVisits" value="5" min="1" max="20">
                    </div>
                    <div class="input-group">
                        <label>í‰ê·  ì²´ë¥˜ì‹œê°„ (ë¶„)</label>
                        <input type="number" id="avgStay" value="30" min="5" max="180">
                    </div>
                </div>
                <div class="input-group">
                    <label>ì¶œë°œì§€ ì„ íƒ</label>
                    <select id="startLocation" onchange="toggleCustomAddress()">
                        <option value="ê²½ê¸°ë„ ì„±ë‚¨ì‹œ ë¶„ë‹¹êµ¬ ì¥ë¯¸ë¡œ 42" data-name="ìˆ˜ë„ê¶Œë™ë¶€í™˜ê²½ë³¸ë¶€">ìˆ˜ë„ê¶Œë™ë¶€í™˜ê²½ë³¸ë¶€ (ê²½ê¸° ì„±ë‚¨ì‹œ ë¶„ë‹¹êµ¬ ì¥ë¯¸ë¡œ 42)</option>
                        <option value="ì¸ì²œ ì„œêµ¬ í™˜ê²½ë¡œ 42" data-name="ë³¸ì‚¬">ë³¸ì‚¬ (ì¸ì²œ ì„œêµ¬ í™˜ê²½ë¡œ 42)</option>
                        <option value="ì„œìš¸ ê°•ì„œêµ¬ í™”ê³¡ë¡œ68ê¸¸ 82" data-name="ìˆ˜ë„ê¶Œì„œë¶€í™˜ê²½ë³¸ë¶€">ìˆ˜ë„ê¶Œì„œë¶€í™˜ê²½ë³¸ë¶€ (ì„œìš¸ ê°•ì„œêµ¬ í™”ê³¡ë¡œ68ê¸¸ 82)</option>
                        <option value="ë¶€ì‚° ë¶êµ¬ ë‚™ë™ë¶ë¡œ 681ë²ˆê¸¸ 34" data-name="ë¶€ì‚°ìš¸ì‚°ê²½ë‚¨í™˜ê²½ë³¸ë¶€">ë¶€ì‚°ìš¸ì‚°ê²½ë‚¨í™˜ê²½ë³¸ë¶€ (ë¶€ì‚° ë¶êµ¬ ë‚™ë™ë¶ë¡œ 681ë²ˆê¸¸ 34)</option>
                        <option value="ëŒ€êµ¬ ìˆ˜ì„±êµ¬ ë¬´í•™ë¡œ 209" data-name="ëŒ€êµ¬ê²½ë¶í™˜ê²½ë³¸ë¶€">ëŒ€êµ¬ê²½ë¶í™˜ê²½ë³¸ë¶€ (ëŒ€êµ¬ ìˆ˜ì„±êµ¬ ë¬´í•™ë¡œ 209)</option>
                        <option value="ëŒ€ì „ ì„œêµ¬ ì²­ì‚¬ë¡œ 156" data-name="ì¶©ì²­ê¶Œí™˜ê²½ë³¸ë¶€">ì¶©ì²­ê¶Œí™˜ê²½ë³¸ë¶€ (ëŒ€ì „ ì„œêµ¬ ì²­ì‚¬ë¡œ 156)</option>
                        <option value="ê´‘ì£¼ ê´‘ì‚°êµ¬ ë¬´ì§„ëŒ€ë¡œ 217" data-name="ê´‘ì£¼ì „ë‚¨ì œì£¼í™˜ê²½ë³¸ë¶€">ê´‘ì£¼ì „ë‚¨ì œì£¼í™˜ê²½ë³¸ë¶€ (ê´‘ì£¼ ê´‘ì‚°êµ¬ ë¬´ì§„ëŒ€ë¡œ 217)</option>
                        <option value="ê°•ì› ì¶˜ì²œì‹œ ê²½ì¶˜ë¡œ 2370" data-name="ê°•ì›í™˜ê²½ë³¸ë¶€">ê°•ì›í™˜ê²½ë³¸ë¶€ (ê°•ì› ì¶˜ì²œì‹œ ê²½ì¶˜ë¡œ 2370)</option>
                        <option value="ì „ë¶ ì „ì£¼ì‹œ ì™„ì‚°êµ¬ ì„œê³¡ë¡œ 100" data-name="ì „ë¶í™˜ê²½ë³¸ë¶€">ì „ë¶í™˜ê²½ë³¸ë¶€ (ì „ë¶ ì „ì£¼ì‹œ ì™„ì‚°êµ¬ ì„œê³¡ë¡œ 100)</option>
                        <option value="custom">ê¸°íƒ€ (ì§ì ‘ ì…ë ¥)</option>
                    </select>
                    <input type="text" id="customAddressInput" placeholder="ì¶œë°œì§€ ì£¼ì†Œë¥¼ ì…ë ¥í•˜ì„¸ìš”">
                </div>
                <button id="optimizeBtn" onclick="optimizeRoute()" disabled>ğŸ¯ ê²½ë¡œ ìµœì í™” ì‹¤í–‰</button>
                <div id="optimizeStatus"></div>
                
                <div id="optimizeProgress" style="display: none;">
                    <div style="padding: 15px; background: #e3f2fd; border-radius: 8px; margin-top: 15px; border-left: 4px solid #5ec9ff;">
                        <div id="optimizeCurrentCity" style="font-weight: bold; margin-bottom: 10px;"></div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="optimizeProgressFill">0%</div>
                        </div>
                        <div id="optimizeDetail" style="margin-top: 10px; font-size: 0.9em; color: #666;"></div>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h2>ğŸ—ºï¸ 3ë‹¨ê³„: ìµœì í™”ëœ ê²½ë¡œ</h2>
                <div id="scheduleButtons" style="display: none; margin-bottom: 15px;">
                    <button onclick="downloadScheduleExcel()">ğŸ“¥ ì¼ì • íŒŒì¼ ë‹¤ìš´ë¡œë“œ</button>
                </div>
                <div id="routeResult"></div>
                <div id="map"></div>
            </div>
        </div>
        
        <div class="footer">
            <p>Â© 2025 ë”°ë¼ì™€. All rights reserved.</p>
            <p>Developed by <strong>BTS</strong> (Business Trip Secretary)</p>
        </div>
    </div>

    <script>
        let uploadedData = [];
        let convertedData = [];
        let map = null;
        let markers = [];
        let geocoder = null;
        let startPoint = null;
        let selectedColumn = 0;
        let companyColumn = -1;
        let finalSchedule = null;
        let startLocationName = '';
        
        // ğŸš€ ê²½ë¡œ ìºì‹œ ì¶”ê°€ (ì†ë„ ê°œì„ )
        const routeCache = new Map();
        
        const dayColors = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8',
            '#F06292', '#BA68C8', '#9575CD', '#7986CB', '#64B5F6',
            '#4FC3F7', '#4DD0E1', '#4DB6AC', '#81C784', '#AED581'
        ];
        
        window.onload = function() {
            if (typeof kakao === 'undefined') {
                showStatus('uploadStatus', 'âŒ ì¹´ì¹´ì˜¤ SDK ë¡œë“œ ì‹¤íŒ¨', 'error');
                return;
            }
            
            kakao.maps.load(function() {
                geocoder = new kakao.maps.services.Geocoder();
                initMap();
                showStatus('uploadStatus', 'ğŸ“‚ ì—‘ì…€ íŒŒì¼ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”.', 'info');
            });
            
            // ë“œë˜ê·¸ì•¤ë“œë¡­ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
            setupDragAndDrop();
        };
        
        function toggleCustomAddress() {
            const select = document.getElementById('startLocation');
            const customInput = document.getElementById('customAddressInput');
            
            if (select.value === 'custom') {
                customInput.style.display = 'block';
                customInput.focus();
                startLocationName = 'ì¶œë°œì§€';
            } else {
                customInput.style.display = 'none';
                const selectedOption = select.options[select.selectedIndex];
                startLocationName = selectedOption.getAttribute('data-name') || 'ì¶œë°œì§€';
            }
        }
        
        function getStartAddress() {
            const select = document.getElementById('startLocation');
            const customInput = document.getElementById('customAddressInput');
            
            if (select.value === 'custom') {
                startLocationName = customInput.value.trim() || 'ì¶œë°œì§€';
                return customInput.value.trim();
            } else {
                const selectedOption = select.options[select.selectedIndex];
                startLocationName = selectedOption.getAttribute('data-name') || 'ì¶œë°œì§€';
                return select.value.trim();
            }
        }
        
        function setupDragAndDrop() {
            const uploadArea = document.getElementById('fileUploadArea');
            const fileInput = document.getElementById('excelFile');
            
            // í´ë¦­ ì´ë²¤íŠ¸
            uploadArea.addEventListener('click', function(e) {
                if (e.target.tagName !== 'INPUT') {
                    fileInput.click();
                }
            });
            
            // ë“œë˜ê·¸ ì˜¤ë²„
            uploadArea.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.add('drag-over');
            });
            
            // ë“œë˜ê·¸ ë‚˜ê°€ê¸°
            uploadArea.addEventListener('dragleave', function(e) {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.remove('drag-over');
            });
            
            // ë“œë¡­
            uploadArea.addEventListener('drop', function(e) {
                e.preventDefault();
                e.stopPropagation();
                uploadArea.classList.remove('drag-over');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    const file = files[0];
                    if (file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {
                        handleFile(file);
                    } else {
                        showStatus('uploadStatus', 'âŒ ì—‘ì…€ íŒŒì¼(.xlsx, .xls)ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤.', 'error');
                    }
                }
            });
            
            // íŒŒì¼ input ë³€ê²½
            fileInput.addEventListener('change', function(e) {
                if (e.target.files.length > 0) {
                    handleFile(e.target.files[0]);
                }
            });
        }
        
        function handleFile(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, {type: 'array'});
                const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                const jsonData = XLSX.utils.sheet_to_json(firstSheet, {header: 1});
                
                uploadedData = jsonData.filter(row => row.length > 0);
                showStatus('uploadStatus', `âœ… ${uploadedData.length}ê°œ í–‰ ì—…ë¡œë“œ ì™„ë£Œ (${file.name})`, 'success');
                showColumnSelector();
            };
            reader.readAsArrayBuffer(file);
        }
        
        function initMap() {
            const container = document.getElementById('map');
            const options = {
                center: new kakao.maps.LatLng(37.5665, 126.9780),
                level: 8
            };
            map = new kakao.maps.Map(container, options);
        }
        
        function showStatus(elementId, message, type) {
            document.getElementById(elementId).innerHTML = `<div class="status ${type}">${message}</div>`;
        }
        
        function showColumnSelector() {
            const previewSection = document.getElementById('previewSection');
            const addressColumnSelect = document.getElementById('addressColumn');
            const companyColumnSelect = document.getElementById('companyColumn');
            
            previewSection.style.display = 'block';
            addressColumnSelect.innerHTML = '<option value="">-- ì£¼ì†Œ ì—´ ì„ íƒ --</option>';
            companyColumnSelect.innerHTML = '<option value="">-- ì—…ì²´ëª… ì—´ ì„ íƒ (ì„ íƒì‚¬í•­) --</option>';
            
            if (uploadedData.length > 0) {
                const headerRow = uploadedData[0];
                headerRow.forEach((header, i) => {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = `${header} (ì—´ ${i + 1})`;
                    addressColumnSelect.appendChild(option);
                    
                    const option2 = document.createElement('option');
                    option2.value = i;
                    option2.textContent = `${header} (ì—´ ${i + 1})`;
                    companyColumnSelect.appendChild(option2);
                });
            }
            
            addressColumnSelect.onchange = function() {
                selectedColumn = parseInt(this.value);
                if (!isNaN(selectedColumn)) {
                    document.getElementById('convertBtn').disabled = false;
                }
            };
            
            companyColumnSelect.onchange = function() {
                const val = parseInt(this.value);
                companyColumn = isNaN(val) ? -1 : val;
            };
        }
        
        async function convertAddresses() {
            if (uploadedData.length <= 1 || isNaN(selectedColumn)) return;
            
            document.getElementById('convertBtn').disabled = true;
            document.getElementById('progressBar').style.display = 'block';
            document.getElementById('conversionStats').style.display = 'block';
            
            convertedData = [];
            let successCount = 0, failCount = 0;
            
            const headerRow = [...uploadedData[0], 'ìœ„ë„', 'ê²½ë„'];
            convertedData.push(headerRow);
            
            const dataRows = uploadedData.slice(1);
            document.getElementById('totalCount').textContent = dataRows.length;
            
            console.log(`\nğŸš€ === ì£¼ì†Œ ë³€í™˜ ì‹œì‘ (${dataRows.length}ê°œ) ===`);
            const startTime = Date.now();
            
            // ğŸš€ ë°°ì¹˜ í¬ê¸° ì„¤ì • (í•œ ë²ˆì— ì²˜ë¦¬í•  ê°œìˆ˜)
            const BATCH_SIZE = 3;
            const BATCH_DELAY = 100; // ë°°ì¹˜ ê°„ ë”œë ˆì´ (ms)
            
            for (let batchStart = 0; batchStart < dataRows.length; batchStart += BATCH_SIZE) {
                const batchEnd = Math.min(batchStart + BATCH_SIZE, dataRows.length);
                const batch = dataRows.slice(batchStart, batchEnd);
                
                // ğŸš€ ë°°ì¹˜ ë‚´ì—ì„œ ë³‘ë ¬ ì²˜ë¦¬
                const batchPromises = batch.map(async (row, batchIndex) => {
                    const i = batchStart + batchIndex;
                    const address = row[selectedColumn];
                    
                    document.getElementById('currentAddress').innerHTML = 
                        `ğŸ”„ (${i + 1}/${dataRows.length}): <strong>${address || 'ë¹ˆ ê°’'}</strong>`;
                    
                    if (!address) {
                        return { row, result: null };
                    }
                    
                    const result = await geocodeAddress(address);
                    return { row, result };
                });
                
                // ë°°ì¹˜ ì™„ë£Œ ëŒ€ê¸°
                const batchResults = await Promise.all(batchPromises);
                
                // ê²°ê³¼ ì €ì¥
                batchResults.forEach(({ row, result }) => {
                    if (!row[selectedColumn]) {
                        convertedData.push([...row, '', '']);
                        failCount++;
                    } else if (result) {
                        convertedData.push([...row, result.y, result.x]);
                        successCount++;
                    } else {
                        convertedData.push([...row, 'ë³€í™˜ ì‹¤íŒ¨', 'ë³€í™˜ ì‹¤íŒ¨']);
                        failCount++;
                    }
                });
                
                // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
                document.getElementById('successCount').textContent = successCount;
                document.getElementById('failCount').textContent = failCount;
                
                const progress = Math.round(((batchEnd) / dataRows.length) * 100);
                document.getElementById('progressFill').style.width = progress + '%';
                document.getElementById('progressFill').textContent = progress + '%';
                
                // ë°°ì¹˜ ê°„ ë”œë ˆì´ (API ì œí•œ ë°©ì§€)
                if (batchEnd < dataRows.length) {
                    await sleep(BATCH_DELAY);
                }
            }
            
            const endTime = Date.now();
            const totalSeconds = ((endTime - startTime) / 1000).toFixed(1);
            
            console.log(`âœ… ë³€í™˜ ì™„ë£Œ: ${totalSeconds}ì´ˆ ì†Œìš”`);
            console.log(`   ì„±ê³µ: ${successCount}ê°œ, ì‹¤íŒ¨: ${failCount}ê°œ`);
            console.log(`   í‰ê· : ${(totalSeconds / dataRows.length).toFixed(2)}ì´ˆ/ê°œ`);
            
            showStatus('uploadStatus', `âœ… ì™„ë£Œ! ${successCount}/${dataRows.length}ê°œ ì„±ê³µ (${totalSeconds}ì´ˆ)`, 'success');
            document.getElementById('downloadBtn').disabled = false;
            document.getElementById('optimizeBtn').disabled = false;
            document.getElementById('convertBtn').disabled = false;
        }
        
        function geocodeAddress(address) {
            return new Promise((resolve) => {
                if (!geocoder || !address || typeof address !== 'string') {
                    resolve(null);
                    return;
                }
                
                const originalAddress = address.trim();
                console.log(`\nğŸ” ì›ë³¸ ì£¼ì†Œ: "${originalAddress}"`);
                
                const cleaningSteps = [
                    (addr) => addr,
                    (addr) => addr.replace(/\([^)]*\)/g, '').trim(),
                    (addr) => addr.replace(/\([^)]*\)/g, '').replace(/[\.Â·,]+$/g, '').trim(),
                    (addr) => {
                        const cleaned = addr.replace(/\([^)]*\)/g, '').replace(/[\.Â·,]+$/g, '').trim();
                        const parts = cleaned.split(' ');
                        if (parts.length > 3) {
                            return parts.slice(0, -1).join(' ');
                        }
                        return cleaned;
                    },
                    (addr) => {
                        const cleaned = addr.replace(/\([^)]*\)/g, '').replace(/[\.Â·,]+$/g, '').trim();
                        const parts = cleaned.split(' ');
                        if (parts.length > 4) {
                            return parts.slice(0, -2).join(' ');
                        }
                        return null;
                    },
                    (addr) => {
                        const cleaned = addr.replace(/\([^)]*\)/g, '').trim();
                        const match = cleaned.match(/(.*?[ì‹œêµ°êµ¬].*?[ìë©´ë™ë¦¬])\s+[\d-]+/);
                        if (match) {
                            return match[0];
                        }
                        return null;
                    }
                ];
                
                attemptGeocodeSequentially(originalAddress, cleaningSteps, 0, resolve);
            });
        }
        
        function attemptGeocodeSequentially(originalAddress, cleaningSteps, stepIndex, finalResolve) {
            if (stepIndex >= cleaningSteps.length) {
                console.log('  âŒ ëª¨ë“  ì‹œë„ ì‹¤íŒ¨');
                finalResolve(null);
                return;
            }
            
            const cleanedAddress = cleaningSteps[stepIndex](originalAddress);
            
            if (!cleanedAddress || cleanedAddress === '') {
                attemptGeocodeSequentially(originalAddress, cleaningSteps, stepIndex + 1, finalResolve);
                return;
            }
            
            if (stepIndex > 0) {
                console.log(`  ì‹œë„ ${stepIndex + 1}: "${cleanedAddress}"`);
            }
            
            geocoder.addressSearch(cleanedAddress, function(result, status) {
                if (status === kakao.maps.services.Status.OK && result && result.length > 0) {
                    console.log(`  âœ… ì„±ê³µ! (ì‹œë„ ${stepIndex + 1}) ì¢Œí‘œ: (${result[0].y}, ${result[0].x})`);
                    finalResolve({ x: result[0].x, y: result[0].y, address: result[0].address_name });
                } else {
                    console.log(`  âŒ ì‹¤íŒ¨ (ì‹œë„ ${stepIndex + 1}, ìƒíƒœ: ${status})`);
                    attemptGeocodeSequentially(originalAddress, cleaningSteps, stepIndex + 1, finalResolve);
                }
            });
        }
        
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        function downloadExcel() {
            const ws = XLSX.utils.aoa_to_sheet(convertedData);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'ë³€í™˜ê²°ê³¼');
            XLSX.writeFile(wb, 'ì£¼ì†Œ_ìœ„ê²½ë„_ë³€í™˜_' + new Date().toISOString().slice(0,10) + '.xlsx');
        }
        
        async function optimizeRoute() {
            if (!geocoder || convertedData.length === 0) return;
            
            const startAddress = getStartAddress();
            if (!startAddress) {
                showStatus('optimizeStatus', 'âŒ ì¶œë°œì§€ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.', 'error');
                return;
            }
            
            console.log(`ğŸš€ ê²½ë¡œ ìºì‹œ: ${routeCache.size}ê°œ ì €ì¥ë¨`);
            
            document.getElementById('optimizeProgress').style.display = 'block';
            document.getElementById('optimizeBtn').disabled = true;
            
            startPoint = await geocodeAddress(startAddress);
            if (!startPoint) {
                showStatus('optimizeStatus', 'âŒ ì¶œë°œì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', 'error');
                document.getElementById('optimizeProgress').style.display = 'none';
                document.getElementById('optimizeBtn').disabled = false;
                return;
            }
            
            const maxHours = parseInt(document.getElementById('maxHours').value);
            const maxVisits = parseInt(document.getElementById('maxVisits').value);
            const avgStay = parseInt(document.getElementById('avgStay').value);
            
            const validLocations = convertedData.slice(1).filter(row => {
                const lat = parseFloat(row[row.length - 2]);
                const lng = parseFloat(row[row.length - 1]);
                return !isNaN(lat) && !isNaN(lng);
            });
            
            if (validLocations.length === 0) {
                showStatus('optimizeStatus', 'âŒ ìœ íš¨í•œ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.', 'error');
                document.getElementById('optimizeProgress').style.display = 'none';
                document.getElementById('optimizeBtn').disabled = false;
                return;
            }
            
            const schedule = await createSmartSchedule(validLocations, startPoint, maxHours, maxVisits, avgStay);
            finalSchedule = schedule;
            
            document.getElementById('optimizeProgress').style.display = 'none';
            displaySchedule(schedule);
            displayMarkersOnMap(schedule, startPoint);
            document.getElementById('scheduleButtons').style.display = 'block';
            
            showStatus('optimizeStatus', 'âœ… ìµœì í™” ì™„ë£Œ!', 'success');
            document.getElementById('optimizeBtn').disabled = false;
        }
        
        async function createSmartSchedule(locations, start, maxHours, maxVisits, avgStay) {
            console.log(`\nğŸ“Š === ê°œì„ ëœ 2ë‹¨ê³„ ìµœì í™” ì‹œì‘ ===`);
            console.log(`ì´ ${locations.length}ê°œ ìœ„ì¹˜, ì¼ì¼ ìµœëŒ€ ${maxVisits}ê°œ ë°©ë¬¸`);
            
            // 1ë‹¨ê³„: ìƒì„¸ ì§€ì—­ë³„ ê·¸ë£¹í™”
            const cityGroups = groupByDetailedRegion(locations);
            console.log(`\nğŸ“ 1ë‹¨ê³„: ${cityGroups.length}ê°œ ì§€ì—­ìœ¼ë¡œ ë¶„ë¥˜ ì™„ë£Œ`);
            cityGroups.forEach(g => console.log(`  - ${g.name}: ${g.locations.length}ê°œ`));
            
            // 2ë‹¨ê³„: ê° ê·¸ë£¹ì˜ ì¤‘ì‹¬ì ê¹Œì§€ ì‹¤ì œ ê±°ë¦¬ ê³„ì‚°
            const groupsWithDistance = await calculateGroupDistances(cityGroups, start);
            
            // 3ë‹¨ê³„: ì¶œë°œì§€ì—ì„œ ê°€ê¹Œìš´ ìˆœìœ¼ë¡œ ì •ë ¬
            const orderedGroups = groupsWithDistance.sort((a, b) => a.distance - b.distance);
            console.log(`\nğŸš— ì¶œë°œì§€ ê¸°ì¤€ ì •ë ¬ ì™„ë£Œ`);
            orderedGroups.forEach(g => console.log(`  ${g.name}: ${g.distance.toFixed(1)}km`));
            
            // 4ë‹¨ê³„: ê° ê·¸ë£¹ ë‚´ì—ì„œ Greedy ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ì¼ì • ìƒì„±
            const schedule = await buildScheduleByGroups(orderedGroups, start, maxHours, maxVisits, avgStay, locations.length);
            
            const scheduledCount = schedule.reduce((sum, day) => sum + day.visits.length, 0);
            console.log(`\nğŸ“Š === ìµœì í™” ê²°ê³¼ ===`);
            console.log(`ì´ ${schedule.length}ì¼ ì¼ì •`);
            console.log(`ìŠ¤ì¼€ì¤„: ${scheduledCount}ê°œ / ì›ë³¸: ${locations.length}ê°œ`);
            
            if (scheduledCount !== locations.length) {
                console.error(`âš ï¸ ${locations.length - scheduledCount}ê°œ ìœ„ì¹˜ ëˆ„ë½!`);
            } else {
                console.log(`âœ… ëª¨ë“  ìœ„ì¹˜ í¬í•¨ ì™„ë£Œ!`);
            }
            
            return schedule;
        }
        
        function groupByDetailedRegion(locations) {
            const groups = {};
            
            locations.forEach(loc => {
                const addr = loc[selectedColumn] || loc[0];
                const normalized = addr.replace(/\s+/g, ' ').trim();
                
                let regionName = 'ê¸°íƒ€';
                
                // ë„ ë‹¨ìœ„ ì¶”ì¶œ íŒ¨í„´
                const provincePatterns = [
                    { pattern: /ì„œìš¸íŠ¹ë³„ì‹œ\s*([ê°€-í£]+êµ¬)/, prefix: 'ì„œìš¸' },
                    { pattern: /ê²½ê¸°ë„?\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ê²½ê¸°' },
                    { pattern: /ì¸ì²œê´‘ì—­ì‹œ\s*([ê°€-í£]+[êµ¬êµ°])/, prefix: 'ì¸ì²œ' },
                    { pattern: /ì¶©ì²­ë‚¨ë„\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ì¶©ë‚¨' },
                    { pattern: /ì¶©ë‚¨\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ì¶©ë‚¨' },
                    { pattern: /ì¶©ì²­ë¶ë„\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ì¶©ë¶' },
                    { pattern: /ì¶©ë¶\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ì¶©ë¶' },
                    { pattern: /ê°•ì›[ë„íŠ¹ë³„ìì¹˜ë„]*\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ê°•ì›' },
                    { pattern: /ì „ë¼ë‚¨ë„\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ì „ë‚¨' },
                    { pattern: /ì „ë‚¨\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ì „ë‚¨' },
                    { pattern: /ì „ë¼ë¶ë„\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ì „ë¶' },
                    { pattern: /ì „ë¶\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ì „ë¶' },
                    { pattern: /ê²½ìƒë‚¨ë„\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ê²½ë‚¨' },
                    { pattern: /ê²½ë‚¨\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ê²½ë‚¨' },
                    { pattern: /ê²½ìƒë¶ë„\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ê²½ë¶' },
                    { pattern: /ê²½ë¶\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ê²½ë¶' },
                    { pattern: /ì œì£¼[ë„íŠ¹ë³„ìì¹˜ë„]*\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ì œì£¼' },
                    { pattern: /ë¶€ì‚°ê´‘ì—­ì‹œ\s*([ê°€-í£]+[êµ¬êµ°])/, prefix: 'ë¶€ì‚°' },
                    { pattern: /ëŒ€êµ¬ê´‘ì—­ì‹œ\s*([ê°€-í£]+[êµ¬êµ°])/, prefix: 'ëŒ€êµ¬' },
                    { pattern: /ëŒ€ì „ê´‘ì—­ì‹œ\s*([ê°€-í£]+êµ¬)/, prefix: 'ëŒ€ì „' },
                    { pattern: /ê´‘ì£¼ê´‘ì—­ì‹œ\s*([ê°€-í£]+êµ¬)/, prefix: 'ê´‘ì£¼' },
                    { pattern: /ìš¸ì‚°ê´‘ì—­ì‹œ\s*([ê°€-í£]+[êµ¬êµ°])/, prefix: 'ìš¸ì‚°' },
                    { pattern: /ì„¸ì¢…íŠ¹ë³„ìì¹˜ì‹œ/, prefix: 'ì„¸ì¢…', noCity: true }
                ];
                
                // íŒ¨í„´ ë§¤ì¹­
                for (const { pattern, prefix, noCity } of provincePatterns) {
                    const match = normalized.match(pattern);
                    if (match) {
                        if (noCity) {
                            regionName = prefix;
                        } else {
                            regionName = `${prefix} ${match[1]}`;
                        }
                        break;
                    }
                }
                
                // ë§¤ì¹­ ì‹¤íŒ¨ ì‹œ ê¸°ë³¸ ì‹œ/êµ°/êµ¬ ì¶”ì¶œ
                if (regionName === 'ê¸°íƒ€') {
                    const basicMatch = normalized.match(/([ê°€-í£]+[ì‹œêµ°êµ¬])/);
                    if (basicMatch) {
                        regionName = basicMatch[1];
                    }
                }
                
                if (!groups[regionName]) {
                    groups[regionName] = [];
                }
                groups[regionName].push(loc);
            });
            
            // ê·¸ë£¹ ë°°ì—´ë¡œ ë³€í™˜ ë° ì¤‘ì‹¬ì  ê³„ì‚°
            return Object.entries(groups).map(([name, locs]) => {
                const centerLat = locs.reduce((s, l) => s + parseFloat(l[l.length - 2]), 0) / locs.length;
                const centerLng = locs.reduce((s, l) => s + parseFloat(l[l.length - 1]), 0) / locs.length;
                
                return {
                    name,
                    locations: locs,
                    center: { lat: centerLat, lng: centerLng }
                };
            });
        }
        
        async function calculateGroupDistances(groups, start) {
            const result = [];
            
            console.log(`\nğŸ” ê° ì§€ì—­ ì¤‘ì‹¬ì ê¹Œì§€ ì‹¤ì œ ê±°ë¦¬ ê³„ì‚° ì¤‘...`);
            
            for (const group of groups) {
                const routeInfo = await getKakaoRoute(
                    start.y, start.x,
                    group.center.lat, group.center.lng
                );
                
                result.push({
                    ...group,
                    distance: routeInfo.distance,
                    duration: routeInfo.duration
                });
                
                console.log(`  ${group.name}: ${routeInfo.distance.toFixed(1)}km (${routeInfo.duration}ë¶„)`);
            }
            
            return result;
        }
        
        async function buildScheduleByGroups(orderedGroups, start, maxHours, maxVisits, avgStay, totalCount) {
            let schedule = [];
            let currentDay = 1;
            let currentDayVisits = [];
            let currentPosition = start;
            let totalProcessed = 0;
            
            // ğŸ†• 0.3ì‹œê°„(18ë¶„) ì—¬ìœ  ì¶”ê°€
            const maxMinutes = (maxHours + 0.3) * 60;
            
            console.log(`\nğŸ¯ === ê·¸ë£¹ë³„ Greedy ìµœì í™” ì‹œì‘ ===`);
            console.log(`ì¼ì¼ ìµœëŒ€ ì—…ë¬´ì‹œê°„: ${maxHours}ì‹œê°„ + 0.3ì‹œê°„ = ${(maxHours + 0.3).toFixed(1)}ì‹œê°„ (${maxMinutes.toFixed(0)}ë¶„)`);
            console.log(`ì¼ì¼ ìµœëŒ€ ë°©ë¬¸: ${maxVisits}ê°œ`);
            
            for (let groupIdx = 0; groupIdx < orderedGroups.length; groupIdx++) {
                const group = orderedGroups[groupIdx];
                let remainingInGroup = [...group.locations];
                
                console.log(`\nğŸ™ï¸ ${group.name} ì²˜ë¦¬ ì¤‘ (${group.locations.length}ê°œ)`);
                
                document.getElementById('optimizeCurrentCity').textContent = 
                    `${group.name} ì²˜ë¦¬ ì¤‘ (${groupIdx + 1}/${orderedGroups.length})`;
                
                while (remainingInGroup.length > 0) {
                    const capacity = maxVisits - currentDayVisits.length;
                    const currentTime = currentDayVisits.reduce((s, v) => s + parseFloat(v.time), 0);
                    const remainTime = maxMinutes - currentTime;
                    
                    if (capacity === 0 || (remainTime < 30 && currentDayVisits.length > 0)) {
                        if (currentDayVisits.length > 0) {
                            const firstVisit = currentDayVisits[0];
                            const lastVisit = currentDayVisits[currentDayVisits.length - 1];
                            
                            const toFirst = await getKakaoRoute(start.y, start.x, firstVisit.lat, firstVisit.lng);
                            const toStart = await getKakaoRoute(lastVisit.lat, lastVisit.lng, start.y, start.x);
                            
                            schedule.push({
                                day: currentDay,
                                visits: currentDayVisits,
                                departureTime: toFirst.duration,
                                returnTime: toStart.duration
                            });
                            
                            console.log(`  âœ… ${currentDay}ì¼ì°¨ ì™„ë£Œ: ${currentDayVisits.length}ê°œ`);
                            currentDay++;
                            currentDayVisits = [];
                            currentPosition = start;
                        }
                        continue;
                    }
                    
                    const progress = Math.round((totalProcessed / totalCount) * 100);
                    document.getElementById('optimizeProgressFill').style.width = progress + '%';
                    document.getElementById('optimizeProgressFill').textContent = progress + '%';
                    document.getElementById('optimizeDetail').textContent = 
                        `${totalProcessed}/${totalCount}ê°œ ì™„ë£Œ | ${group.name} ë‚´ ${remainingInGroup.length}ê°œ ë‚¨ìŒ`;
                    
                    // ğŸš€ ì†ë„ ê°œì„ : ì§ì„  ê±°ë¦¬ë¡œ ì‚¬ì „ í•„í„°ë§
                    const candidates = remainingInGroup
                        .map((loc, idx) => {
                            const lat = parseFloat(loc[loc.length - 2]);
                            const lng = parseFloat(loc[loc.length - 1]);
                            
                            if (isNaN(lat) || isNaN(lng)) return null;
                            
                            const straightDist = calculateDistance(
                                parseFloat(currentPosition.y), parseFloat(currentPosition.x),
                                lat, lng
                            );
                            
                            return { idx, loc, lat, lng, straightDist };
                        })
                        .filter(c => c !== null)
                        .sort((a, b) => a.straightDist - b.straightDist)
                        .slice(0, Math.min(5, remainingInGroup.length)); // ê°€ê¹Œìš´ 5ê°œë§Œ ì„ íƒ
                    
                    if (candidates.length === 0) {
                        console.error(`  âŒ ${group.name}ì—ì„œ ìœ íš¨í•œ ê²½ë¡œ ì—†ìŒ`);
                        break;
                    }
                    
                    // ğŸš€ ì„ íƒëœ í›„ë³´ë“¤ë§Œ API í˜¸ì¶œ (ë³‘ë ¬ ì²˜ë¦¬)
                    let nearestIdx = -1;
                    let minDuration = Infinity;
                    let nearestDistance = 0;
                    
                    const routePromises = candidates.map(async (candidate) => {
                        const routeInfo = await getKakaoRoute(
                            currentPosition.y, currentPosition.x, 
                            candidate.lat, candidate.lng
                        );
                        return { ...candidate, routeInfo };
                    });
                    
                    const routeResults = await Promise.all(routePromises);
                    
                    // ê°€ì¥ ê°€ê¹Œìš´ ê²ƒ ì„ íƒ
                    for (const result of routeResults) {
                        if (result.routeInfo.duration < minDuration) {
                            minDuration = result.routeInfo.duration;
                            nearestDistance = result.routeInfo.distance;
                            nearestIdx = result.idx;
                        }
                    }
                    
                    if (nearestIdx === -1) {
                        console.error(`  âŒ ${group.name}ì—ì„œ ìœ íš¨í•œ ê²½ë¡œ ì—†ìŒ`);
                        break;
                    }
                    
                    const nearest = remainingInGroup[nearestIdx];
                    const lat = parseFloat(nearest[nearest.length - 2]);
                    const lng = parseFloat(nearest[nearest.length - 1]);
                    
                    const estimatedTime = minDuration + avgStay;
                    const newTotalTime = currentTime + estimatedTime;
                    
                    // ğŸ†• 20km ì´ìƒì´ë©´ ë‹¤ìŒ ë‚ ë¡œ (ì‹œê°„/ìš©ëŸ‰ ì²´í¬ ì „ì—)
                    if (nearestDistance > 20 && currentDayVisits.length > 0) {
                        console.log(`  ğŸ“ ê±°ë¦¬ ì´ˆê³¼ (${nearestDistance.toFixed(1)}km > 20km), ë‹¤ìŒ ë‚ ë¡œ`);
                        
                        const firstVisit = currentDayVisits[0];
                        const lastVisit = currentDayVisits[currentDayVisits.length - 1];
                        
                        const toFirst = await getKakaoRoute(start.y, start.x, firstVisit.lat, firstVisit.lng);
                        const toStart = await getKakaoRoute(lastVisit.lat, lastVisit.lng, start.y, start.x);
                        
                        schedule.push({
                            day: currentDay,
                            visits: currentDayVisits,
                            departureTime: toFirst.duration,
                            returnTime: toStart.duration
                        });
                        
                        currentDay++;
                        currentDayVisits = [];
                        currentPosition = start;
                        continue;
                    }
                    
                    if (newTotalTime > maxMinutes && currentDayVisits.length > 0) {
                        console.log(`  â° ì‹œê°„ ì´ˆê³¼ (${(newTotalTime/60).toFixed(1)}h > ${(maxMinutes/60).toFixed(1)}h), ë‹¤ìŒ ë‚ ë¡œ`);
                        
                        const firstVisit = currentDayVisits[0];
                        const lastVisit = currentDayVisits[currentDayVisits.length - 1];
                        
                        const toFirst = await getKakaoRoute(start.y, start.x, firstVisit.lat, firstVisit.lng);
                        const toStart = await getKakaoRoute(lastVisit.lat, lastVisit.lng, start.y, start.x);
                        
                        schedule.push({
                            day: currentDay,
                            visits: currentDayVisits,
                            departureTime: toFirst.duration,
                            returnTime: toStart.duration
                        });
                        
                        currentDay++;
                        currentDayVisits = [];
                        currentPosition = start;
                        continue;
                    }
                    
                    // ì—…ì²´ëª… ì¶”ì¶œ
                    const companyName = (companyColumn >= 0 && nearest[companyColumn]) ? nearest[companyColumn] : '';
                    
                    currentDayVisits.push({
                        address: nearest[selectedColumn] || nearest[0],
                        company: companyName,
                        lat, lng,
                        distance: nearestDistance.toFixed(2),
                        travelTime: minDuration.toFixed(0),
                        time: estimatedTime.toFixed(0),
                        data: nearest
                    });
                    
                    console.log(`    â• ${nearest[selectedColumn]?.substring(0, 30)} (${nearestDistance.toFixed(1)}km)`);
                    
                    currentPosition = { x: lng, y: lat };
                    remainingInGroup.splice(nearestIdx, 1);
                    totalProcessed++;
                }
                
                console.log(`  âœ… ${group.name} ì™„ë£Œ (${group.locations.length}ê°œ ì²˜ë¦¬)`);
            }
            
            if (currentDayVisits.length > 0) {
                const firstVisit = currentDayVisits[0];
                const lastVisit = currentDayVisits[currentDayVisits.length - 1];
                
                const toFirst = await getKakaoRoute(start.y, start.x, firstVisit.lat, firstVisit.lng);
                const toStart = await getKakaoRoute(lastVisit.lat, lastVisit.lng, start.y, start.x);
                
                schedule.push({
                    day: currentDay,
                    visits: currentDayVisits,
                    departureTime: toFirst.duration,
                    returnTime: toStart.duration
                });
                
                console.log(`  âœ… ${currentDay}ì¼ì°¨ ì™„ë£Œ (ë§ˆì§€ë§‰)`);
            }
            
            // ğŸ†• ì¼ì • ì¬ì¡°ì •: 50% ë¯¸ë§Œì¸ ë‚ ì€ 20km ì´ë‚´ ë‹¤ë¥¸ ë‚ ê³¼ ë³‘í•©
            console.log(`\nğŸ”„ === ì¼ì • ì¬ì¡°ì • ì‹œì‘ ===`);
            schedule = await rebalanceSchedule(schedule, maxVisits, start);
            
            return schedule;
        }
        
        async function rebalanceSchedule(schedule, maxVisits, start) {
            const threshold = Math.floor(maxVisits * 0.5);
            console.log(`\nğŸ”„ === ì¼ì • ì¬ì¡°ì • ì‹œì‘ ===`);
            console.log(`ì¬ì¡°ì • ê¸°ì¤€: ${threshold}ê°œ ì´í•˜`);
            console.log(`í˜„ì¬ ì¼ì •: ${schedule.length}ì¼`);
            
            // ê° ë‚ ì§œì˜ ë°©ë¬¸ ìˆ˜ ì¶œë ¥
            schedule.forEach(day => {
                const status = day.visits.length <= threshold ? 'â—ì¬ì¡°ì • ëŒ€ìƒ' : 'âœ…ì •ìƒ';
                console.log(`  ${day.day}ì¼ì°¨: ${day.visits.length}ê°œ ${status}`);
            });
            
            let changed = true;
            let iterations = 0;
            const maxIterations = 5;
            
            while (changed && iterations < maxIterations) {
                changed = false;
                iterations++;
                console.log(`\nğŸ”„ ì¬ì¡°ì • ${iterations}íšŒì°¨ ì‹œì‘`);
                
                // ì¬ì¡°ì • ëŒ€ìƒ ì°¾ê¸° (ë°©ë¬¸ ìˆ˜ê°€ ì ì€ ìˆœìœ¼ë¡œ ì •ë ¬)
                const sortedDays = schedule
                    .map((day, idx) => ({ day, originalIdx: idx }))
                    .filter(item => item.day.visits.length <= threshold)
                    .sort((a, b) => a.day.visits.length - b.day.visits.length);
                
                if (sortedDays.length === 0) {
                    console.log('  âœ… ì¬ì¡°ì • ëŒ€ìƒ ì—†ìŒ');
                    break;
                }
                
                console.log(`  ì¬ì¡°ì • ëŒ€ìƒ: ${sortedDays.length}ì¼`);
                
                for (const { day: sourceDay, originalIdx: sourceIdx } of sortedDays) {
                    console.log(`\n  ğŸ“Œ ${sourceDay.day}ì¼ì°¨ ì²˜ë¦¬ (${sourceDay.visits.length}ê°œ)`);
                    
                    // ì†ŒìŠ¤ ë‚ ì§œì˜ ì¤‘ì‹¬ì  ê³„ì‚°
                    const sourceCenter = calculateCenter(sourceDay.visits);
                    
                    // ë³‘í•© ê°€ëŠ¥í•œ ë‚  ì°¾ê¸°
                    let bestTarget = null;
                    let bestDistance = Infinity;
                    
                    for (let j = 0; j < schedule.length; j++) {
                        if (j === sourceIdx) continue;
                        
                        const targetDay = schedule[j];
                        
                        // ìš©ëŸ‰ ì²´í¬
                        if (targetDay.visits.length + sourceDay.visits.length > maxVisits) {
                            console.log(`    â­ï¸ ${targetDay.day}ì¼ì°¨: ìš©ëŸ‰ ì´ˆê³¼ (${targetDay.visits.length} + ${sourceDay.visits.length} > ${maxVisits})`);
                            continue;
                        }
                        
                        // íƒ€ê²Ÿ ë‚ ì§œì˜ ì¤‘ì‹¬ì  ê³„ì‚°
                        const targetCenter = calculateCenter(targetDay.visits);
                        
                        // ì¤‘ì‹¬ì  ê°„ ê±°ë¦¬
                        const centerDistance = calculateDistance(
                            sourceCenter.lat, sourceCenter.lng,
                            targetCenter.lat, targetCenter.lng
                        );
                        
                        console.log(`    ğŸ“ ${targetDay.day}ì¼ì°¨: ì¤‘ì‹¬ì  ê±°ë¦¬ ${centerDistance.toFixed(1)}km (ìš©ëŸ‰: ${targetDay.visits.length}/${maxVisits})`);
                        
                        // ì¤‘ì‹¬ì ì´ 30km ì´ë‚´ì´ê³  ê°€ì¥ ê°€ê¹Œìš´ ë‚  ì„ íƒ
                        if (centerDistance <= 30 && centerDistance < bestDistance) {
                            // ì‹¤ì œ ê±°ë¦¬ë¡œ ì¬í™•ì¸ (ê°€ì¥ ë¨¼ ë‘ ì§€ì  ê°„ ê±°ë¦¬)
                            const maxPairDistance = getMaxPairDistance(sourceDay.visits, targetDay.visits);
                            
                            if (maxPairDistance <= 40) {  // 40km ì´ë‚´ë©´ ë³‘í•© ê°€ëŠ¥
                                bestTarget = j;
                                bestDistance = centerDistance;
                                console.log(`      âœ… ë³‘í•© í›„ë³´ (ìµœëŒ€ ê±°ë¦¬: ${maxPairDistance.toFixed(1)}km)`);
                            } else {
                                console.log(`      âŒ ìµœëŒ€ ê±°ë¦¬ ì´ˆê³¼: ${maxPairDistance.toFixed(1)}km > 40km`);
                            }
                        } else if (centerDistance > 30) {
                            console.log(`      âŒ ì¤‘ì‹¬ì  ê±°ë¦¬ ì´ˆê³¼`);
                        }
                    }
                    
                    if (bestTarget !== null) {
                        const targetDay = schedule[bestTarget];
                        console.log(`\n    ğŸ¯ ${sourceDay.day}ì¼ì°¨ â†’ ${targetDay.day}ì¼ì°¨ ë³‘í•© ì‹¤í–‰`);
                        
                        // ë³‘í•©
                        targetDay.visits.push(...sourceDay.visits);
                        
                        console.log(`      ë³‘í•© ì „ ìˆœì„œ ìµœì í™” ì¤‘...`);
                        // ë³‘í•©ëœ ë‚ ì„ ìµœì í™” (ê°€ê¹Œìš´ ìˆœì„œë¡œ ì¬ì •ë ¬)
                        targetDay.visits = await reorderVisits(targetDay.visits, start);
                        
                        // ì¶œë°œ/ê·€ê°€ ì‹œê°„ ì¬ê³„ì‚°
                        const firstVisit = targetDay.visits[0];
                        const lastVisit = targetDay.visits[targetDay.visits.length - 1];
                        const toFirst = await getKakaoRoute(start.y, start.x, firstVisit.lat, firstVisit.lng);
                        const toStart = await getKakaoRoute(lastVisit.lat, lastVisit.lng, start.y, start.x);
                        targetDay.departureTime = toFirst.duration;
                        targetDay.returnTime = toStart.duration;
                        
                        // ë¹ˆ ë‚  ì œê±°
                        schedule.splice(sourceIdx, 1);
                        
                        // ì¼ì°¨ ë²ˆí˜¸ ì¬ì¡°ì •
                        schedule.forEach((d, idx) => d.day = idx + 1);
                        
                        changed = true;
                        console.log(`      âœ… ë³‘í•© ì™„ë£Œ! (${targetDay.visits.length}ê°œ)`);
                        break;
                    } else {
                        console.log(`    âŒ ë³‘í•© ê°€ëŠ¥í•œ ë‚ ì§œ ì—†ìŒ`);
                    }
                }
                
                if (!changed) {
                    console.log('\n  â„¹ï¸ ë” ì´ìƒ ë³‘í•©í•  ë‚ ì§œ ì—†ìŒ');
                }
            }
            
            console.log(`\nâœ… ì¬ì¡°ì • ì™„ë£Œ: ${schedule.length}ì¼ ì¼ì •`);
            console.log(`ğŸ“Š ìºì‹œ íˆíŠ¸: ${routeCache.size}ê°œ ê²½ë¡œ ì €ì¥ë¨`);
            
            // ìµœì¢… ê²°ê³¼ ì¶œë ¥
            console.log('\nğŸ“‹ ìµœì¢… ì¼ì •:');
            schedule.forEach(day => {
                console.log(`  ${day.day}ì¼ì°¨: ${day.visits.length}ê°œ ë°©ë¬¸`);
            });
            
            return schedule;
        }
        
        function calculateCenter(visits) {
            const sumLat = visits.reduce((sum, v) => sum + parseFloat(v.lat), 0);
            const sumLng = visits.reduce((sum, v) => sum + parseFloat(v.lng), 0);
            return {
                lat: sumLat / visits.length,
                lng: sumLng / visits.length
            };
        }
        
        function getMaxPairDistance(visits1, visits2) {
            let maxDist = 0;
            
            for (const v1 of visits1) {
                for (const v2 of visits2) {
                    const dist = calculateDistance(
                        parseFloat(v1.lat), parseFloat(v1.lng),
                        parseFloat(v2.lat), parseFloat(v2.lng)
                    );
                    if (dist > maxDist) maxDist = dist;
                }
            }
            
            return maxDist;
        }
        
        async function reorderVisits(visits, start) {
            // Greedy ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ë°©ë¬¸ ìˆœì„œ ìµœì í™”
            const ordered = [];
            const remaining = [...visits];
            let currentPos = start;
            
            while (remaining.length > 0) {
                // ğŸš€ ì§ì„  ê±°ë¦¬ë¡œ ê°€ê¹Œìš´ 5ê°œë§Œ ì„ íƒ
                const candidates = remaining
                    .map((visit, idx) => {
                        const straightDist = calculateDistance(
                            parseFloat(currentPos.y), parseFloat(currentPos.x),
                            parseFloat(visit.lat), parseFloat(visit.lng)
                        );
                        return { idx, visit, straightDist };
                    })
                    .sort((a, b) => a.straightDist - b.straightDist)
                    .slice(0, Math.min(5, remaining.length));
                
                // ğŸš€ ë³‘ë ¬ë¡œ ê²½ë¡œ ê³„ì‚°
                const routePromises = candidates.map(async (candidate) => {
                    const route = await getKakaoRoute(
                        parseFloat(currentPos.y), 
                        parseFloat(currentPos.x),
                        parseFloat(candidate.visit.lat), 
                        parseFloat(candidate.visit.lng)
                    );
                    return { ...candidate, route };
                });
                
                const routeResults = await Promise.all(routePromises);
                
                // ê°€ì¥ ê°€ê¹Œìš´ ê²ƒ ì„ íƒ
                let bestResult = routeResults[0];
                for (const result of routeResults) {
                    if (result.route.distance < bestResult.route.distance) {
                        bestResult = result;
                    }
                }
                
                const nearest = remaining.splice(bestResult.idx, 1)[0];
                
                // ê±°ë¦¬/ì‹œê°„ ì—…ë°ì´íŠ¸
                nearest.distance = bestResult.route.distance.toFixed(2);
                nearest.travelTime = bestResult.route.duration.toFixed(0);
                const avgStay = parseInt(document.getElementById('avgStay').value) || 30;
                nearest.time = (bestResult.route.duration + avgStay).toFixed(0);
                
                ordered.push(nearest);
                currentPos = { y: nearest.lat, x: nearest.lng };
            }
            
            return ordered;
        }
        
        async function getKakaoRoute(startLat, startLng, endLat, endLng) {
            // ğŸ”§ íƒ€ì… ì•ˆì „ì„±: ìˆ«ìë¡œ ë³€í™˜
            startLat = parseFloat(startLat);
            startLng = parseFloat(startLng);
            endLat = parseFloat(endLat);
            endLng = parseFloat(endLng);
            
            // ìœ íš¨ì„± ê²€ì‚¬
            if (isNaN(startLat) || isNaN(startLng) || isNaN(endLat) || isNaN(endLng)) {
                console.error('Invalid coordinates:', { startLat, startLng, endLat, endLng });
                return { duration: 0, distance: 0 };
            }
            
            // ğŸš€ ìºì‹œ í‚¤ ìƒì„± (ì†Œìˆ˜ì  4ìë¦¬ë¡œ ë°˜ì˜¬ë¦¼)
            const cacheKey = `${startLat.toFixed(4)},${startLng.toFixed(4)}-${endLat.toFixed(4)},${endLng.toFixed(4)}`;
            
            // ìºì‹œì— ìˆìœ¼ë©´ ì¦‰ì‹œ ë°˜í™˜
            if (routeCache.has(cacheKey)) {
                return routeCache.get(cacheKey);
            }
            
            try {
                const url = `https://apis-navi.kakaomobility.com/v1/directions?origin=${startLng},${startLat}&destination=${endLng},${endLat}&priority=RECOMMEND`;
                const response = await fetch(url, {
                    headers: { 'Authorization': 'KakaoAK e7993bf34b2b04dcdeaf01bb36f06a85' }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    
                    // ğŸ”§ ê¸°ë³¸ êµ¬ì¡° í™•ì¸
                    if (data && data.routes && data.routes.length > 0) {
                        const route = data.routes[0];
                        
                        // summary ì¡´ì¬ ì—¬ë¶€ í™•ì¸
                        if (route.summary) {
                            const duration = route.summary.duration;
                            const distance = route.summary.distance;
                            
                            // ê°’ì´ ìœ íš¨í•œì§€ í™•ì¸
                            if (typeof duration === 'number' && typeof distance === 'number' && 
                                !isNaN(duration) && !isNaN(distance)) {
                                
                                const result = {
                                    duration: Math.round(duration / 60),
                                    distance: distance / 1000
                                };
                                
                                // ìºì‹œì— ì €ì¥
                                routeCache.set(cacheKey, result);
                                return result;
                            } else {
                                console.warn('Invalid duration/distance values:', { duration, distance });
                            }
                        } else {
                            console.warn('No summary in route:', route);
                        }
                    } else {
                        console.warn('No routes in response:', data);
                    }
                } else {
                    console.warn(`API response not ok: ${response.status} ${response.statusText}`);
                }
            } catch (error) {
                console.warn('Route API error:', error.message);
            }
            
            // API ì‹¤íŒ¨ ì‹œ ì§ì„  ê±°ë¦¬ë¡œ ì¶”ì •
            const distance = calculateDistance(startLat, startLng, endLat, endLng);
            const result = { 
                duration: Math.round((distance / 40) * 60), 
                distance 
            };
            
            // ì¶”ì •ê°’ë„ ìºì‹œì— ì €ì¥
            routeCache.set(cacheKey, result);
            return result;
        }
        
        function calculateDistance(lat1, lon1, lat2, lon2) {
            // ğŸ”§ íƒ€ì… ì•ˆì „ì„±: ìˆ«ìë¡œ ë³€í™˜
            lat1 = parseFloat(lat1);
            lon1 = parseFloat(lon1);
            lat2 = parseFloat(lat2);
            lon2 = parseFloat(lon2);
            
            if (isNaN(lat1) || isNaN(lon1) || isNaN(lat2) || isNaN(lon2)) {
                return 0;
            }
            
            const R = 6371;
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        function displaySchedule(schedule) {
            let html = '<div class="route-list">';
            
            schedule.forEach(day => {
                const totalDistance = day.visits.reduce((s, v) => s + parseFloat(v.distance), 0);
                const travelTime = day.visits.reduce((s, v) => s + parseFloat(v.travelTime), 0);
                const avgStay = parseInt(document.getElementById('avgStay').value);
                const totalTime = travelTime + (day.departureTime || 0) + (day.returnTime || 0) + (day.visits.length * avgStay);
                const color = dayColors[(day.day - 1) % dayColors.length];
                
                html += `
                    <div class="day-schedule" style="border-top: 5px solid ${color};">
                        <h3>
                            <span style="background: ${color}; color: white; padding: 8px 15px; border-radius: 8px;">
                                ${day.day}ì¼ì°¨
                            </span>
                        </h3>
                        
                        <div class="day-stats">
                            <div class="stat-card">
                                <div class="label">ë°©ë¬¸ ì—…ì²´</div>
                                <div class="value">${day.visits.length}ê°œ</div>
                            </div>
                            <div class="stat-card">
                                <div class="label">ì´ ê±°ë¦¬</div>
                                <div class="value">${totalDistance.toFixed(1)}km</div>
                            </div>
                            <div class="stat-card">
                                <div class="label">ì´ë™ ì‹œê°„</div>
                                <div class="value">${Math.round(travelTime)}ë¶„</div>
                            </div>
                            <div class="stat-card">
                                <div class="label">ì´ ì†Œìš”ì‹œê°„</div>
                                <div class="value">${(totalTime/60).toFixed(1)}ì‹œê°„</div>
                            </div>
                        </div>
                        
                        <div class="timeline">
                            <div class="timeline-item">
                                <div class="timeline-icon start">ğŸ </div>
                                <div class="timeline-content start-point">
                                    <div class="timeline-info">
                                        <div class="timeline-title">${startLocationName}</div>
                                    </div>
                                </div>
                            </div>
                `;
                
                day.visits.forEach((visit, index) => {
                    html += `
                        <div class="timeline-item">
                            <div class="timeline-icon visit" style="background: ${color};">${index + 1}</div>
                            <div class="timeline-content">
                                <div class="timeline-info">
                                    ${visit.company ? `<div class="timeline-company">${visit.company}</div>` : ''}
                                    <div class="timeline-title">${visit.address}</div>
                                </div>
                                <div class="travel-info">
                                    <span>ğŸš— ${visit.travelTime}ë¶„</span>
                                    <span>ğŸ“ ${visit.distance}km</span>
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                html += `
                        <div class="timeline-item">
                            <div class="timeline-icon end">ğŸ</div>
                            <div class="timeline-content end-point">
                                <div class="timeline-info">
                                    <div class="timeline-title">ê·€ê°€</div>
                                </div>
                                <div class="travel-info">
                                    <span>ğŸš— ${day.returnTime}ë¶„</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                `;
            });
            
            html += '</div>';
            document.getElementById('routeResult').innerHTML = html;
        }
        
        function displayMarkersOnMap(schedule, start) {
            if (!map) return;
            
            // ê¸°ì¡´ ë§ˆì»¤ ì œê±°
            markers.forEach(marker => {
                try {
                    if (marker && marker.setMap) {
                        marker.setMap(null);
                    }
                } catch (e) {
                    console.log('ë§ˆì»¤ ì œê±° ì¤‘ ì˜¤ë¥˜:', e);
                }
            });
            markers = [];
            
            const bounds = new kakao.maps.LatLngBounds();
            
            // ì¶œë°œì§€ ë§ˆì»¤
            try {
                const startPos = new kakao.maps.LatLng(parseFloat(start.y), parseFloat(start.x));
                const startMarker = new kakao.maps.Marker({
                    position: startPos,
                    map: map,
                    image: new kakao.maps.MarkerImage(
                        'https://t1.daumcdn.net/localimg/localimages/07/mapapidoc/markerStar.png',
                        new kakao.maps.Size(24, 35)
                    )
                });
                
                const startInfowindow = new kakao.maps.InfoWindow({
                    content: '<div style="padding:5px;font-size:12px;">ğŸ  ì¶œë°œì§€</div>'
                });
                startInfowindow.open(map, startMarker);
                markers.push(startMarker);
                bounds.extend(startPos);
            } catch (e) {
                console.error('ì¶œë°œì§€ ë§ˆì»¤ ìƒì„± ì˜¤ë¥˜:', e);
            }
            
            // ë°©ë¬¸ì§€ ë§ˆì»¤ ë° ê²½ë¡œì„ 
            schedule.forEach((day) => {
                const color = dayColors[(day.day - 1) % dayColors.length];
                
                day.visits.forEach((visit, visitIndex) => {
                    try {
                        const lat = parseFloat(visit.lat);
                        const lng = parseFloat(visit.lng);
                        
                        if (isNaN(lat) || isNaN(lng)) {
                            console.warn(`ìœ íš¨í•˜ì§€ ì•Šì€ ì¢Œí‘œ: ${visit.address}`);
                            return;
                        }
                        
                        const position = new kakao.maps.LatLng(lat, lng);
                        
                        // ê²½ë¡œì„  ê·¸ë¦¬ê¸°
                        if (visitIndex > 0) {
                            const prevVisit = day.visits[visitIndex - 1];
                            const prevLat = parseFloat(prevVisit.lat);
                            const prevLng = parseFloat(prevVisit.lng);
                            
                            if (!isNaN(prevLat) && !isNaN(prevLng)) {
                                const polyline = new kakao.maps.Polyline({
                                    path: [
                                        new kakao.maps.LatLng(prevLat, prevLng),
                                        position
                                    ],
                                    strokeWeight: 3,
                                    strokeColor: color,
                                    strokeOpacity: 0.7
                                });
                                polyline.setMap(map);
                                markers.push(polyline);
                            }
                        }
                        
                        // ğŸ¨ ìƒ‰ìƒ ìˆëŠ” ì»¤ìŠ¤í…€ ë§ˆì»¤ ìƒì„±
                        const markerContent = document.createElement('div');
                        markerContent.style.cssText = `
                            width: 36px;
                            height: 36px;
                            background: ${color};
                            border: 3px solid white;
                            border-radius: 50%;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-weight: bold;
                            color: white;
                            font-size: 14px;
                            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
                            cursor: pointer;
                            position: relative;
                        `;
                        markerContent.textContent = visitIndex + 1;
                        
                        // ì»¤ìŠ¤í…€ ì˜¤ë²„ë ˆì´ ìƒì„±
                        const customOverlay = new kakao.maps.CustomOverlay({
                            position: position,
                            content: markerContent,
                            yAnchor: 0.5,
                            zIndex: 3
                        });
                        
                        customOverlay.setMap(map);
                        
                        // ì¸í¬ìœˆë„ìš° ìƒì„±
                        const infoContent = visit.company 
                            ? `<div style="padding:8px;font-size:12px;min-width:150px;">
                                <strong style="color:${color};">${day.day}ì¼ì°¨-${visitIndex + 1}</strong><br>
                                <strong>${visit.company}</strong><br>
                                ${visit.address}<br>
                                <small>ğŸš— ${visit.travelTime}ë¶„ | ğŸ“ ${visit.distance}km</small>
                            </div>`
                            : `<div style="padding:8px;font-size:12px;min-width:150px;">
                                <strong style="color:${color};">${day.day}ì¼ì°¨-${visitIndex + 1}</strong><br>
                                ${visit.address}<br>
                                <small>ğŸš— ${visit.travelTime}ë¶„ | ğŸ“ ${visit.distance}km</small>
                            </div>`;
                        
                        const infowindow = new kakao.maps.InfoWindow({
                            content: infoContent,
                            removable: false
                        });
                        
                        // ë§ˆì»¤ í´ë¦­ ì´ë²¤íŠ¸
                        markerContent.addEventListener('click', function() {
                            // ê¸°ì¡´ ì—´ë¦° ì¸í¬ìœˆë„ìš° ëª¨ë‘ ë‹«ê¸°
                            markers.forEach(m => {
                                if (m.infowindow && m.infowindow.close) {
                                    m.infowindow.close();
                                }
                            });
                            
                            // ì„ì‹œ ë§ˆì»¤ ìœ„ì¹˜ ìƒì„± (ì¸í¬ìœˆë„ìš° í‘œì‹œìš©)
                            const tempMarker = new kakao.maps.Marker({
                                position: position,
                                map: null
                            });
                            
                            infowindow.open(map, tempMarker);
                            
                            // 3ì´ˆ í›„ ìë™ ë‹«ê¸°
                            setTimeout(() => {
                                infowindow.close();
                            }, 3000);
                        });
                        
                        markers.push({
                            overlay: customOverlay,
                            infowindow: infowindow,
                            setMap: function(m) {
                                if (this.overlay) this.overlay.setMap(m);
                            }
                        });
                        
                        bounds.extend(position);
                        
                    } catch (e) {
                        console.error(`ë§ˆì»¤ ìƒì„± ì˜¤ë¥˜ (${visit.address}):`, e);
                    }
                });
            });
            
            // ì§€ë„ ë²”ìœ„ ì¡°ì •
            try {
                map.setBounds(bounds);
            } catch (e) {
                console.error('ì§€ë„ ë²”ìœ„ ì¡°ì • ì˜¤ë¥˜:', e);
            }
        }
        
        function downloadScheduleExcel() {
            if (!finalSchedule || !convertedData) return;
            
            console.log('\nğŸ“¥ === ì¼ì • íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì‹œì‘ ===');
            console.log(`convertedData í–‰ ìˆ˜: ${convertedData.length} (í—¤ë” í¬í•¨)`);
            console.log(`ë°ì´í„° í–‰ ìˆ˜: ${convertedData.length - 1}`);
            
            // ì›ë³¸ ë°ì´í„° ë³µì‚¬ (í–‰ ìˆœì„œ ìœ ì§€)
            const scheduleData = convertedData.map(row => [...row]);
            
            // í—¤ë”ì— "ì¼ì •" ì—´ ì¶”ê°€
            scheduleData[0].push('ì¼ì •');
            
            // ì¼ì • ë§¤í•‘ ìƒì„±
            const scheduleMap = new Map();
            const usedRows = new Set();  // ì´ë¯¸ ì‚¬ìš©ëœ í–‰ ì¶”ì 
            let totalScheduledVisits = 0;
            
            finalSchedule.forEach(day => {
                day.visits.forEach((visit, idx) => {
                    totalScheduledVisits++;
                    
                    // ì›ë³¸ ë°ì´í„°ì˜ í–‰ ë²ˆí˜¸ ì°¾ê¸° (ìœ„ë„/ê²½ë„ë¡œ ë§¤ì¹­, ì•„ì§ ì‚¬ìš©ë˜ì§€ ì•Šì€ í–‰ë§Œ)
                    for (let i = 1; i < convertedData.length; i++) {
                        // ì´ë¯¸ ì‚¬ìš©ëœ í–‰ì€ ìŠ¤í‚µ
                        if (usedRows.has(i)) continue;
                        
                        const row = convertedData[i];
                        const rowLat = parseFloat(row[row.length - 2]);
                        const rowLng = parseFloat(row[row.length - 1]);
                        
                        if (isNaN(rowLat) || isNaN(rowLng)) continue;
                        
                        if (Math.abs(rowLat - visit.lat) < 0.0001 && 
                            Math.abs(rowLng - visit.lng) < 0.0001) {
                            
                            const scheduleLabel = `Day${day.day}-${idx + 1}`;
                            scheduleMap.set(i, scheduleLabel);
                            usedRows.add(i);  // ì‚¬ìš©ëœ í–‰ìœ¼ë¡œ í‘œì‹œ
                            console.log(`  ë§¤ì¹­: í–‰${i} â†’ ${scheduleLabel} (${visit.address?.substring(0, 30)}...)`);
                            break;
                        }
                    }
                });
            });
            
            console.log(`\nì´ ìŠ¤ì¼€ì¤„ëœ ë°©ë¬¸: ${totalScheduledVisits}ê°œ`);
            console.log(`ë§¤ì¹­ëœ í–‰: ${scheduleMap.size}ê°œ`);
            
            if (totalScheduledVisits !== scheduleMap.size) {
                console.warn(`âš ï¸ ë§¤ì¹­ ëˆ„ë½: ${totalScheduledVisits - scheduleMap.size}ê°œ`);
            }
            
            // ì›ë³¸ ìˆœì„œëŒ€ë¡œ ì¼ì • ì •ë³´ ì¶”ê°€
            let addedCount = 0;
            for (let i = 1; i < scheduleData.length; i++) {
                const scheduleLabel = scheduleMap.get(i) || '';
                scheduleData[i].push(scheduleLabel);
                if (scheduleLabel) {
                    addedCount++;
                }
            }
            
            console.log(`ì¼ì •ì´ ì¶”ê°€ëœ í–‰: ${addedCount}ê°œ`);
            console.log(`ì²˜ë¦¬ëœ ì „ì²´ í–‰: ${scheduleData.length - 1}ê°œ (í—¤ë” ì œì™¸)`);
            
            const ws = XLSX.utils.aoa_to_sheet(scheduleData);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'ì¼ì •í‘œ');
            XLSX.writeFile(wb, 'ì¶œì¥ì¼ì •_' + new Date().toISOString().slice(0,10) + '.xlsx');
            
            console.log('\nâœ… ì¼ì • íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì™„ë£Œ');
        }
    </script>
</body>
</html>
