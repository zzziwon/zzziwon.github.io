<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì¶œì¥ ê³„íš ìˆ˜ë¦½ ì—…ë¬´ ìë™í™” í”„ë¡¬í”„íŠ¸</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=0c62e9a12c740ee7f1620f92ec4659bf&libraries=services"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #e3f2fd 0%, #f0f9ff 50%, #f5fffa 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #a0e65f 0%, #5ec9ff 50%, #3fa8e0 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .content {
            padding: 30px;
        }
        
        .section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        
        .section h2 {
            color: #3fa8e0;
            margin-bottom: 20px;
            font-size: 1.5em;
            border-bottom: 3px solid #a0e65f;
            padding-bottom: 10px;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }
        
        .input-group input, .input-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }
        
        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #5ec9ff;
        }
        
        .input-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        
        button {
            background: linear-gradient(135deg, #3fa8e0 0%, #5ec9ff 50%, #a0e65f 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(63, 168, 224, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            background: #999;
            cursor: not-allowed;
            transform: none;
        }
        
        .file-upload {
            border: 3px dashed #a0e65f;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .file-upload:hover {
            background: #f0fff4;
        }
        
        .file-upload input[type="file"] {
            display: none;
        }
        
        .status {
            margin-top: 15px;
            padding: 12px;
            border-radius: 8px;
            font-weight: 500;
        }
        
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        #map {
            width: 100%;
            height: 600px;
            border-radius: 12px;
            margin-top: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e0e0e0;
            border-radius: 15px;
            overflow: hidden;
            margin: 15px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3fa8e0 0%, #5ec9ff 50%, #a0e65f 100%);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
        }
        
        .route-list {
            margin-top: 20px;
        }
        
        .day-schedule {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
        }
        
        .day-schedule h3 {
            color: #3fa8e0;
            margin-bottom: 15px;
        }
        
        .visit-item {
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 10px;
        }
        
        .visit-item:hover {
            background: #e9ecef;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .conversion-stats {
            display: flex;
            gap: 20px;
            margin: 15px 0;
            flex-wrap: wrap;
        }
        
        .stat-box {
            flex: 1;
            min-width: 150px;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        
        .stat-box.success {
            background: #d1fae5;
            border: 2px solid #a0e65f;
        }
        
        .stat-box.fail {
            background: #fee2e2;
            border: 2px solid #ef4444;
        }
        
        .stat-box.total {
            background: #dbeafe;
            border: 2px solid #5ec9ff;
        }
        
        .stat-number {
            font-size: 2em;
            font-weight: bold;
            margin: 5px 0;
        }
        
        .stat-label {
            font-size: 0.9em;
            color: #666;
        }
        
        .legend {
            display: flex;
            gap: 15px;
            margin: 15px 0;
            flex-wrap: wrap;
            padding: 15px;
            background: white;
            border-radius: 8px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }
        
        .footer {
            background: #6c757d;
            color: white;
            text-align: center;
            padding: 20px;
            font-size: 0.9em;
        }
        
        .footer a {
            color: #5ec9ff;
            text-decoration: none;
        }
        
        .footer a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸš— ë”°ë¼ì™€</h1>
            <p>ì¶œì¥ ê³„íš ìˆ˜ë¦½ ì—…ë¬´ ìë™í™” í”„ë¡¬í”„íŠ¸</p>
        </div>
        
        <div class="content">
            <div class="section">
                <h2>ğŸ“ 1ë‹¨ê³„: ì—‘ì…€ íŒŒì¼ ì—…ë¡œë“œ ë° ì£¼ì†Œ ë³€í™˜</h2>
                <div class="file-upload" onclick="document.getElementById('excelFile').click()">
                    <p style="font-size: 1.2em; margin-bottom: 10px;">ğŸ“¤ í´ë¦­í•˜ì—¬ ì—‘ì…€ íŒŒì¼ ì—…ë¡œë“œ</p>
                    <p style="color: #666;">ì£¼ì†Œê°€ í¬í•¨ëœ ì—‘ì…€ íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”</p>
                    <input type="file" id="excelFile" accept=".xlsx,.xls" onchange="handleFileUpload(event)">
                </div>
                <div id="uploadStatus"></div>
                
                <div id="previewSection" style="display: none;">
                    <div class="input-group" style="margin-top: 20px;">
                        <label>ì£¼ì†Œê°€ í¬í•¨ëœ ì—´ì„ ì„ íƒí•˜ì„¸ìš”</label>
                        <select id="addressColumn">
                            <option value="">-- ì£¼ì†Œ ì—´ ì„ íƒ --</option>
                        </select>
                    </div>
                </div>
                
                <div id="conversionStats" style="display: none;">
                    <div class="conversion-stats">
                        <div class="stat-box total">
                            <div class="stat-label">ì „ì²´</div>
                            <div class="stat-number" id="totalCount">0</div>
                        </div>
                        <div class="stat-box success">
                            <div class="stat-label">âœ… ì„±ê³µ</div>
                            <div class="stat-number" id="successCount">0</div>
                        </div>
                        <div class="stat-box fail">
                            <div class="stat-label">âŒ ì‹¤íŒ¨</div>
                            <div class="stat-number" id="failCount">0</div>
                        </div>
                    </div>
                    <div id="currentAddress" style="padding: 10px; background: #d1fae5; border-radius: 8px; margin-top: 10px; border-left: 4px solid #a0e65f;"></div>
                </div>
                
                <div id="progressBar" style="display: none;">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill">0%</div>
                    </div>
                </div>
                <div class="button-group" style="margin-top: 20px;">
                    <button id="convertBtn" onclick="convertAddresses()" disabled>ğŸ”„ ì£¼ì†Œ ë³€í™˜ ì‹œì‘</button>
                    <button id="downloadBtn" onclick="downloadExcel()" disabled>ğŸ’¾ ë³€í™˜ëœ íŒŒì¼ ë‹¤ìš´ë¡œë“œ</button>
                </div>
            </div>
            
            <div class="section">
                <h2>ğŸ“… 2ë‹¨ê³„: ë°©ë¬¸ ì¼ì • ì„¤ì •</h2>
                <div class="input-row">
                    <div class="input-group">
                        <label>ì¼ì¼ ìµœëŒ€ ì—…ë¬´ì‹œê°„ (ì‹œê°„)</label>
                        <input type="number" id="maxHours" value="8" min="1" max="24">
                    </div>
                    <div class="input-group">
                        <label>ì¼ì¼ ë°©ë¬¸ ì—…ì²´ìˆ˜ (ê°œ)</label>
                        <input type="number" id="maxVisits" value="5" min="1" max="20">
                    </div>
                    <div class="input-group">
                        <label>í‰ê·  ì²´ë¥˜ì‹œê°„ (ë¶„)</label>
                        <input type="number" id="avgStay" value="30" min="5" max="180">
                    </div>
                </div>
                <div class="input-group">
                    <label>ì¶œë°œì§€ ì£¼ì†Œ</label>
                    <input type="text" id="startAddress" value="ê²½ê¸°ë„ ì„±ë‚¨ì‹œ ë¶„ë‹¹êµ¬ ì¥ë¯¸ë¡œ 42">
                </div>
                <button id="optimizeBtn" onclick="optimizeRoute()" disabled>ğŸ¯ ê²½ë¡œ ìµœì í™” ì‹¤í–‰</button>
                <div id="optimizeStatus"></div>
                
                <div id="optimizeProgress" style="display: none;">
                    <div style="padding: 15px; background: #e3f2fd; border-radius: 8px; margin-top: 15px; border-left: 4px solid #5ec9ff;">
                        <div id="optimizeCurrentCity" style="font-weight: bold; margin-bottom: 10px;"></div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="optimizeProgressFill">0%</div>
                        </div>
                        <div id="optimizeDetail" style="margin-top: 10px; font-size: 0.9em; color: #666;"></div>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h2>ğŸ—ºï¸ 3ë‹¨ê³„: ìµœì í™”ëœ ê²½ë¡œ</h2>
                <div id="scheduleButtons" style="display: none; margin-bottom: 15px;">
                    <button onclick="downloadScheduleExcel()">ğŸ“¥ ì¼ì • íŒŒì¼ ë‹¤ìš´ë¡œë“œ</button>
                </div>
                <!-- ì¼ì°¨ë³„ ìƒ‰ìƒ í‘œê¸° ìˆ¨ê¹€
                <div id="legendSection" style="display: none;">
                    <div class="legend" id="legend"></div>
                </div>
                -->
                <div id="routeResult"></div>
                <div id="map"></div>
            </div>
        </div>
        
        <div class="footer">
            <p>Â© 2025 ë”°ë¼ì™€. All rights reserved.</p>
            <p>Developed by <strong>BTS</strong> (Business Trip Secretary)</p>
        </div>
    </div>

    <script>
        let uploadedData = [];
        let convertedData = [];
        let map = null;
        let markers = [];
        let geocoder = null;
        let startPoint = null;
        let selectedColumn = 0;
        let finalSchedule = null;
        
        // ğŸš€ ê²½ë¡œ ìºì‹œ ì¶”ê°€ (ì†ë„ ê°œì„ )
        const routeCache = new Map();
        
        const dayColors = [
            '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8',
            '#F06292', '#BA68C8', '#9575CD', '#7986CB', '#64B5F6',
            '#4FC3F7', '#4DD0E1', '#4DB6AC', '#81C784', '#AED581'
        ];
        
        window.onload = function() {
            if (typeof kakao === 'undefined') {
                showStatus('uploadStatus', 'âŒ ì¹´ì¹´ì˜¤ SDK ë¡œë“œ ì‹¤íŒ¨', 'error');
                return;
            }
            
            kakao.maps.load(function() {
                geocoder = new kakao.maps.services.Geocoder();
                initMap();
                // testGeocoderAPI();
                showStatus('uploadStatus', 'ğŸ“‚ ì—‘ì…€ íŒŒì¼ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”.', 'info');
            });
        };
        
        /*
        async function testGeocoderAPI() {
            const result = await geocodeAddress('ê²½ê¸° ê´‘ì£¼ì‹œ ê³¤ì§€ì•”ì ë§Œì‚¼ë¡œ 103-7');
            if (result) {
                showStatus('uploadStatus', `âœ… API ì—°ê²° ì„±ê³µ! íŒŒì¼ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”.`, 'success');
            }
        }
        */
        
        function initMap() {
            const container = document.getElementById('map');
            const options = {
                center: new kakao.maps.LatLng(37.5665, 126.9780),
                level: 8
            };
            map = new kakao.maps.Map(container, options);
        }
        
        function showStatus(elementId, message, type) {
            document.getElementById(elementId).innerHTML = `<div class="status ${type}">${message}</div>`;
        }
        
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, {type: 'array'});
                const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                const jsonData = XLSX.utils.sheet_to_json(firstSheet, {header: 1});
                
                uploadedData = jsonData.filter(row => row.length > 0);
                showStatus('uploadStatus', `âœ… ${uploadedData.length}ê°œ í–‰ ì—…ë¡œë“œ ì™„ë£Œ`, 'success');
                showColumnSelector();
            };
            reader.readAsArrayBuffer(file);
        }
        
        function showColumnSelector() {
            const previewSection = document.getElementById('previewSection');
            const addressColumnSelect = document.getElementById('addressColumn');
            
            previewSection.style.display = 'block';
            addressColumnSelect.innerHTML = '<option value="">-- ì£¼ì†Œ ì—´ ì„ íƒ --</option>';
            
            if (uploadedData.length > 0) {
                const headerRow = uploadedData[0];
                headerRow.forEach((header, i) => {
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = `${header} (ì—´ ${i + 1})`;
                    addressColumnSelect.appendChild(option);
                });
            }
            
            addressColumnSelect.onchange = function() {
                selectedColumn = parseInt(this.value);
                if (!isNaN(selectedColumn)) {
                    document.getElementById('convertBtn').disabled = false;
                }
            };
        }
        
        async function convertAddresses() {
            if (uploadedData.length <= 1 || isNaN(selectedColumn)) return;
            
            document.getElementById('convertBtn').disabled = true;
            document.getElementById('progressBar').style.display = 'block';
            document.getElementById('conversionStats').style.display = 'block';
            
            convertedData = [];
            let successCount = 0, failCount = 0;
            
            const headerRow = [...uploadedData[0], 'ìœ„ë„', 'ê²½ë„'];
            convertedData.push(headerRow);
            
            const dataRows = uploadedData.slice(1);
            document.getElementById('totalCount').textContent = dataRows.length;
            
            for (let i = 0; i < dataRows.length; i++) {
                const row = dataRows[i];
                const address = row[selectedColumn];
                
                document.getElementById('currentAddress').innerHTML = 
                    `ğŸ”„ (${i + 1}/${dataRows.length}): <strong>${address || 'ë¹ˆ ê°’'}</strong>`;
                
                if (!address) {
                    convertedData.push([...row, '', '']);
                    failCount++;
                } else {
                    const result = await geocodeAddress(address);
                    if (result) {
                        convertedData.push([...row, result.y, result.x]);
                        successCount++;
                    } else {
                        convertedData.push([...row, 'ë³€í™˜ ì‹¤íŒ¨', 'ë³€í™˜ ì‹¤íŒ¨']);
                        failCount++;
                    }
                }
                
                document.getElementById('successCount').textContent = successCount;
                document.getElementById('failCount').textContent = failCount;
                
                const progress = Math.round(((i + 1) / dataRows.length) * 100);
                document.getElementById('progressFill').style.width = progress + '%';
                document.getElementById('progressFill').textContent = progress + '%';
                
                await sleep(300);
            }
            
            showStatus('uploadStatus', `âœ… ì™„ë£Œ! ${successCount}/${dataRows.length}ê°œ ì„±ê³µ`, 'success');
            document.getElementById('downloadBtn').disabled = false;
            document.getElementById('optimizeBtn').disabled = false;
            document.getElementById('convertBtn').disabled = false;
        }
        
        function geocodeAddress(address) {
            return new Promise((resolve) => {
                if (!geocoder || !address || typeof address !== 'string') {
                    resolve(null);
                    return;
                }
                
                const originalAddress = address.trim();
                console.log(`\nğŸ” ì›ë³¸ ì£¼ì†Œ: "${originalAddress}"`);
                
                const cleaningSteps = [
                    (addr) => addr,
                    (addr) => addr.replace(/\([^)]*\)/g, '').trim(),
                    (addr) => addr.replace(/\([^)]*\)/g, '').replace(/[\.Â·,]+$/g, '').trim(),
                    (addr) => {
                        const cleaned = addr.replace(/\([^)]*\)/g, '').replace(/[\.Â·,]+$/g, '').trim();
                        const parts = cleaned.split(' ');
                        if (parts.length > 3) {
                            return parts.slice(0, -1).join(' ');
                        }
                        return cleaned;
                    },
                    (addr) => {
                        const cleaned = addr.replace(/\([^)]*\)/g, '').replace(/[\.Â·,]+$/g, '').trim();
                        const parts = cleaned.split(' ');
                        if (parts.length > 4) {
                            return parts.slice(0, -2).join(' ');
                        }
                        return null;
                    },
                    (addr) => {
                        const cleaned = addr.replace(/\([^)]*\)/g, '').trim();
                        const match = cleaned.match(/(.*?[ì‹œêµ°êµ¬].*?[ìë©´ë™ë¦¬])\s+[\d-]+/);
                        if (match) {
                            return match[0];
                        }
                        return null;
                    }
                ];
                
                attemptGeocodeSequentially(originalAddress, cleaningSteps, 0, resolve);
            });
        }
        
        function attemptGeocodeSequentially(originalAddress, cleaningSteps, stepIndex, finalResolve) {
            if (stepIndex >= cleaningSteps.length) {
                console.log('  âŒ ëª¨ë“  ì‹œë„ ì‹¤íŒ¨');
                finalResolve(null);
                return;
            }
            
            const cleanedAddress = cleaningSteps[stepIndex](originalAddress);
            
            if (!cleanedAddress || cleanedAddress === '') {
                attemptGeocodeSequentially(originalAddress, cleaningSteps, stepIndex + 1, finalResolve);
                return;
            }
            
            if (stepIndex > 0) {
                console.log(`  ì‹œë„ ${stepIndex + 1}: "${cleanedAddress}"`);
            }
            
            geocoder.addressSearch(cleanedAddress, function(result, status) {
                if (status === kakao.maps.services.Status.OK && result && result.length > 0) {
                    console.log(`  âœ… ì„±ê³µ! (ì‹œë„ ${stepIndex + 1}) ì¢Œí‘œ: (${result[0].y}, ${result[0].x})`);
                    finalResolve({ x: result[0].x, y: result[0].y, address: result[0].address_name });
                } else {
                    console.log(`  âŒ ì‹¤íŒ¨ (ì‹œë„ ${stepIndex + 1}, ìƒíƒœ: ${status})`);
                    attemptGeocodeSequentially(originalAddress, cleaningSteps, stepIndex + 1, finalResolve);
                }
            });
        }
        
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        function downloadExcel() {
            const ws = XLSX.utils.aoa_to_sheet(convertedData);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'ë³€í™˜ê²°ê³¼');
            XLSX.writeFile(wb, 'ì£¼ì†Œ_ìœ„ê²½ë„_ë³€í™˜_' + new Date().toISOString().slice(0,10) + '.xlsx');
        }
        
        async function optimizeRoute() {
            if (!geocoder || convertedData.length === 0) return;
            
            const startAddress = document.getElementById('startAddress').value.trim();
            if (!startAddress) {
                showStatus('optimizeStatus', 'âŒ ì¶œë°œì§€ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.', 'error');
                return;
            }
            
            console.log(`ğŸš€ ê²½ë¡œ ìºì‹œ: ${routeCache.size}ê°œ ì €ì¥ë¨`);
            
            document.getElementById('optimizeProgress').style.display = 'block';
            document.getElementById('optimizeBtn').disabled = true;
            
            startPoint = await geocodeAddress(startAddress);
            if (!startPoint) {
                showStatus('optimizeStatus', 'âŒ ì¶œë°œì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', 'error');
                document.getElementById('optimizeProgress').style.display = 'none';
                document.getElementById('optimizeBtn').disabled = false;
                return;
            }
            
            const maxHours = parseInt(document.getElementById('maxHours').value);
            const maxVisits = parseInt(document.getElementById('maxVisits').value);
            const avgStay = parseInt(document.getElementById('avgStay').value);
            
            const validLocations = convertedData.slice(1).filter(row => {
                const lat = parseFloat(row[row.length - 2]);
                const lng = parseFloat(row[row.length - 1]);
                return !isNaN(lat) && !isNaN(lng);
            });
            
            if (validLocations.length === 0) {
                showStatus('optimizeStatus', 'âŒ ìœ íš¨í•œ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.', 'error');
                document.getElementById('optimizeProgress').style.display = 'none';
                document.getElementById('optimizeBtn').disabled = false;
                return;
            }
            
            const schedule = await createSmartSchedule(validLocations, startPoint, maxHours, maxVisits, avgStay);
            finalSchedule = schedule;
            
            document.getElementById('optimizeProgress').style.display = 'none';
            displaySchedule(schedule);
            displayMarkersOnMap(schedule, startPoint);
            // displayLegend(schedule);
            document.getElementById('scheduleButtons').style.display = 'block';
            
            showStatus('optimizeStatus', 'âœ… ìµœì í™” ì™„ë£Œ!', 'success');
            document.getElementById('optimizeBtn').disabled = false;
        }
        
        async function createSmartSchedule(locations, start, maxHours, maxVisits, avgStay) {
            console.log(`\nğŸ“Š === ê°œì„ ëœ 2ë‹¨ê³„ ìµœì í™” ì‹œì‘ ===`);
            console.log(`ì´ ${locations.length}ê°œ ìœ„ì¹˜, ì¼ì¼ ìµœëŒ€ ${maxVisits}ê°œ ë°©ë¬¸`);
            
            // 1ë‹¨ê³„: ìƒì„¸ ì§€ì—­ë³„ ê·¸ë£¹í™”
            const cityGroups = groupByDetailedRegion(locations);
            console.log(`\nğŸ“ 1ë‹¨ê³„: ${cityGroups.length}ê°œ ì§€ì—­ìœ¼ë¡œ ë¶„ë¥˜ ì™„ë£Œ`);
            cityGroups.forEach(g => console.log(`  - ${g.name}: ${g.locations.length}ê°œ`));
            
            // 2ë‹¨ê³„: ê° ê·¸ë£¹ì˜ ì¤‘ì‹¬ì ê¹Œì§€ ì‹¤ì œ ê±°ë¦¬ ê³„ì‚°
            const groupsWithDistance = await calculateGroupDistances(cityGroups, start);
            
            // 3ë‹¨ê³„: ì¶œë°œì§€ì—ì„œ ê°€ê¹Œìš´ ìˆœìœ¼ë¡œ ì •ë ¬
            const orderedGroups = groupsWithDistance.sort((a, b) => a.distance - b.distance);
            console.log(`\nğŸš— ì¶œë°œì§€ ê¸°ì¤€ ì •ë ¬ ì™„ë£Œ`);
            orderedGroups.forEach(g => console.log(`  ${g.name}: ${g.distance.toFixed(1)}km`));
            
            // 4ë‹¨ê³„: ê° ê·¸ë£¹ ë‚´ì—ì„œ Greedy ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ì¼ì • ìƒì„±
            const schedule = await buildScheduleByGroups(orderedGroups, start, maxHours, maxVisits, avgStay, locations.length);
            
            const scheduledCount = schedule.reduce((sum, day) => sum + day.visits.length, 0);
            console.log(`\nğŸ“Š === ìµœì í™” ê²°ê³¼ ===`);
            console.log(`ì´ ${schedule.length}ì¼ ì¼ì •`);
            console.log(`ìŠ¤ì¼€ì¤„: ${scheduledCount}ê°œ / ì›ë³¸: ${locations.length}ê°œ`);
            
            if (scheduledCount !== locations.length) {
                console.error(`âš ï¸ ${locations.length - scheduledCount}ê°œ ìœ„ì¹˜ ëˆ„ë½!`);
            } else {
                console.log(`âœ… ëª¨ë“  ìœ„ì¹˜ í¬í•¨ ì™„ë£Œ!`);
            }
            
            return schedule;
        }
        
        function groupByDetailedRegion(locations) {
            const groups = {};
            
            locations.forEach(loc => {
                const addr = loc[selectedColumn] || loc[0];
                const normalized = addr.replace(/\s+/g, ' ').trim();
                
                let regionName = 'ê¸°íƒ€';
                
                // ë„ ë‹¨ìœ„ ì¶”ì¶œ íŒ¨í„´
                const provincePatterns = [
                    { pattern: /ì„œìš¸íŠ¹ë³„ì‹œ\s*([ê°€-í£]+êµ¬)/, prefix: 'ì„œìš¸' },
                    { pattern: /ê²½ê¸°ë„?\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ê²½ê¸°' },
                    { pattern: /ì¸ì²œê´‘ì—­ì‹œ\s*([ê°€-í£]+[êµ¬êµ°])/, prefix: 'ì¸ì²œ' },
                    { pattern: /ì¶©ì²­ë‚¨ë„\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ì¶©ë‚¨' },
                    { pattern: /ì¶©ë‚¨\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ì¶©ë‚¨' },
                    { pattern: /ì¶©ì²­ë¶ë„\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ì¶©ë¶' },
                    { pattern: /ì¶©ë¶\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ì¶©ë¶' },
                    { pattern: /ê°•ì›[ë„íŠ¹ë³„ìì¹˜ë„]*\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ê°•ì›' },
                    { pattern: /ì „ë¼ë‚¨ë„\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ì „ë‚¨' },
                    { pattern: /ì „ë‚¨\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ì „ë‚¨' },
                    { pattern: /ì „ë¼ë¶ë„\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ì „ë¶' },
                    { pattern: /ì „ë¶\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ì „ë¶' },
                    { pattern: /ê²½ìƒë‚¨ë„\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ê²½ë‚¨' },
                    { pattern: /ê²½ë‚¨\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ê²½ë‚¨' },
                    { pattern: /ê²½ìƒë¶ë„\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ê²½ë¶' },
                    { pattern: /ê²½ë¶\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ê²½ë¶' },
                    { pattern: /ì œì£¼[ë„íŠ¹ë³„ìì¹˜ë„]*\s*([ê°€-í£]+[ì‹œêµ°])/, prefix: 'ì œì£¼' },
                    { pattern: /ë¶€ì‚°ê´‘ì—­ì‹œ\s*([ê°€-í£]+[êµ¬êµ°])/, prefix: 'ë¶€ì‚°' },
                    { pattern: /ëŒ€êµ¬ê´‘ì—­ì‹œ\s*([ê°€-í£]+[êµ¬êµ°])/, prefix: 'ëŒ€êµ¬' },
                    { pattern: /ëŒ€ì „ê´‘ì—­ì‹œ\s*([ê°€-í£]+êµ¬)/, prefix: 'ëŒ€ì „' },
                    { pattern: /ê´‘ì£¼ê´‘ì—­ì‹œ\s*([ê°€-í£]+êµ¬)/, prefix: 'ê´‘ì£¼' },
                    { pattern: /ìš¸ì‚°ê´‘ì—­ì‹œ\s*([ê°€-í£]+[êµ¬êµ°])/, prefix: 'ìš¸ì‚°' },
                    { pattern: /ì„¸ì¢…íŠ¹ë³„ìì¹˜ì‹œ/, prefix: 'ì„¸ì¢…', noCity: true }
                ];
                
                // íŒ¨í„´ ë§¤ì¹­
                for (const { pattern, prefix, noCity } of provincePatterns) {
                    const match = normalized.match(pattern);
                    if (match) {
                        if (noCity) {
                            regionName = prefix;
                        } else {
                            regionName = `${prefix} ${match[1]}`;
                        }
                        break;
                    }
                }
                
                // ë§¤ì¹­ ì‹¤íŒ¨ ì‹œ ê¸°ë³¸ ì‹œ/êµ°/êµ¬ ì¶”ì¶œ
                if (regionName === 'ê¸°íƒ€') {
                    const basicMatch = normalized.match(/([ê°€-í£]+[ì‹œêµ°êµ¬])/);
                    if (basicMatch) {
                        regionName = basicMatch[1];
                    }
                }
                
                if (!groups[regionName]) {
                    groups[regionName] = [];
                }
                groups[regionName].push(loc);
            });
            
            // ê·¸ë£¹ ë°°ì—´ë¡œ ë³€í™˜ ë° ì¤‘ì‹¬ì  ê³„ì‚°
            return Object.entries(groups).map(([name, locs]) => {
                const centerLat = locs.reduce((s, l) => s + parseFloat(l[l.length - 2]), 0) / locs.length;
                const centerLng = locs.reduce((s, l) => s + parseFloat(l[l.length - 1]), 0) / locs.length;
                
                return {
                    name,
                    locations: locs,
                    center: { lat: centerLat, lng: centerLng }
                };
            });
        }
        
        async function calculateGroupDistances(groups, start) {
            const result = [];
            
            console.log(`\nğŸ” ê° ì§€ì—­ ì¤‘ì‹¬ì ê¹Œì§€ ì‹¤ì œ ê±°ë¦¬ ê³„ì‚° ì¤‘...`);
            
            for (const group of groups) {
                const routeInfo = await getKakaoRoute(
                    start.y, start.x,
                    group.center.lat, group.center.lng
                );
                
                result.push({
                    ...group,
                    distance: routeInfo.distance,
                    duration: routeInfo.duration
                });
                
                console.log(`  ${group.name}: ${routeInfo.distance.toFixed(1)}km (${routeInfo.duration}ë¶„)`);
                // sleep ì œê±° - ìºì‹±ìœ¼ë¡œ ì¶©ë¶„íˆ ë¹ ë¦„
            }
            
            return result;
        }
        
        async function buildScheduleByGroups(orderedGroups, start, maxHours, maxVisits, avgStay, totalCount) {
            let schedule = [];
            let currentDay = 1;
            let currentDayVisits = [];
            let currentPosition = start;
            let totalProcessed = 0;
            
            console.log(`\nğŸ¯ === ê·¸ë£¹ë³„ Greedy ìµœì í™” ì‹œì‘ ===`);
            
            for (let groupIdx = 0; groupIdx < orderedGroups.length; groupIdx++) {
                const group = orderedGroups[groupIdx];
                let remainingInGroup = [...group.locations];
                
                console.log(`\nğŸ™ï¸ ${group.name} ì²˜ë¦¬ ì¤‘ (${group.locations.length}ê°œ)`);
                
                document.getElementById('optimizeCurrentCity').textContent = 
                    `${group.name} ì²˜ë¦¬ ì¤‘ (${groupIdx + 1}/${orderedGroups.length})`;
                
                while (remainingInGroup.length > 0) {
                    const capacity = maxVisits - currentDayVisits.length;
                    const currentTime = currentDayVisits.reduce((s, v) => s + parseFloat(v.time), 0);
                    const remainTime = (maxHours * 60) - currentTime;
                    
                    if (capacity === 0 || (remainTime < 30 && currentDayVisits.length > 0)) {
                        if (currentDayVisits.length > 0) {
                            const firstVisit = currentDayVisits[0];
                            const lastVisit = currentDayVisits[currentDayVisits.length - 1];
                            
                            const toFirst = await getKakaoRoute(start.y, start.x, firstVisit.lat, firstVisit.lng);
                            const toStart = await getKakaoRoute(lastVisit.lat, lastVisit.lng, start.y, start.x);
                            
                            schedule.push({
                                day: currentDay,
                                visits: currentDayVisits,
                                departureTime: toFirst.duration,
                                returnTime: toStart.duration
                            });
                            
                            console.log(`  âœ… ${currentDay}ì¼ì°¨ ì™„ë£Œ: ${currentDayVisits.length}ê°œ`);
                            currentDay++;
                            currentDayVisits = [];
                            currentPosition = start;
                        }
                        continue;
                    }
                    
                    const progress = Math.round((totalProcessed / totalCount) * 100);
                    document.getElementById('optimizeProgressFill').style.width = progress + '%';
                    document.getElementById('optimizeProgressFill').textContent = progress + '%';
                    document.getElementById('optimizeDetail').textContent = 
                        `${totalProcessed}/${totalCount}ê°œ ì™„ë£Œ | ${group.name} ë‚´ ${remainingInGroup.length}ê°œ ë‚¨ìŒ`;
                    
                    // ğŸš€ ì†ë„ ê°œì„ : ì§ì„  ê±°ë¦¬ë¡œ ì‚¬ì „ í•„í„°ë§
                    const candidates = remainingInGroup
                        .map((loc, idx) => {
                            const lat = parseFloat(loc[loc.length - 2]);
                            const lng = parseFloat(loc[loc.length - 1]);
                            
                            if (isNaN(lat) || isNaN(lng)) return null;
                            
                            const straightDist = calculateDistance(
                                parseFloat(currentPosition.y), parseFloat(currentPosition.x),
                                lat, lng
                            );
                            
                            return { idx, loc, lat, lng, straightDist };
                        })
                        .filter(c => c !== null)
                        .sort((a, b) => a.straightDist - b.straightDist)
                        .slice(0, Math.min(5, remainingInGroup.length)); // ê°€ê¹Œìš´ 5ê°œë§Œ ì„ íƒ
                    
                    if (candidates.length === 0) {
                        console.error(`  âŒ ${group.name}ì—ì„œ ìœ íš¨í•œ ê²½ë¡œ ì—†ìŒ`);
                        break;
                    }
                    
                    // ğŸš€ ì„ íƒëœ í›„ë³´ë“¤ë§Œ API í˜¸ì¶œ (ë³‘ë ¬ ì²˜ë¦¬)
                    let nearestIdx = -1;
                    let minDuration = Infinity;
                    let nearestDistance = 0;
                    
                    const routePromises = candidates.map(async (candidate) => {
                        const routeInfo = await getKakaoRoute(
                            currentPosition.y, currentPosition.x, 
                            candidate.lat, candidate.lng
                        );
                        return { ...candidate, routeInfo };
                    });
                    
                    const routeResults = await Promise.all(routePromises);
                    
                    // ê°€ì¥ ê°€ê¹Œìš´ ê²ƒ ì„ íƒ
                    for (const result of routeResults) {
                        if (result.routeInfo.duration < minDuration) {
                            minDuration = result.routeInfo.duration;
                            nearestDistance = result.routeInfo.distance;
                            nearestIdx = result.idx;
                        }
                    }
                    
                    if (nearestIdx === -1) {
                        console.error(`  âŒ ${group.name}ì—ì„œ ìœ íš¨í•œ ê²½ë¡œ ì—†ìŒ`);
                        break;
                    }
                    
                    const nearest = remainingInGroup[nearestIdx];
                    const lat = parseFloat(nearest[nearest.length - 2]);
                    const lng = parseFloat(nearest[nearest.length - 1]);
                    
                    const estimatedTime = minDuration + avgStay;
                    const newTotalTime = currentTime + estimatedTime;
                    
                    // ğŸ†• 20km ì´ìƒì´ë©´ ë‹¤ìŒ ë‚ ë¡œ (ì‹œê°„/ìš©ëŸ‰ ì²´í¬ ì „ì—)
                    if (nearestDistance > 20 && currentDayVisits.length > 0) {
                        console.log(`  ğŸ“ ê±°ë¦¬ ì´ˆê³¼ (${nearestDistance.toFixed(1)}km > 20km), ë‹¤ìŒ ë‚ ë¡œ`);
                        
                        const firstVisit = currentDayVisits[0];
                        const lastVisit = currentDayVisits[currentDayVisits.length - 1];
                        
                        const toFirst = await getKakaoRoute(start.y, start.x, firstVisit.lat, firstVisit.lng);
                        const toStart = await getKakaoRoute(lastVisit.lat, lastVisit.lng, start.y, start.x);
                        
                        schedule.push({
                            day: currentDay,
                            visits: currentDayVisits,
                            departureTime: toFirst.duration,
                            returnTime: toStart.duration
                        });
                        
                        currentDay++;
                        currentDayVisits = [];
                        currentPosition = start;
                        continue;
                    }
                    
                    if (newTotalTime > maxHours * 60 && currentDayVisits.length > 0) {
                        console.log(`  â° ì‹œê°„ ì´ˆê³¼, ë‹¤ìŒ ë‚ ë¡œ`);
                        
                        const firstVisit = currentDayVisits[0];
                        const lastVisit = currentDayVisits[currentDayVisits.length - 1];
                        
                        const toFirst = await getKakaoRoute(start.y, start.x, firstVisit.lat, firstVisit.lng);
                        const toStart = await getKakaoRoute(lastVisit.lat, lastVisit.lng, start.y, start.x);
                        
                        schedule.push({
                            day: currentDay,
                            visits: currentDayVisits,
                            departureTime: toFirst.duration,
                            returnTime: toStart.duration
                        });
                        
                        currentDay++;
                        currentDayVisits = [];
                        currentPosition = start;
                        continue;
                    }
                    
                    currentDayVisits.push({
                        address: nearest[selectedColumn] || nearest[0],
                        lat, lng,
                        distance: nearestDistance.toFixed(2),
                        travelTime: minDuration.toFixed(0),
                        time: estimatedTime.toFixed(0),
                        data: nearest
                    });
                    
                    console.log(`    â• ${nearest[selectedColumn]?.substring(0, 30)} (${nearestDistance.toFixed(1)}km)`);
                    
                    currentPosition = { x: lng, y: lat };
                    remainingInGroup.splice(nearestIdx, 1);
                    totalProcessed++;
                }
                
                console.log(`  âœ… ${group.name} ì™„ë£Œ (${group.locations.length}ê°œ ì²˜ë¦¬)`);
            }
            
            if (currentDayVisits.length > 0) {
                const firstVisit = currentDayVisits[0];
                const lastVisit = currentDayVisits[currentDayVisits.length - 1];
                
                const toFirst = await getKakaoRoute(start.y, start.x, firstVisit.lat, firstVisit.lng);
                const toStart = await getKakaoRoute(lastVisit.lat, lastVisit.lng, start.y, start.x);
                
                schedule.push({
                    day: currentDay,
                    visits: currentDayVisits,
                    departureTime: toFirst.duration,
                    returnTime: toStart.duration
                });
                
                console.log(`  âœ… ${currentDay}ì¼ì°¨ ì™„ë£Œ (ë§ˆì§€ë§‰)`);
            }
            
            // ğŸ†• ì¼ì • ì¬ì¡°ì •: 50% ë¯¸ë§Œì¸ ë‚ ì€ 20km ì´ë‚´ ë‹¤ë¥¸ ë‚ ê³¼ ë³‘í•©
            console.log(`\nğŸ”„ === ì¼ì • ì¬ì¡°ì • ì‹œì‘ ===`);
            schedule = await rebalanceSchedule(schedule, maxVisits, start);
            
            return schedule;
        }
        
        async function rebalanceSchedule(schedule, maxVisits, start) {
            const threshold = Math.floor(maxVisits * 0.5);
            console.log(`ì¬ì¡°ì • ê¸°ì¤€: ${threshold}ê°œ ì´í•˜`);
            
            let changed = true;
            let iterations = 0;
            const maxIterations = 3;  // 5 â†’ 3ìœ¼ë¡œ ì¤„ì„
            
            while (changed && iterations < maxIterations) {
                changed = false;
                iterations++;
                console.log(`\nì¬ì¡°ì • ë°˜ë³µ ${iterations}íšŒ`);
                
                for (let i = 0; i < schedule.length; i++) {
                    const day = schedule[i];
                    
                    // 50% ë¯¸ë§Œì¸ ë‚  ì°¾ê¸°
                    if (day.visits.length > threshold) continue;
                    
                    console.log(`  ${day.day}ì¼ì°¨: ${day.visits.length}ê°œ (< ${threshold}ê°œ) - ì¬ì¡°ì • ëŒ€ìƒ`);
                    
                    // ë‹¤ë¥¸ ë‚ ë“¤ê³¼ ë³‘í•© ì‹œë„
                    for (let j = 0; j < schedule.length; j++) {
                        if (i === j) continue;
                        
                        const targetDay = schedule[j];
                        if (targetDay.visits.length >= maxVisits) continue;
                        
                        // ë‘ ë‚ ì˜ ë°©ë¬¸ì§€ë“¤ì´ 20km ì´ë‚´ì¸ì§€ í™•ì¸
                        const canMerge = checkMergeableDays(day, targetDay);
                        
                        if (canMerge && (day.visits.length + targetDay.visits.length) <= maxVisits) {
                            console.log(`    â†’ ${targetDay.day}ì¼ì°¨ì™€ ë³‘í•© ê°€ëŠ¥ (ì´ ${day.visits.length + targetDay.visits.length}ê°œ)`);
                            
                            // ë³‘í•©
                            targetDay.visits.push(...day.visits);
                            
                            // ë³‘í•©ëœ ë‚ ì„ ìµœì í™” (ê°€ê¹Œìš´ ìˆœì„œë¡œ ì¬ì •ë ¬)
                            targetDay.visits = await reorderVisits(targetDay.visits, start);
                            
                            // ì¶œë°œ/ê·€ê°€ ì‹œê°„ ì¬ê³„ì‚°
                            const firstVisit = targetDay.visits[0];
                            const lastVisit = targetDay.visits[targetDay.visits.length - 1];
                            const toFirst = await getKakaoRoute(start.y, start.x, firstVisit.lat, firstVisit.lng);
                            const toStart = await getKakaoRoute(lastVisit.lat, lastVisit.lng, start.y, start.x);
                            targetDay.departureTime = toFirst.duration;
                            targetDay.returnTime = toStart.duration;
                            
                            // ë¹ˆ ë‚  ì œê±°
                            schedule.splice(i, 1);
                            
                            // ì¼ì°¨ ë²ˆí˜¸ ì¬ì¡°ì •
                            schedule.forEach((d, idx) => d.day = idx + 1);
                            
                            changed = true;
                            console.log(`    âœ… ë³‘í•© ì™„ë£Œ`);
                            break;
                        }
                    }
                    
                    if (changed) break;
                }
            }
            
            console.log(`\nì¬ì¡°ì • ì™„ë£Œ: ${schedule.length}ì¼ ì¼ì •`);
            console.log(`ğŸ“Š ìºì‹œ íˆíŠ¸: ${routeCache.size}ê°œ ê²½ë¡œ ì €ì¥ë¨`);
            return schedule;
        }
        
        function checkMergeableDays(day1, day2) {
            // ë‘ ë‚ ì˜ ëª¨ë“  ë°©ë¬¸ì§€ ê°„ ê±°ë¦¬ê°€ 20km ì´ë‚´ì¸ì§€ í™•ì¸ (ì§ì„ ê±°ë¦¬)
            for (const visit1 of day1.visits) {
                for (const visit2 of day2.visits) {
                    const distance = calculateDistance(
                        parseFloat(visit1.lat), parseFloat(visit1.lng),
                        parseFloat(visit2.lat), parseFloat(visit2.lng)
                    );
                    
                    // ì§ì„ ê±°ë¦¬ê°€ 20km ë„˜ìœ¼ë©´ ì‹¤ì œ ê²½ë¡œëŠ” ë” ë©€ ê²ƒìœ¼ë¡œ íŒë‹¨
                    if (distance > 20) {
                        return false;
                    }
                }
            }
            return true;
        }
        
        async function reorderVisits(visits, start) {
            // Greedy ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ë°©ë¬¸ ìˆœì„œ ìµœì í™”
            const ordered = [];
            const remaining = [...visits];
            let currentPos = start;
            
            while (remaining.length > 0) {
                // ğŸš€ ì§ì„  ê±°ë¦¬ë¡œ ê°€ê¹Œìš´ 5ê°œë§Œ ì„ íƒ
                const candidates = remaining
                    .map((visit, idx) => {
                        const straightDist = calculateDistance(
                            parseFloat(currentPos.y), parseFloat(currentPos.x),
                            parseFloat(visit.lat), parseFloat(visit.lng)
                        );
                        return { idx, visit, straightDist };
                    })
                    .sort((a, b) => a.straightDist - b.straightDist)
                    .slice(0, Math.min(5, remaining.length));
                
                // ğŸš€ ë³‘ë ¬ë¡œ ê²½ë¡œ ê³„ì‚°
                const routePromises = candidates.map(async (candidate) => {
                    const route = await getKakaoRoute(
                        parseFloat(currentPos.y), 
                        parseFloat(currentPos.x),
                        parseFloat(candidate.visit.lat), 
                        parseFloat(candidate.visit.lng)
                    );
                    return { ...candidate, route };
                });
                
                const routeResults = await Promise.all(routePromises);
                
                // ê°€ì¥ ê°€ê¹Œìš´ ê²ƒ ì„ íƒ
                let bestResult = routeResults[0];
                for (const result of routeResults) {
                    if (result.route.distance < bestResult.route.distance) {
                        bestResult = result;
                    }
                }
                
                const nearest = remaining.splice(bestResult.idx, 1)[0];
                
                // ê±°ë¦¬/ì‹œê°„ ì—…ë°ì´íŠ¸
                nearest.distance = bestResult.route.distance.toFixed(2);
                nearest.travelTime = bestResult.route.duration.toFixed(0);
                const avgStay = parseInt(document.getElementById('avgStay').value) || 30;
                nearest.time = (bestResult.route.duration + avgStay).toFixed(0);
                
                ordered.push(nearest);
                currentPos = { y: nearest.lat, x: nearest.lng };
            }
            
            return ordered;
        }
        
        async function getKakaoRoute(startLat, startLng, endLat, endLng) {
            // ğŸ”§ íƒ€ì… ì•ˆì „ì„±: ìˆ«ìë¡œ ë³€í™˜
            startLat = parseFloat(startLat);
            startLng = parseFloat(startLng);
            endLat = parseFloat(endLat);
            endLng = parseFloat(endLng);
            
            // ìœ íš¨ì„± ê²€ì‚¬
            if (isNaN(startLat) || isNaN(startLng) || isNaN(endLat) || isNaN(endLng)) {
                console.error('Invalid coordinates:', { startLat, startLng, endLat, endLng });
                return { duration: 0, distance: 0 };
            }
            
            // ğŸš€ ìºì‹œ í‚¤ ìƒì„± (ì†Œìˆ˜ì  4ìë¦¬ë¡œ ë°˜ì˜¬ë¦¼)
            const cacheKey = `${startLat.toFixed(4)},${startLng.toFixed(4)}-${endLat.toFixed(4)},${endLng.toFixed(4)}`;
            
            // ìºì‹œì— ìˆìœ¼ë©´ ì¦‰ì‹œ ë°˜í™˜
            if (routeCache.has(cacheKey)) {
                return routeCache.get(cacheKey);
            }
            
            try {
                const url = `https://apis-navi.kakaomobility.com/v1/directions?origin=${startLng},${startLat}&destination=${endLng},${endLat}&priority=RECOMMEND`;
                const response = await fetch(url, {
                    headers: { 'Authorization': 'KakaoAK e7993bf34b2b04dcdeaf01bb36f06a85' }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.routes && data.routes.length > 0) {
                        const route = data.routes[0];
                        const result = {
                            duration: Math.round(route.summary.duration / 60),
                            distance: route.summary.distance / 1000
                        };
                        
                        // ìºì‹œì— ì €ì¥
                        routeCache.set(cacheKey, result);
                        return result;
                    }
                }
            } catch (error) {
                console.warn('Route API error:', error);
            }
            
            // API ì‹¤íŒ¨ ì‹œ ì§ì„  ê±°ë¦¬ë¡œ ì¶”ì •
            const distance = calculateDistance(startLat, startLng, endLat, endLng);
            const result = { 
                duration: Math.round((distance / 40) * 60), 
                distance 
            };
            
            // ì¶”ì •ê°’ë„ ìºì‹œì— ì €ì¥
            routeCache.set(cacheKey, result);
            return result;
        }
        
        function calculateDistance(lat1, lon1, lat2, lon2) {
            // ğŸ”§ íƒ€ì… ì•ˆì „ì„±: ìˆ«ìë¡œ ë³€í™˜
            lat1 = parseFloat(lat1);
            lon1 = parseFloat(lon1);
            lat2 = parseFloat(lat2);
            lon2 = parseFloat(lon2);
            
            if (isNaN(lat1) || isNaN(lon1) || isNaN(lat2) || isNaN(lon2)) {
                return 0;
            }
            
            const R = 6371;
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        function displaySchedule(schedule) {
            let html = '<div class="route-list">';
            
            schedule.forEach(day => {
                const totalDistance = day.visits.reduce((s, v) => s + parseFloat(v.distance), 0);
                const travelTime = day.visits.reduce((s, v) => s + parseFloat(v.time), 0);
                const totalTime = travelTime + (day.departureTime || 0) + (day.returnTime || 0);
                const color = dayColors[(day.day - 1) % dayColors.length];
                
                html += `
                    <div class="day-schedule" style="border-left: 5px solid ${color};">
                        <h3>ğŸ“ ${day.day}ì¼ì°¨ (${day.visits.length}ê°œ | ${totalDistance.toFixed(1)}km | ${(totalTime/60).toFixed(1)}ì‹œê°„)</h3>
                `;
                
                day.visits.forEach((visit, index) => {
                    html += `
                        <div class="visit-item">
                            <div>
                                <strong>${index + 1}. ${visit.address}</strong><br>
                                <small>ì´ë™: ${visit.distance}km (${visit.travelTime}ë¶„) | ì²´ë¥˜: ${document.getElementById('avgStay').value}ë¶„</small>
                            </div>
                        </div>
                    `;
                });
                
                html += '</div>';
            });
            
            html += '</div>';
            document.getElementById('routeResult').innerHTML = html;
        }
        
        /*
        function displayLegend(schedule) {
            let html = '<strong>ğŸ“ ì¼ì°¨ë³„ ìƒ‰ìƒ:</strong>';
            schedule.forEach(day => {
                const color = dayColors[(day.day - 1) % dayColors.length];
                html += `
                    <div class="legend-item">
                        <div class="legend-color" style="background: ${color};"></div>
                        <span>${day.day}ì¼ì°¨</span>
                    </div>
                `;
            });
            document.getElementById('legend').innerHTML = html;
            document.getElementById('legendSection').style.display = 'block';
        }
        */
        
        function displayMarkersOnMap(schedule, start) {
            if (!map) return;
            
            // ê¸°ì¡´ ë§ˆì»¤ ì œê±°
            markers.forEach(marker => {
                try {
                    if (marker && marker.setMap) {
                        marker.setMap(null);
                    }
                } catch (e) {
                    console.log('ë§ˆì»¤ ì œê±° ì¤‘ ì˜¤ë¥˜:', e);
                }
            });
            markers = [];
            
            const bounds = new kakao.maps.LatLngBounds();
            
            // ì¶œë°œì§€ ë§ˆì»¤
            try {
                const startPos = new kakao.maps.LatLng(parseFloat(start.y), parseFloat(start.x));
                const startMarker = new kakao.maps.Marker({
                    position: startPos,
                    map: map,
                    image: new kakao.maps.MarkerImage(
                        'https://t1.daumcdn.net/localimg/localimages/07/mapapidoc/markerStar.png',
                        new kakao.maps.Size(24, 35)
                    )
                });
                
                const startInfowindow = new kakao.maps.InfoWindow({
                    content: '<div style="padding:5px;font-size:12px;">ğŸ  ì¶œë°œì§€</div>'
                });
                startInfowindow.open(map, startMarker);
                markers.push(startMarker);
                bounds.extend(startPos);
            } catch (e) {
                console.error('ì¶œë°œì§€ ë§ˆì»¤ ìƒì„± ì˜¤ë¥˜:', e);
            }
            
            // ë°©ë¬¸ì§€ ë§ˆì»¤ ë° ê²½ë¡œì„ 
            schedule.forEach((day) => {
                const color = dayColors[(day.day - 1) % dayColors.length];
                
                day.visits.forEach((visit, visitIndex) => {
                    try {
                        const lat = parseFloat(visit.lat);
                        const lng = parseFloat(visit.lng);
                        
                        if (isNaN(lat) || isNaN(lng)) {
                            console.warn(`ìœ íš¨í•˜ì§€ ì•Šì€ ì¢Œí‘œ: ${visit.address}`);
                            return;
                        }
                        
                        const position = new kakao.maps.LatLng(lat, lng);
                        
                        // ê²½ë¡œì„  ê·¸ë¦¬ê¸°
                        if (visitIndex > 0) {
                            const prevVisit = day.visits[visitIndex - 1];
                            const prevLat = parseFloat(prevVisit.lat);
                            const prevLng = parseFloat(prevVisit.lng);
                            
                            if (!isNaN(prevLat) && !isNaN(prevLng)) {
                                const polyline = new kakao.maps.Polyline({
                                    path: [
                                        new kakao.maps.LatLng(prevLat, prevLng),
                                        position
                                    ],
                                    strokeWeight: 3,
                                    strokeColor: color,
                                    strokeOpacity: 0.7
                                });
                                polyline.setMap(map);
                                markers.push(polyline);
                            }
                        }
                        
                        // ğŸ¨ ìƒ‰ìƒ ìˆëŠ” ì»¤ìŠ¤í…€ ë§ˆì»¤ ìƒì„±
                        const markerContent = document.createElement('div');
                        markerContent.style.cssText = `
                            width: 36px;
                            height: 36px;
                            background: ${color};
                            border: 3px solid white;
                            border-radius: 50%;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-weight: bold;
                            color: white;
                            font-size: 14px;
                            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
                            cursor: pointer;
                            position: relative;
                        `;
                        markerContent.textContent = visitIndex + 1;
                        
                        // ì»¤ìŠ¤í…€ ì˜¤ë²„ë ˆì´ ìƒì„±
                        const customOverlay = new kakao.maps.CustomOverlay({
                            position: position,
                            content: markerContent,
                            yAnchor: 0.5,
                            zIndex: 3
                        });
                        
                        customOverlay.setMap(map);
                        
                        // ì¸í¬ìœˆë„ìš° ìƒì„±
                        const infowindow = new kakao.maps.InfoWindow({
                            content: `<div style="padding:8px;font-size:12px;min-width:150px;">
                                <strong style="color:${color};">${day.day}ì¼ì°¨-${visitIndex + 1}</strong><br>
                                ${visit.address}<br>
                                <small>ğŸš— ${visit.travelTime}ë¶„ | ğŸ“ ${visit.distance}km</small>
                            </div>`,
                            removable: false
                        });
                        
                        // ë§ˆì»¤ í´ë¦­ ì´ë²¤íŠ¸
                        markerContent.addEventListener('click', function() {
                            // ê¸°ì¡´ ì—´ë¦° ì¸í¬ìœˆë„ìš° ëª¨ë‘ ë‹«ê¸°
                            markers.forEach(m => {
                                if (m.infowindow && m.infowindow.close) {
                                    m.infowindow.close();
                                }
                            });
                            
                            // ì„ì‹œ ë§ˆì»¤ ìœ„ì¹˜ ìƒì„± (ì¸í¬ìœˆë„ìš° í‘œì‹œìš©)
                            const tempMarker = new kakao.maps.Marker({
                                position: position,
                                map: null
                            });
                            
                            infowindow.open(map, tempMarker);
                            
                            // 3ì´ˆ í›„ ìë™ ë‹«ê¸°
                            setTimeout(() => {
                                infowindow.close();
                            }, 3000);
                        });
                        
                        markers.push({
                            overlay: customOverlay,
                            infowindow: infowindow,
                            setMap: function(m) {
                                if (this.overlay) this.overlay.setMap(m);
                            }
                        });
                        
                        bounds.extend(position);
                        
                    } catch (e) {
                        console.error(`ë§ˆì»¤ ìƒì„± ì˜¤ë¥˜ (${visit.address}):`, e);
                    }
                });
            });
            
            // ì§€ë„ ë²”ìœ„ ì¡°ì •
            try {
                map.setBounds(bounds);
            } catch (e) {
                console.error('ì§€ë„ ë²”ìœ„ ì¡°ì • ì˜¤ë¥˜:', e);
            }
        }
        
        function downloadScheduleExcel() {
            if (!finalSchedule || !convertedData) return;
            
            console.log('\nğŸ“¥ === ì¼ì • íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì‹œì‘ ===');
            console.log(`convertedData í–‰ ìˆ˜: ${convertedData.length} (í—¤ë” í¬í•¨)`);
            console.log(`ë°ì´í„° í–‰ ìˆ˜: ${convertedData.length - 1}`);
            
            // ì›ë³¸ ë°ì´í„° ë³µì‚¬ (í–‰ ìˆœì„œ ìœ ì§€)
            const scheduleData = convertedData.map(row => [...row]);
            
            // í—¤ë”ì— "ì¼ì •" ì—´ ì¶”ê°€
            scheduleData[0].push('ì¼ì •');
            
            // ì¼ì • ë§¤í•‘ ìƒì„±
            const scheduleMap = new Map();
            const usedRows = new Set();  // ì´ë¯¸ ì‚¬ìš©ëœ í–‰ ì¶”ì 
            let totalScheduledVisits = 0;
            
            finalSchedule.forEach(day => {
                day.visits.forEach((visit, idx) => {
                    totalScheduledVisits++;
                    
                    // ì›ë³¸ ë°ì´í„°ì˜ í–‰ ë²ˆí˜¸ ì°¾ê¸° (ìœ„ë„/ê²½ë„ë¡œ ë§¤ì¹­, ì•„ì§ ì‚¬ìš©ë˜ì§€ ì•Šì€ í–‰ë§Œ)
                    for (let i = 1; i < convertedData.length; i++) {
                        // ì´ë¯¸ ì‚¬ìš©ëœ í–‰ì€ ìŠ¤í‚µ
                        if (usedRows.has(i)) continue;
                        
                        const row = convertedData[i];
                        const rowLat = parseFloat(row[row.length - 2]);
                        const rowLng = parseFloat(row[row.length - 1]);
                        
                        if (isNaN(rowLat) || isNaN(rowLng)) continue;
                        
                        if (Math.abs(rowLat - visit.lat) < 0.0001 && 
                            Math.abs(rowLng - visit.lng) < 0.0001) {
                            
                            const scheduleLabel = `Day${day.day}-${idx + 1}`;
                            scheduleMap.set(i, scheduleLabel);
                            usedRows.add(i);  // ì‚¬ìš©ëœ í–‰ìœ¼ë¡œ í‘œì‹œ
                            console.log(`  ë§¤ì¹­: í–‰${i} â†’ ${scheduleLabel} (${visit.address?.substring(0, 30)}...)`);
                            break;
                        }
                    }
                });
            });
            
            console.log(`\nì´ ìŠ¤ì¼€ì¤„ëœ ë°©ë¬¸: ${totalScheduledVisits}ê°œ`);
            console.log(`ë§¤ì¹­ëœ í–‰: ${scheduleMap.size}ê°œ`);
            
            if (totalScheduledVisits !== scheduleMap.size) {
                console.warn(`âš ï¸ ë§¤ì¹­ ëˆ„ë½: ${totalScheduledVisits - scheduleMap.size}ê°œ`);
            }
            
            // ì›ë³¸ ìˆœì„œëŒ€ë¡œ ì¼ì • ì •ë³´ ì¶”ê°€
            let addedCount = 0;
            for (let i = 1; i < scheduleData.length; i++) {
                const scheduleLabel = scheduleMap.get(i) || '';
                scheduleData[i].push(scheduleLabel);
                if (scheduleLabel) {
                    addedCount++;
                }
            }
            
            console.log(`ì¼ì •ì´ ì¶”ê°€ëœ í–‰: ${addedCount}ê°œ`);
            console.log(`ì²˜ë¦¬ëœ ì „ì²´ í–‰: ${scheduleData.length - 1}ê°œ (í—¤ë” ì œì™¸)`);
            
            // ë§ˆì§€ë§‰ ëª‡ í–‰ í™•ì¸
            console.log('\në§ˆì§€ë§‰ 5ê°œ í–‰ í™•ì¸:');
            for (let i = Math.max(1, scheduleData.length - 5); i < scheduleData.length; i++) {
                const row = scheduleData[i];
                const scheduleCol = row[row.length - 1];
                const address = row[selectedColumn]?.substring(0, 30) || 'ì£¼ì†Œì—†ìŒ';
                console.log(`  í–‰${i}: ì¼ì •="${scheduleCol}" | ì£¼ì†Œ="${address}"`);
            }
            
            const ws = XLSX.utils.aoa_to_sheet(scheduleData);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'ì¼ì •í‘œ');
            XLSX.writeFile(wb, 'ì¶œì¥ì¼ì •_' + new Date().toISOString().slice(0,10) + '.xlsx');
            
            console.log('\nâœ… ì¼ì • íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì™„ë£Œ');
        }
    </script>
</body>
</html>
